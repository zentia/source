<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: xxHash fast digest algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_runtime_2xx_hash_2doc_2xxhash__spec.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">xxHash fast digest algorithm</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md392"></a>
Notices</h2>
<p>Copyright (c) Yann Collet</p>
<p>Permission is granted to copy and distribute this document for any purpose and without charge, including translations into other languages and incorporation into compilations, provided that the copyright notice and this notice are preserved, and that any substantive changes or deletions from the original are clearly marked. Distribution of this document is unlimited.</p>
<h2><a class="anchor" id="autotoc_md393"></a>
Version</h2>
<p>0.2.0 (29/06/23)</p>
<h1><a class="anchor" id="autotoc_md394"></a>
Table of Contents</h1>
<ul>
<li>Introduction</li>
<li>XXH32 algorithm description</li>
<li>XXH64 algorithm description</li>
<li>XXH3 algorithm description<ul>
<li>Small inputs</li>
<li>Medium inputs</li>
<li>Large inputs</li>
</ul>
</li>
<li>Performance considerations</li>
<li>Reference Implementation</li>
</ul>
<h1><a class="anchor" id="autotoc_md395"></a>
Introduction</h1>
<p>This document describes the xxHash digest algorithm for both 32-bit and 64-bit variants, named <code>XXH32</code> and <code>XXH64</code>. The algorithm takes an input a message of arbitrary length and an optional seed value, then produces an output of 32 or 64-bit as "fingerprint" or "digest".</p>
<p>xxHash is primarily designed for speed. It is labeled non-cryptographic, and is not meant to avoid intentional collisions (same digest for 2 different messages), or to prevent producing a message with a predefined digest.</p>
<p>XXH32 is designed to be fast on 32-bit machines. XXH64 is designed to be fast on 64-bit machines. Both variants produce different output. However, a given variant shall produce exactly the same output, irrespective of the cpu / os used. In particular, the result remains identical whatever the endianness and width of the cpu is.</p>
<h2><a class="anchor" id="autotoc_md396"></a>
Operation notations</h2>
<p>All operations are performed modulo {32,64} bits. Arithmetic overflows are expected. <code>XXH32</code> uses 32-bit modular operations. <code>XXH64</code> and <code>XXH3</code> use 64-bit modular operations. When an operation ingests input or secret as multi-bytes values, it reads it using little-endian convention.</p>
<ul>
<li><code>+</code>: denotes modular addition</li>
<li><code>-</code>: denotes modular subtraction</li>
<li><code>*</code>: denotes modular multiplication<ul>
<li><b>Exception:</b> In <code>XXH3</code>, if it is in the form <code>(u128)x * (u128)y</code>, it denotes 64-bit by 64-bit normal multiplication into a full 128-bit result.</li>
</ul>
</li>
<li><code>X &lt;&lt;&lt; s</code>: denotes the value obtained by circularly shifting (rotating) <code>X</code> left by <code>s</code> bit positions.</li>
<li><code>X &gt;&gt; s</code>: denotes the value obtained by shifting <code>X</code> right by s bit positions. Upper <code>s</code> bits become <code>0</code>.</li>
<li><code>X &lt;&lt; s</code>: denotes the value obtained by shifting <code>X</code> left by s bit positions. Lower <code>s</code> bits become <code>0</code>.</li>
<li><code>X xor Y</code>: denotes the bit-wise XOR of <code>X</code> and <code>Y</code> (same width).</li>
<li><code>X | Y</code>: denotes the bit-wise OR of <code>X</code> and <code>Y</code> (same width).</li>
<li><code>~X</code>: denotes the bit-wise negation of <code>X</code>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md397"></a>
XXH32 Algorithm Description</h1>
<h2><a class="anchor" id="autotoc_md398"></a>
Overview</h2>
<p>We begin by supposing that we have a message of any length <code>L</code> as input, and that we wish to find its digest. Here <code>L</code> is an arbitrary nonnegative integer; <code>L</code> may be zero. The following steps are performed to compute the digest of the message.</p>
<p>The algorithm collect and transform input in <em>stripes</em> of 16 bytes. The transforms are stored inside 4 "accumulators", each one storing an unsigned 32-bit value. Each accumulator can be processed independently in parallel, speeding up processing for cpu with multiple execution units.</p>
<p>The algorithm uses 32-bits addition, multiplication, rotate, shift and xor operations. Many operations require some 32-bits prime number constants, all defined below:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u32 PRIME32_1 = 0x9E3779B1U;  <span class="comment">// 0b10011110001101110111100110110001</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u32 PRIME32_2 = 0x85EBCA77U;  <span class="comment">// 0b10000101111010111100101001110111</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u32 PRIME32_3 = 0xC2B2AE3DU;  <span class="comment">// 0b11000010101100101010111000111101</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u32 PRIME32_4 = 0x27D4EB2FU;  <span class="comment">// 0b00100111110101001110101100101111</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u32 PRIME32_5 = 0x165667B1U;  <span class="comment">// 0b00010110010101100110011110110001</span></div>
</div><!-- fragment --><p>These constants are prime numbers, and feature a good mix of bits 1 and 0, neither too regular, nor too dissymmetric. These properties help dispersion capabilities.</p>
<h2><a class="anchor" id="autotoc_md399"></a>
Step 1. Initialize internal accumulators</h2>
<p>Each accumulator gets an initial value based on optional <code>seed</code> input. Since the <code>seed</code> is optional, it can be <code>0</code>.</p>
<div class="fragment"><div class="line">u32 acc1 = seed + PRIME32_1 + PRIME32_2;</div>
<div class="line">u32 acc2 = seed + PRIME32_2;</div>
<div class="line">u32 acc3 = seed + 0;</div>
<div class="line">u32 acc4 = seed - PRIME32_1;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md400"></a>
Special case: input is less than 16 bytes</h3>
<p>When the input is too small (&lt; 16 bytes), the algorithm will not process any stripes. Consequently, it will not make use of parallel accumulators.</p>
<p>In this case, a simplified initialization is performed, using a single accumulator:</p>
<div class="fragment"><div class="line">u32 acc  = seed + PRIME32_5;</div>
</div><!-- fragment --><p>The algorithm then proceeds directly to step 4.</p>
<h2><a class="anchor" id="autotoc_md401"></a>
Step 2. Process stripes</h2>
<p>A stripe is a contiguous segment of 16 bytes. It is evenly divided into 4 <em>lanes</em>, of 4 bytes each. The first lane is used to update accumulator 1, the second lane is used to update accumulator 2, and so on.</p>
<p>Each lane read its associated 32-bit value using <b>little-endian</b> convention.</p>
<p>For each {lane, accumulator}, the update process is called a <em>round</em>, and applies the following formula:</p>
<div class="fragment"><div class="line">accN = accN + (laneN * PRIME32_2);</div>
<div class="line">accN = accN &lt;&lt;&lt; 13;</div>
<div class="line">accN = accN * PRIME32_1;</div>
</div><!-- fragment --><p>This shuffles the bits so that any bit from input <em>lane</em> impacts several bits in output <em>accumulator</em>. All operations are performed modulo 2^32.</p>
<p>Input is consumed one full stripe at a time. Step 2 is looped as many times as necessary to consume the whole input, except for the last remaining bytes which cannot form a stripe (&lt; 16 bytes). When that happens, move to step 3.</p>
<h2><a class="anchor" id="autotoc_md402"></a>
Step 3. Accumulator convergence</h2>
<p>All 4 lane accumulators from the previous steps are merged to produce a single remaining accumulator of the same width (32-bit). The associated formula is as follows:</p>
<div class="fragment"><div class="line">acc = (acc1 &lt;&lt;&lt; 1) + (acc2 &lt;&lt;&lt; 7) + (acc3 &lt;&lt;&lt; 12) + (acc4 &lt;&lt;&lt; 18);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md403"></a>
Step 4. Add input length</h2>
<p>The input total length is presumed known at this stage. This step is just about adding the length to accumulator, so that it participates to final mixing.</p>
<div class="fragment"><div class="line">acc = acc + (u32)inputLength;</div>
</div><!-- fragment --><p>Note that, if input length is so large that it requires more than 32-bits, only the lower 32-bits are added to the accumulator.</p>
<h2><a class="anchor" id="autotoc_md404"></a>
Step 5. Consume remaining input</h2>
<p>There may be up to 15 bytes remaining to consume from the input. The final stage will digest them according to following pseudo-code:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (remainingLength &gt;= 4) {</div>
<div class="line">    lane = read_32bit_little_endian(input_ptr);</div>
<div class="line">    acc = acc + lane * PRIME32_3;</div>
<div class="line">    acc = (acc &lt;&lt;&lt; 17) * PRIME32_4;</div>
<div class="line">    input_ptr += 4; remainingLength -= 4;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (remainingLength &gt;= 1) {</div>
<div class="line">    lane = read_byte(input_ptr);</div>
<div class="line">    acc = acc + lane * PRIME32_5;</div>
<div class="line">    acc = (acc &lt;&lt;&lt; 11) * PRIME32_1;</div>
<div class="line">    input_ptr += 1; remainingLength -= 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This process ensures that all input bytes are present in the final mix.</p>
<h2><a class="anchor" id="autotoc_md405"></a>
Step 6. Final mix (avalanche)</h2>
<p>The final mix ensures that all input bits have a chance to impact any bit in the output digest, resulting in an unbiased distribution. This is also called avalanche effect.</p>
<div class="fragment"><div class="line">acc = acc xor (acc &gt;&gt; 15);</div>
<div class="line">acc = acc * PRIME32_2;</div>
<div class="line">acc = acc xor (acc &gt;&gt; 13);</div>
<div class="line">acc = acc * PRIME32_3;</div>
<div class="line">acc = acc xor (acc &gt;&gt; 16);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md406"></a>
Step 7. Output</h2>
<p>The <code><a class="el" href="group___x_x_h32__family.html#ga49360c30d0eef2cd4e20cabfe6ab1c55" title="Calculates the 32-bit hash of input using xxHash32.">XXH32()</a></code> function produces an unsigned 32-bit value as output.</p>
<p>For systems which require to store and/or display the result in binary or hexadecimal format, the canonical format is defined to reproduce the same value as the natural decimal format, hence follows <b>big-endian</b> convention (most significant byte first).</p>
<h1><a class="anchor" id="autotoc_md407"></a>
XXH64 Algorithm Description</h1>
<h2><a class="anchor" id="autotoc_md408"></a>
Overview</h2>
<p><code>XXH64</code>'s algorithm structure is very similar to <code>XXH32</code> one. The major difference is that <code>XXH64</code> uses 64-bit arithmetic, speeding up memory transfer for 64-bit compliant systems, but also relying on cpu capability to efficiently perform 64-bit operations.</p>
<p>The algorithm collects and transforms input in <em>stripes</em> of 32 bytes. The transforms are stored inside 4 "accumulators", each one storing an unsigned 64-bit value. Each accumulator can be processed independently in parallel, speeding up processing for cpu with multiple execution units.</p>
<p>The algorithm uses 64-bit addition, multiplication, rotate, shift and xor operations. Many operations require some 64-bit prime number constants, all defined below:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME64_1 = 0x9E3779B185EBCA87ULL;  <span class="comment">// 0b1001111000110111011110011011000110000101111010111100101010000111</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME64_2 = 0xC2B2AE3D27D4EB4FULL;  <span class="comment">// 0b1100001010110010101011100011110100100111110101001110101101001111</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME64_3 = 0x165667B19E3779F9ULL;  <span class="comment">// 0b0001011001010110011001111011000110011110001101110111100111111001</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME64_4 = 0x85EBCA77C2B2AE63ULL;  <span class="comment">// 0b1000010111101011110010100111011111000010101100101010111001100011</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME64_5 = 0x27D4EB2F165667C5ULL;  <span class="comment">// 0b0010011111010100111010110010111100010110010101100110011111000101</span></div>
</div><!-- fragment --><p>These constants are prime numbers, and feature a good mix of bits 1 and 0, neither too regular, nor too dissymmetric. These properties help dispersion capabilities.</p>
<h2><a class="anchor" id="autotoc_md409"></a>
Step 1. Initialize internal accumulators</h2>
<p>Each accumulator gets an initial value based on optional <code>seed</code> input. Since the <code>seed</code> is optional, it can be <code>0</code>.</p>
<div class="fragment"><div class="line">u64 acc1 = seed + PRIME64_1 + PRIME64_2;</div>
<div class="line">u64 acc2 = seed + PRIME64_2;</div>
<div class="line">u64 acc3 = seed + 0;</div>
<div class="line">u64 acc4 = seed - PRIME64_1;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md410"></a>
Special case: input is less than 32 bytes</h3>
<p>When the input is too small (&lt; 32 bytes), the algorithm will not process any stripes. Consequently, it will not make use of parallel accumulators.</p>
<p>In this case, a simplified initialization is performed, using a single accumulator:</p>
<div class="fragment"><div class="line">u64 acc  = seed + PRIME64_5;</div>
</div><!-- fragment --><p>The algorithm then proceeds directly to step 4.</p>
<h2><a class="anchor" id="autotoc_md411"></a>
Step 2. Process stripes</h2>
<p>A stripe is a contiguous segment of 32 bytes. It is evenly divided into 4 <em>lanes</em>, of 8 bytes each. The first lane is used to update accumulator 1, the second lane is used to update accumulator 2, and so on.</p>
<p>Each lane read its associated 64-bit value using <b>little-endian</b> convention.</p>
<p>For each {lane, accumulator}, the update process is called a <em>round</em>, and applies the following formula:</p>
<div class="fragment"><div class="line">round(accN,laneN):</div>
<div class="line">  accN = accN + (laneN * PRIME64_2);</div>
<div class="line">  accN = accN &lt;&lt;&lt; 31;</div>
<div class="line">  <span class="keywordflow">return</span> accN * PRIME64_1;</div>
</div><!-- fragment --><p>This shuffles the bits so that any bit from input <em>lane</em> impacts several bits in output <em>accumulator</em>. All operations are performed modulo 2^64.</p>
<p>Input is consumed one full stripe at a time. Step 2 is looped as many times as necessary to consume the whole input, except for the last remaining bytes which cannot form a stripe (&lt; 32 bytes). When that happens, move to step 3.</p>
<h2><a class="anchor" id="autotoc_md412"></a>
Step 3. Accumulator convergence</h2>
<p>All 4 lane accumulators from previous steps are merged to produce a single remaining accumulator of same width (64-bit). The associated formula is as follows.</p>
<p>Note that accumulator convergence is more complex than 32-bit variant, and requires to define another function called <em>mergeAccumulator()</em>:</p>
<div class="fragment"><div class="line">mergeAccumulator(acc,accN):</div>
<div class="line">  acc  = acc xor round(0, accN);</div>
<div class="line">  acc  = acc * PRIME64_1;</div>
<div class="line">  <span class="keywordflow">return</span> acc + PRIME64_4;</div>
</div><!-- fragment --><p>which is then used in the convergence formula:</p>
<div class="fragment"><div class="line">acc = (acc1 &lt;&lt;&lt; 1) + (acc2 &lt;&lt;&lt; 7) + (acc3 &lt;&lt;&lt; 12) + (acc4 &lt;&lt;&lt; 18);</div>
<div class="line">acc = mergeAccumulator(acc, acc1);</div>
<div class="line">acc = mergeAccumulator(acc, acc2);</div>
<div class="line">acc = mergeAccumulator(acc, acc3);</div>
<div class="line">acc = mergeAccumulator(acc, acc4);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md413"></a>
Step 4. Add input length</h2>
<p>The input total length is presumed known at this stage. This step is just about adding the length to accumulator, so that it participates to final mixing.</p>
<div class="fragment"><div class="line">acc = acc + inputLength;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md414"></a>
Step 5. Consume remaining input</h2>
<p>There may be up to 31 bytes remaining to consume from the input. The final stage will digest them according to following pseudo-code:</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (remainingLength &gt;= 8) {</div>
<div class="line">    lane = read_64bit_little_endian(input_ptr);</div>
<div class="line">    acc = acc xor round(0, lane);</div>
<div class="line">    acc = (acc &lt;&lt;&lt; 27) * PRIME64_1;</div>
<div class="line">    acc = acc + PRIME64_4;</div>
<div class="line">    input_ptr += 8; remainingLength -= 8;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (remainingLength &gt;= 4) {</div>
<div class="line">    lane = read_32bit_little_endian(input_ptr);</div>
<div class="line">    acc = acc xor (lane * PRIME64_1);</div>
<div class="line">    acc = (acc &lt;&lt;&lt; 23) * PRIME64_2;</div>
<div class="line">    acc = acc + PRIME64_3;</div>
<div class="line">    input_ptr += 4; remainingLength -= 4;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (remainingLength &gt;= 1) {</div>
<div class="line">    lane = read_byte(input_ptr);</div>
<div class="line">    acc = acc xor (lane * PRIME64_5);</div>
<div class="line">    acc = (acc &lt;&lt;&lt; 11) * PRIME64_1;</div>
<div class="line">    input_ptr += 1; remainingLength -= 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This process ensures that all input bytes are present in the final mix.</p>
<h2><a class="anchor" id="autotoc_md415"></a>
Step 6. Final mix (avalanche)</h2>
<p>The final mix ensures that all input bits have a chance to impact any bit in the output digest, resulting in an unbiased distribution. This is also called avalanche effect.</p>
<div class="fragment"><div class="line">acc = acc xor (acc &gt;&gt; 33);</div>
<div class="line">acc = acc * PRIME64_2;</div>
<div class="line">acc = acc xor (acc &gt;&gt; 29);</div>
<div class="line">acc = acc * PRIME64_3;</div>
<div class="line">acc = acc xor (acc &gt;&gt; 32);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md416"></a>
Step 7. Output</h2>
<p>The <code><a class="el" href="group___x_x_h64__family.html#ga582b359c2b7a04d83837f58e72e60a09" title="Calculates the 64-bit hash of input using xxHash64.">XXH64()</a></code> function produces an unsigned 64-bit value as output.</p>
<p>For systems which require to store and/or display the result in binary or hexadecimal format, the canonical format is defined to reproduce the same value as the natural decimal format, hence follows <b>big-endian</b> convention (most significant byte first).</p>
<h1><a class="anchor" id="autotoc_md417"></a>
XXH3 Algorithm Overview</h1>
<p>XXH3 comes in two different versions: XXH3-64 and XXH3-128 (or XXH128), producing 64 and 128 bits of output, respectively.</p>
<p>XXH3 uses different algorithms for small (0-16 bytes), medium (17-240 bytes), and large (241+ bytes) inputs. The algorithms for small and medium inputs are optimized for performance. The three algorithms are described in the following sections.</p>
<p>Many operations require some 64-bit prime number constants, which are mostly the same constants used in XXH32 and XXH64, all defined below:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME32_1 = 0x9E3779B1U;  <span class="comment">// 0b10011110001101110111100110110001</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME32_2 = 0x85EBCA77U;  <span class="comment">// 0b10000101111010111100101001110111</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME32_3 = 0xC2B2AE3DU;  <span class="comment">// 0b11000010101100101010111000111101</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME64_1 = 0x9E3779B185EBCA87ULL;  <span class="comment">// 0b1001111000110111011110011011000110000101111010111100101010000111</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME64_2 = 0xC2B2AE3D27D4EB4FULL;  <span class="comment">// 0b1100001010110010101011100011110100100111110101001110101101001111</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME64_3 = 0x165667B19E3779F9ULL;  <span class="comment">// 0b0001011001010110011001111011000110011110001101110111100111111001</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME64_4 = 0x85EBCA77C2B2AE63ULL;  <span class="comment">// 0b1000010111101011110010100111011111000010101100101010111001100011</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME64_5 = 0x27D4EB2F165667C5ULL;  <span class="comment">// 0b0010011111010100111010110010111100010110010101100110011111000101</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME_MX1 = 0x165667919E3779F9ULL;  <span class="comment">// 0b0001011001010110011001111001000110011110001101110111100111111001</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u64 PRIME_MX2 = 0x9FB21C651E98DF25ULL;  <span class="comment">// 0b1001111110110010000111000110010100011110100110001101111100100101</span></div>
</div><!-- fragment --><p>The <code><a class="el" href="xxh__x86dispatch_8h.html#a3d8a8a2f1875f7d46d9acbc7658d40f2">XXH3_64bits()</a></code> function produces an unsigned 64-bit value. The <code><a class="el" href="xxh__x86dispatch_8h.html#a7bd9fdebde0f76eda9bda4fdb4b52090">XXH3_128bits()</a></code> function produces a <code><a class="el" href="struct_x_x_h128__hash__t.html" title="The return value from 128-bit hashes.">XXH128_hash_t</a></code> struct containing <code>low64</code> and <code>high64</code> - the lower and higher 64-bit half values of the result, respectively.</p>
<p>For systems requiring storing and/or displaying the result in binary or hexadecimal format, the canonical format is defined to reproduce the same value as the natural decimal format, hence following <b>big-endian</b> convention (most significant byte first).</p>
<h2><a class="anchor" id="autotoc_md418"></a>
Seed and Secret</h2>
<p>XXH3 provides seeded hashing by introducing two configurable constants used in the hashing process: the seed and the secret. The seed is an unsigned 64-bit value, and the secret is an array of bytes that is at least 136 bytes in size. The default seed is 0, and the default secret is the following 192-byte value:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8 defaultSecret[192] = {</div>
<div class="line">  0xb8, 0xfe, 0x6c, 0x39, 0x23, 0xa4, 0x4b, 0xbe, 0x7c, 0x01, 0x81, 0x2c, 0xf7, 0x21, 0xad, 0x1c,</div>
<div class="line">  0xde, 0xd4, 0x6d, 0xe9, 0x83, 0x90, 0x97, 0xdb, 0x72, 0x40, 0xa4, 0xa4, 0xb7, 0xb3, 0x67, 0x1f,</div>
<div class="line">  0xcb, 0x79, 0xe6, 0x4e, 0xcc, 0xc0, 0xe5, 0x78, 0x82, 0x5a, 0xd0, 0x7d, 0xcc, 0xff, 0x72, 0x21,</div>
<div class="line">  0xb8, 0x08, 0x46, 0x74, 0xf7, 0x43, 0x24, 0x8e, 0xe0, 0x35, 0x90, 0xe6, 0x81, 0x3a, 0x26, 0x4c,</div>
<div class="line">  0x3c, 0x28, 0x52, 0xbb, 0x91, 0xc3, 0x00, 0xcb, 0x88, 0xd0, 0x65, 0x8b, 0x1b, 0x53, 0x2e, 0xa3,</div>
<div class="line">  0x71, 0x64, 0x48, 0x97, 0xa2, 0x0d, 0xf9, 0x4e, 0x38, 0x19, 0xef, 0x46, 0xa9, 0xde, 0xac, 0xd8,</div>
<div class="line">  0xa8, 0xfa, 0x76, 0x3f, 0xe3, 0x9c, 0x34, 0x3f, 0xf9, 0xdc, 0xbb, 0xc7, 0xc7, 0x0b, 0x4f, 0x1d,</div>
<div class="line">  0x8a, 0x51, 0xe0, 0x4b, 0xcd, 0xb4, 0x59, 0x31, 0xc8, 0x9f, 0x7e, 0xc9, 0xd9, 0x78, 0x73, 0x64,</div>
<div class="line">  0xea, 0xc5, 0xac, 0x83, 0x34, 0xd3, 0xeb, 0xc3, 0xc5, 0x81, 0xa0, 0xff, 0xfa, 0x13, 0x63, 0xeb,</div>
<div class="line">  0x17, 0x0d, 0xdd, 0x51, 0xb7, 0xf0, 0xda, 0x49, 0xd3, 0x16, 0x55, 0x26, 0x29, 0xd4, 0x68, 0x9e,</div>
<div class="line">  0x2b, 0x16, 0xbe, 0x58, 0x7d, 0x47, 0xa1, 0xfc, 0x8f, 0xf8, 0xb8, 0xd1, 0x7a, 0xd0, 0x31, 0xce,</div>
<div class="line">  0x45, 0xcb, 0x3a, 0x8f, 0x95, 0x16, 0x04, 0x28, 0xaf, 0xd7, 0xfb, 0xca, 0xbb, 0x4b, 0x40, 0x7e,</div>
<div class="line">};</div>
</div><!-- fragment --><p>The seed and the secret can be optionally specified using the <code>*_withSecret</code> and <code>*_withSeed</code> versions of the hash function.</p>
<p>The seed and the secret cannot be specified simultaneously (<code>*_withSecretAndSeed</code> is actually <code>*_withSeed</code> for short and medium inputs &lt;= 240 bytes, and <code>*_withSecret</code> for large inputs). When one is specified, the other one uses the default value. There is one exception though: when input is large (&gt; 240 bytes) and a seed is given, a secret is derived from the seed value and the default secret using the following procedure:</p>
<div class="fragment"><div class="line">deriveSecret(u64 seed):</div>
<div class="line">  u64 derivedSecret[24] = defaultSecret[0:192];</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; 12; i++) {</div>
<div class="line">    derivedSecret[i*2] += seed;</div>
<div class="line">    derivedSecret[i*2+1] -= seed;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> derivedSecret; <span class="comment">// convert to u8[192] (little-endian)</span></div>
</div><!-- fragment --><p>The derivation treats the secrets as 24 64-bit values. In XXH3 algorithms, the secret is always read similarly by treating a contiguous segment of the array as one or more 32-bit or 64-bit values. <b>The secret values are always read using little-endian convention</b>.</p>
<h2><a class="anchor" id="autotoc_md419"></a>
Final Mixing Step (avalanche)</h2>
<p>To make sure that all input bits have a chance to impact any bit in the output digest (avalanche effect), the final step of the XXH3 algorithm is usually one of the two fixed operations that mix the bits in a 64-bit value. These operations are denoted <code>avalanche()</code> and <code>avalanche_XXH64()</code> in the following XXH3 description.</p>
<div class="fragment"><div class="line">avalanche(u64 <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a>):</div>
<div class="line">  <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> = <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> xor (<a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> &gt;&gt; 37);</div>
<div class="line">  <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> = <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> * PRIME_MX1;</div>
<div class="line">  <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> = <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> xor (<a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> &gt;&gt; 32);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a>;</div>
<div class="line"> </div>
<div class="line">avalanche_XXH64(u64 <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a>):</div>
<div class="line">  <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> = <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> xor (<a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> &gt;&gt; 33);</div>
<div class="line">  <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> = <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> * PRIME64_2;</div>
<div class="line">  <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> = <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> xor (<a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> &gt;&gt; 29);</div>
<div class="line">  <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> = <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> * PRIME64_3;</div>
<div class="line">  <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> = <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> xor (<a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a> &gt;&gt; 32);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_variable" href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a>;</div>
<div class="ttc" id="aoffscreen_8c_html_ad0da36b2558901e21e7a30f6c227a45e"><div class="ttname"><a href="offscreen_8c.html#ad0da36b2558901e21e7a30f6c227a45e">x</a></div><div class="ttdeci">float x</div><div class="ttdef"><b>定义</b> offscreen.c:41</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md420"></a>
XXH3 Algorithm Description (for small inputs)</h1>
<p>The algorithm for small inputs (0-16 bytes of input) is further divided into 4 cases: empty, 1-3 bytes, 4-8 bytes, and 9-16 bytes of input.</p>
<p>The algorithm uses byte-swap operations. The byte-swap operation reverses the byte order in a 32-bit or 64-bit value. It is denoted <code>bswap32</code> and <code>bswap64</code> for its 32-bit and 64-bit versions, respectively.</p>
<h2><a class="anchor" id="autotoc_md421"></a>
Empty input</h2>
<p>The hash of empty input is calculated from the seed and a segment of the secret:</p>
<div class="fragment"><div class="line">XXH3_64_empty():</div>
<div class="line">  u64 secretWords[2] = secret[56:72];</div>
<div class="line">  <span class="keywordflow">return</span> avalanche_XXH64(seed xor secretWords[0] xor secretWords[1]);</div>
<div class="line"> </div>
<div class="line">XXH3_128_empty():</div>
<div class="line">  u64 secretWords[4] = secret[64:96];</div>
<div class="line">  <span class="keywordflow">return</span> {avalanche_XXH64(seed xor secretWords[0] xor secretWords[1]), <span class="comment">// lower half</span></div>
<div class="line">          avalanche_XXH64(seed xor secretWords[2] xor secretWords[3])}; <span class="comment">// higher half</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md422"></a>
1-3 bytes of input</h2>
<p>The algorithm starts from a single 32-bit value combining the input bytes and its length:</p>
<div class="fragment"><div class="line">u32 combined = (u32)input[inputLength-1] | ((u32)inputLength &lt;&lt; 8) |</div>
<div class="line">               ((u32)input[0] &lt;&lt; 16) | ((u32)input[inputLength&gt;&gt;1] &lt;&lt; 24);</div>
<div class="line"><span class="comment">// LSB          8       16           24                    MSB</span></div>
<div class="line"><span class="comment">//  | last byte | length | first byte | middle-or-last byte |</span></div>
</div><!-- fragment --><p>Then the final output is calculated from the value and the first 8 bytes (XXH3-64) or 16 bytes (XXH3-128) of the secret to produce the final result. The secret here is read as 32-bit values instead of the usual 64-bit values.</p>
<div class="fragment"><div class="line">XXH3_64_1to3():</div>
<div class="line">  u32 secretWords[2] = secret[0:8];</div>
<div class="line">  u64 <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> = ((u64)(secretWords[0] xor secretWords[1]) + seed) xor (u64)combined;</div>
<div class="line">  <span class="keywordflow">return</span> avalanche_XXH64(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a>);</div>
<div class="line"> </div>
<div class="line">XXH3_128_1to3():</div>
<div class="line">  u32 secretWords[4] = secret[0:16];</div>
<div class="line">  u64 low = ((u64)(secretWords[0] xor secretWords[1]) + seed) xor (u64)combined;</div>
<div class="line">  u64 high = ((u64)(secretWords[2] xor secretWords[3]) - seed) xor (u64)(bswap32(combined) &lt;&lt;&lt; 13);</div>
<div class="line">  <span class="comment">// note that the bswap32(combined) &lt;&lt;&lt; 13 above is 32-bit rotate</span></div>
<div class="line">  <span class="keywordflow">return</span> {avalanche_XXH64(low), <span class="comment">// lower half</span></div>
<div class="line">          avalanche_XXH64(high)}; <span class="comment">// higher half</span></div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_a1b2be7bfa84f129a2690a62f3ad82d62"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a></div><div class="ttdeci">GLsizei GLboolean const GLfloat * value</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:325</div></div>
</div><!-- fragment --><p>Note that the XXH3-64 result is the lower half of XXH3-128 result.</p>
<h2><a class="anchor" id="autotoc_md423"></a>
4-8 bytes of input</h2>
<p>The algorithm starts from reading the first and last 4 bytes of the input as little-endian 32-bit values, and a modified seed:</p>
<div class="fragment"><div class="line">u32 inputFirst = input[0:4];</div>
<div class="line">u32 inputLast = input[inputLength-4:inputLength];</div>
<div class="line">u64 modifiedSeed = seed xor ((u64)bswap32((u32)lowerHalf(seed)) &lt;&lt; 32);</div>
</div><!-- fragment --><p>Again, these values are combined with a segment of the secret to produce the final value.</p>
<div class="fragment"><div class="line">XXH3_64_4to8():</div>
<div class="line">  u64 secretWords[2] = secret[8:24];</div>
<div class="line">  u64 combined = (u64)inputLast | ((u64)inputFirst &lt;&lt; 32);</div>
<div class="line">  u64 <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> = ((secretWords[0] xor secretWords[1]) - modifiedSeed) xor combined;</div>
<div class="line">  <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> = <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> xor (<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> &lt;&lt;&lt; 49) xor (<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> &lt;&lt;&lt; 24);</div>
<div class="line">  <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> = <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> * PRIME_MX2;</div>
<div class="line">  <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> = <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> xor ((<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> &gt;&gt; 35) + inputLength);</div>
<div class="line">  <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> = <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> * PRIME_MX2;</div>
<div class="line">  <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> = <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> xor (<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> &gt;&gt; 28);</div>
<div class="line">  <a class="code hl_define" href="sugar_8h.html#a6b8c693f1c0454a1128432b746966c17">return</a> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a>;</div>
<div class="line"> </div>
<div class="line">XXH3_128_4to8():</div>
<div class="line">  u64 secretWords[2] = secret[16:32];</div>
<div class="line">  u64 combined = (u64)inputFirst | ((u64)inputLast &lt;&lt; 32);</div>
<div class="line">  u64 <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> = ((secretWords[0] xor secretWords[1]) + modifiedSeed) xor combined;</div>
<div class="line">  u128 mulResult = (u128)<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> * (u128)(PRIME64_1 + (inputLength &lt;&lt; 2));</div>
<div class="line">  u64 high = higherHalf(mulResult); <span class="comment">// mulResult &gt;&gt; 64</span></div>
<div class="line">  u64 low = lowerHalf(mulResult); <span class="comment">// mulResult &amp; 0xFFFFFFFFFFFFFFFF</span></div>
<div class="line">  high = high + (low &lt;&lt; 1);</div>
<div class="line">  low = low xor (high &gt;&gt; 3);</div>
<div class="line">  low = low xor (low &gt;&gt; 35);</div>
<div class="line">  low = low * PRIME_MX2;</div>
<div class="line">  low = low xor (low &gt;&gt; 28);</div>
<div class="line">  high = avalanche(high);</div>
<div class="line">  <a class="code hl_define" href="sugar_8h.html#a6b8c693f1c0454a1128432b746966c17">return</a> {low, high};</div>
<div class="ttc" id="asugar_8h_html_a6b8c693f1c0454a1128432b746966c17"><div class="ttname"><a href="sugar_8h.html#a6b8c693f1c0454a1128432b746966c17">return</a></div><div class="ttdeci">#define return(...)</div><div class="ttdef"><b>定义</b> sugar.h:103</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md424"></a>
9-16 bytes of input</h2>
<p>The algorithm starts from reading the first and last 8 bytes of the input as little-endian 64-bit values:</p>
<div class="fragment"><div class="line">u64 inputFirst = input[0:8];</div>
<div class="line">u64 inputLast = input[inputLength-8:inputLength];</div>
</div><!-- fragment --><p>Once again, these values are combined with a segment of the secret to produce the final value.</p>
<div class="fragment"><div class="line">XXH3_64_9to16():</div>
<div class="line">  u64 secretWords[4] = secret[24:56];</div>
<div class="line">  u64 low = ((secretWords[0] xor secretWords[1]) + seed) xor inputFirst;</div>
<div class="line">  u64 high = ((secretWords[2] xor secretWords[3]) - seed) xor inputLast;</div>
<div class="line">  u128 mulResult = (u128)low * (u128)high;</div>
<div class="line">  u64 <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> = inputLength + bswap64(low) + high + (u64)(lowerHalf(mulResult) xor higherHalf(mulResult));</div>
<div class="line">  <span class="keywordflow">return</span> avalanche(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a>);</div>
<div class="line"> </div>
<div class="line">XXH3_128_9to16():</div>
<div class="line">  u64 secretWords[4] = secret[32:64];</div>
<div class="line">  u64 val1 = ((secretWords[0] xor secretWords[1]) - seed) xor inputFirst xor inputLast;</div>
<div class="line">  u64 val2 = ((secretWords[2] xor secretWords[3]) + seed) xor inputLast;</div>
<div class="line">  u128 mulResult = (u128)val1 * (u128)PRIME64_1;</div>
<div class="line">  u64 low = lowerHalf(mulResult) + ((u64)(inputLength - 1) &lt;&lt; 54);</div>
<div class="line">  u64 high = higherHalf(mulResult) + ((u64)higherHalf(val2) &lt;&lt; 32) + (u64)lowerHalf(val2) * PRIME32_2;</div>
<div class="line">  <span class="comment">// the above line can also be simplified to higherHalf(mulResult) + val2 + (u64)lowerHalf(val2) * (PRIME32_2 - 1);</span></div>
<div class="line">  low = low xor bswap64(high);</div>
<div class="line">  <span class="comment">// the following three lines are in fact a 128x64 -&gt; 128 multiplication ({low,high} = (u128){low,high} * PRIME64_2)</span></div>
<div class="line">  u128 mulResult2 = (u128)low * (u128)PRIME64_2;</div>
<div class="line">  low = lowerHalf(mulResult2);</div>
<div class="line">  high = higherHalf(mulResult2) + high * PRIME64_2;</div>
<div class="line">  <span class="keywordflow">return</span> {avalanche(low), <span class="comment">// lower half</span></div>
<div class="line">          avalanche(high)}; <span class="comment">// higher half</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md425"></a>
XXH3 Algorithm Description (for medium inputs)</h1>
<p>This algorithm is used for medium inputs (17-240 bytes of input). Its internal hash state is stored inside 1 (XXH3-64) or 2 (XXH3-128) "accumulators", each storing an unsigned 64-bit value.</p>
<h2><a class="anchor" id="autotoc_md426"></a>
Step 1. Initialize internal accumulators</h2>
<p>The accumulator(s) are initialized based on the input length.</p>
<div class="fragment"><div class="line"><span class="comment">// For XXH3-64</span></div>
<div class="line">u64 acc = inputLength * PRIME64_1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// For XXH3-128</span></div>
<div class="line">u64 acc[2] = {inputLength * PRIME64_1, 0};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md427"></a>
Step 2. Process the input</h2>
<p>This step is further divided into two cases: one for 17-128 bytes of input, and one for 129-240 bytes of input.</p>
<h3><a class="anchor" id="autotoc_md428"></a>
Mixing operation</h3>
<p>This step uses a mixing operation that mixes a 16-byte segment of data, a 16-byte segment of secret and the seed into a 64-bit value as a building block. This operation treat the segment of data and secret as little-endian 64-bit values.</p>
<div class="fragment"><div class="line">mixStep(u8 <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#abd87654504355b4c1bb002dcb1d4d16a">data</a>[16], <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a> secretOffset, u64 seed):</div>
<div class="line">  u64 dataWords[2] = <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#abd87654504355b4c1bb002dcb1d4d16a">data</a>[0:16];</div>
<div class="line">  u64 secretWords[2] = secret[secretOffset:secretOffset+16];</div>
<div class="line">  u128 mulResult = (u128)(dataWords[0] xor (secretWords[0] + seed)) *</div>
<div class="line">                   (u128)(dataWords[1] xor (secretWords[1] - seed));</div>
<div class="line">  <span class="keywordflow">return</span> lowerHalf(mulResult) xor higherHalf(mulResult);</div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_a3d1e3edfcf61ca2d831883e1afbad89e"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a></div><div class="ttdeci">GLsizeiptr size</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:272</div></div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_abd87654504355b4c1bb002dcb1d4d16a"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#abd87654504355b4c1bb002dcb1d4d16a">data</a></div><div class="ttdeci">GLint * data</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:199</div></div>
</div><!-- fragment --><p>The mixing operation is always invoked in groups of two in XXH3-128, where two 16-byte segments of data are mixed with a 32-byte segment of secret, and the accumulators are updated accordingly.</p>
<div class="fragment"><div class="line">mixTwoChunks(u8 data1[16], u8 data2[16], <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a> secretOffset, u64 seed):</div>
<div class="line">  u64 dataWords1[2] = data1[0:16]; <span class="comment">// again, little-endian conversion</span></div>
<div class="line">  u64 dataWords2[2] = data2[0:16];</div>
<div class="line">  acc[0] = acc[0] + mixStep(data1, secretOffset, seed);</div>
<div class="line">  acc[1] = acc[1] + mixStep(data2, secretOffset + 16, seed);</div>
<div class="line">  acc[0] = acc[0] xor (dataWords2[0] + dataWords2[1]);</div>
<div class="line">  acc[1] = acc[1] xor (dataWords1[0] + dataWords1[1]);</div>
</div><!-- fragment --><p>The input is split into several 16-byte chunks and mixed, and the result is added to the accumulator(s).</p>
<h3><a class="anchor" id="autotoc_md429"></a>
17-128 bytes of input</h3>
<p>The input is read as <em>N</em> 16-byte chunks starting from the beginning and <em>N</em> chunks starting from the end, where <em>N</em> is the smallest number that these 2*N* chunks cover the whole input. These chunks are paired up and mixed, and the results are accumulated to the accumulator(s).</p>
<div class="fragment"><div class="line"><span class="comment">// the loop variable `i` should be signed to avoid underflow in implementation</span></div>
<div class="line">processInput_XXH3_64_17to128():</div>
<div class="line">  u64 numRounds = ((inputLength - 1) &gt;&gt; 5) + 1;</div>
<div class="line">  <span class="keywordflow">for</span> (i = numRounds - 1; i &gt;= 0; i--) {</div>
<div class="line">    <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a> offsetStart = i*16;</div>
<div class="line">    <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a> offsetEnd = inputLength - i*16 - 16;</div>
<div class="line">    acc += mixStep(input[offsetStart:offsetStart+16], i*32, seed);</div>
<div class="line">    acc += mixStep(input[offsetEnd:offsetEnd+16], i*32+16, seed);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">processInput_XXH3_128_17to128():</div>
<div class="line">  u64 numRounds = ((inputLength - 1) &gt;&gt; 5) + 1;</div>
<div class="line">  <span class="keywordflow">for</span> (i = numRounds - 1; i &gt;= 0; i--) {</div>
<div class="line">    <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a> offsetStart = i*16;</div>
<div class="line">    <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a> offsetEnd = inputLength - i*16 - 16;</div>
<div class="line">    mixTwoChunks(input[offsetStart:offsetStart+16], input[offsetEnd:offsetEnd+16], i*32, seed);</div>
<div class="line">  }</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md430"></a>
129-240 bytes of input</h3>
<p>The input is split into 16-byte (XXH3-64) or 32-byte (XXH3-128) chunks. The first 128 bytes are first mixed chunk by chunk, followed by an intermediate avalanche operation. Then the remaining full chunks are processed, and finally the last 16/32 bytes are treated as a chunk to process.</p>
<div class="fragment"><div class="line">processInput_XXH3_64_129to240():</div>
<div class="line">  u64 numChunks = inputLength &gt;&gt; 4;</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++) {</div>
<div class="line">    acc += mixStep(input[i*16:i*16+16], i*16, seed);</div>
<div class="line">  }</div>
<div class="line">  acc = avalanche(acc);</div>
<div class="line">  <span class="keywordflow">for</span> (i = 8; i &lt; numChunks; i++) {</div>
<div class="line">    acc += mixStep(input[i*16:i*16+16], (i-8)*16 + 3, seed);</div>
<div class="line">  }</div>
<div class="line">  acc += mixStep(input[inputLength-16:inputLength], 119, seed);</div>
<div class="line"> </div>
<div class="line">processInput_XXH3_128_129to240():</div>
<div class="line">  u64 numChunks = inputLength &gt;&gt; 5;</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {</div>
<div class="line">    mixTwoChunks(input[i*32:i*32+16], input[i*32+16:i*32+32], i*32, seed);</div>
<div class="line">  }</div>
<div class="line">  acc[0] = avalanche(acc[0]);</div>
<div class="line">  acc[1] = avalanche(acc[1]);</div>
<div class="line">  <span class="keywordflow">for</span> (i = 4; i &lt; numChunks; i++) {</div>
<div class="line">    mixTwoChunks(input[i*32:i*32+16], input[i*32+16:i*32+32], (i-4)*32 + 3, seed);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// note that the half-chunk order and the seed is different here</span></div>
<div class="line">  mixTwoChunks(input[inputLength-16:inputLength], input[inputLength-32:inputLength-16], 103, (u64)0 - seed);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md431"></a>
Step 3. Finalization</h2>
<p>The final result is extracted from the accumulator(s).</p>
<div class="fragment"><div class="line">XXH3_64_17to240():</div>
<div class="line">  <a class="code hl_define" href="sugar_8h.html#a6b8c693f1c0454a1128432b746966c17">return</a> avalanche(acc);</div>
<div class="line"> </div>
<div class="line">XXH3_128_17to240():</div>
<div class="line">  u64 low = acc[0] + acc[1];</div>
<div class="line">  u64 high = (acc[0] * PRIME64_1) + (acc[1] * PRIME64_4) + (((u64)inputLength - seed) * PRIME64_2);</div>
<div class="line">  <span class="keywordflow">return</span> {avalanche(low), <span class="comment">// lower half</span></div>
<div class="line">          (u64)0 - avalanche(high)}; <span class="comment">// higher half</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md432"></a>
XXH3 Algorithm Description (for large inputs)</h1>
<p>This algorithm is used for inputs larger than 240 bytes. The internal hash state is stored inside 8 "accumulators", each one storing an unsigned 64-bit value.</p>
<h2><a class="anchor" id="autotoc_md433"></a>
Step 1. Initialize internal accumulators</h2>
<p>The accumulators are initialized to fixed constants:</p>
<div class="fragment"><div class="line">u64 acc[8] = {</div>
<div class="line">  PRIME32_3, PRIME64_1, PRIME64_2, PRIME64_3,</div>
<div class="line">  PRIME64_4, PRIME32_2, PRIME64_5, PRIME32_1};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md434"></a>
Step 2. Process blocks</h2>
<p>The input is consumed and processed one full block at a time. The size of the block depends on the length of the secret. Specifically, a block consists of several 64-byte stripes. The number of stripes per block is <code>floor((secretLength-64)/8)</code> . For the default 192-byte secret, there are 16 stripes in a block, and thus the block size is 1024 bytes.</p>
<div class="fragment"><div class="line">secretLength = lengthInBytes(secret);    <span class="comment">// default 192; at least 136</span></div>
<div class="line">stripesPerBlock = (secretLength-64) / 8; <span class="comment">// default 16; at least 9</span></div>
<div class="line">blockSize = 64 * stripesPerBlock;        <span class="comment">// default 1024; at least 576</span></div>
</div><!-- fragment --><p>The process of processing a full block is called a <em>round</em>. It consists of the following two sub-steps:</p>
<h3><a class="anchor" id="autotoc_md435"></a>
Step 2-1. Process stripes in the block</h3>
<p>A stripe is evenly divided into 8 lanes, of 8 bytes each. In an accumulation step, one stripe and a 64-byte contiguous segment of the secret are used to update the accumulators. Each lane reads its associated 64-bit value using little-endian convention.</p>
<p>The accumulation step applies the following procedure:</p>
<div class="fragment"><div class="line">accumulate(u64 stripe[8], <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a> secretOffset):</div>
<div class="line">  u64 secretWords[8] = secret[secretOffset:secretOffset+64];</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++) {</div>
<div class="line">    u64 <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a> = stripe[i] xor secretWords[i];</div>
<div class="line">    acc[i xor 1] = acc[i xor 1] + stripe[i];</div>
<div class="line">    acc[i] = acc[i] + (u64)lowerHalf(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a>) * (u64)higherHalf(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a1b2be7bfa84f129a2690a62f3ad82d62">value</a>);</div>
<div class="line">                      <span class="comment">// (value and 0xFFFFFFFF) * (value &gt;&gt; 32)</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p>The accumulation step is repeated for all stripes in a block, using different segments of the secret, starting from the first 64 bytes for the first stripe, and offset by 8 bytes for each following round:</p>
<div class="fragment"><div class="line">round_accumulate(u8 <a class="code hl_typedef" href="mimalloc_8h.html#a840cb394e7433c7fe0c4875a3030c955">block</a>[blockSize]):</div>
<div class="line">  <a class="code hl_define" href="sugar_8h.html#a750e3136a03cedcdb7f5f2de4b988f5b">for</a> (n = 0; n &lt; stripesPerBlock; n++) {</div>
<div class="line">    u64 stripe[8] = <a class="code hl_typedef" href="mimalloc_8h.html#a840cb394e7433c7fe0c4875a3030c955">block</a>[n*64:n*64+64]; <span class="comment">// 64 bytes = 8 u64s</span></div>
<div class="line">    accumulate(stripe, n*8);</div>
<div class="line">  }</div>
<div class="ttc" id="amimalloc_8h_html_a840cb394e7433c7fe0c4875a3030c955"><div class="ttname"><a href="mimalloc_8h.html#a840cb394e7433c7fe0c4875a3030c955">block</a></div><div class="ttdeci">const mi_heap_area_t void * block</div><div class="ttdef"><b>定义</b> mimalloc.h:265</div></div>
<div class="ttc" id="asugar_8h_html_a750e3136a03cedcdb7f5f2de4b988f5b"><div class="ttname"><a href="sugar_8h.html#a750e3136a03cedcdb7f5f2de4b988f5b">for</a></div><div class="ttdeci">#define for(x,...)</div><div class="ttdef"><b>定义</b> sugar.h:147</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md436"></a>
Step 2-2. Scramble accumulators</h3>
<p>After the accumulation steps are finished for all stripes in the block, the accumulators are scrambled using the last 64 bytes of the secret.</p>
<div class="fragment"><div class="line">round_scramble():</div>
<div class="line">  u64 secretWords[8] = secret[secretLength-64:secretLength];</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++) {</div>
<div class="line">    acc[i] = acc[i] xor (acc[i] &gt;&gt; 47);</div>
<div class="line">    acc[i] = acc[i] xor secretWords[i];</div>
<div class="line">    acc[i] = acc[i] * PRIME32_1;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>A round is thus a <code>round_accumulate</code> followed by a <code>round_scramble</code>:</p>
<div class="fragment"><div class="line">round(u8 <a class="code hl_typedef" href="mimalloc_8h.html#a840cb394e7433c7fe0c4875a3030c955">block</a>[blockSize]):</div>
<div class="line">  round_accumulate(<a class="code hl_typedef" href="mimalloc_8h.html#a840cb394e7433c7fe0c4875a3030c955">block</a>);</div>
<div class="line">  round_scramble();</div>
</div><!-- fragment --><p>Step 2 is looped to consume the input until there are less than or equal to <code>blockSize</code> bytes of input left. Note that we leave the last block to the next step even if it is a full block.</p>
<h2><a class="anchor" id="autotoc_md437"></a>
Step 3. Process the last block and the last 64 bytes</h2>
<p>Accumulation steps are run for the stripes in the last block, except for the last stripe (whether it is full or not). After that, run a final accumulation step by treating the last 64 bytes as a stripe. Note that the last 64 bytes might overlap with the second-to-last block.</p>
<div class="fragment"><div class="line"><span class="comment">// len is the size of the last block (1 &lt;= len &lt;= blockSize)</span></div>
<div class="line">lastRound(u8 <a class="code hl_typedef" href="mimalloc_8h.html#a840cb394e7433c7fe0c4875a3030c955">block</a>[], <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a> len, u64 lastStripe[8]):</div>
<div class="line">  <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a> nFullStripes = (len-1)/64;</div>
<div class="line">  <span class="keywordflow">for</span> (n = 0; n &lt; nFullStripes; n++) {</div>
<div class="line">    u64 stripe[8] = <a class="code hl_typedef" href="mimalloc_8h.html#a840cb394e7433c7fe0c4875a3030c955">block</a>[n*64:n*64+64];</div>
<div class="line">    accumulate(stripe, n * 8);</div>
<div class="line">  }</div>
<div class="line">  accumulate(lastStripe, secretLength - 71);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md438"></a>
Step 4. Finalization</h2>
<p>In the finalization step, a merging procedure is used to extract a single 64-bit value from the accumulators, using an initial seed value and a 64-byte segment of the secret.</p>
<div class="fragment"><div class="line">finalMerge(u64 initValue, <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a> secretOffset):</div>
<div class="line">  u64 secretWords[8] = secret[secretOffset:secretOffset+64];</div>
<div class="line">  u64 <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#aa7f56a70231ed8bc64f97aa7c37fcb19">result</a> = initValue;</div>
<div class="line">  <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {</div>
<div class="line">    <span class="comment">// 64-bit by 64-bit multiplication to 128-bit full result</span></div>
<div class="line">    u128 mulResult = (u128)(acc[i*2] xor secretWords[i*2]) *</div>
<div class="line">                     (u128)(acc[i*2+1] xor secretWords[i*2+1]);</div>
<div class="line">    <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#aa7f56a70231ed8bc64f97aa7c37fcb19">result</a> = <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#aa7f56a70231ed8bc64f97aa7c37fcb19">result</a> + (lowerHalf(mulResult) xor higherHalf(mulResult));</div>
<div class="line">                      <span class="comment">// (mulResult and 0xFFFFFFFFFFFFFFFF) xor (mulResult &gt;&gt; 64)</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> avalanche(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#aa7f56a70231ed8bc64f97aa7c37fcb19">result</a>);</div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_aa7f56a70231ed8bc64f97aa7c37fcb19"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#aa7f56a70231ed8bc64f97aa7c37fcb19">result</a></div><div class="ttdeci">GLuint GLuint64EXT * result</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:446</div></div>
</div><!-- fragment --><p>XXH3-128 runs the merging procedure twice for the two halves of the result, using different secret segments and different initial values derived from the total input length. The XXH3-64 result is just the lower half of the XXH3-128 result.</p>
<div class="fragment"><div class="line">XXH3_64_large():</div>
<div class="line">  <a class="code hl_define" href="sugar_8h.html#a6b8c693f1c0454a1128432b746966c17">return</a> finalMerge((u64)inputLength * PRIME64_1, 11);</div>
<div class="line"> </div>
<div class="line">XXH3_128_large():</div>
<div class="line">  <a class="code hl_define" href="sugar_8h.html#a6b8c693f1c0454a1128432b746966c17">return</a> {finalMerge((u64)inputLength * PRIME64_1, 11), <span class="comment">// lower half</span></div>
<div class="line">          finalMerge(~((u64)inputLength * PRIME64_2), secretLength - 75)}; <span class="comment">// higher half</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md439"></a>
Performance considerations</h1>
<p>The xxHash algorithms are simple and compact to implement. They provide a system independent "fingerprint" or digest of a message of arbitrary length.</p>
<p>The algorithm allows input to be streamed and processed in multiple steps. In such case, an internal buffer is needed to ensure data is presented to the algorithm in full stripes.</p>
<p>On 64-bit systems, the 64-bit variant <code>XXH64</code> is generally faster to compute, so it is a recommended variant, even when only 32-bit are needed.</p>
<p>On 32-bit systems though, positions are reversed: <code>XXH64</code> performance is reduced, due to its usage of 64-bit arithmetic. <code>XXH32</code> becomes a faster variant.</p>
<p>Finally, when vector operations are possible, <code>XXH3</code> is likely the faster variant.</p>
<h1><a class="anchor" id="autotoc_md440"></a>
Reference Implementation</h1>
<p>A reference library written in C is available at <a href="https://www.xxhash.com">https://www.xxhash.com</a>. The web page also links to multiple other implementations written in many different languages. It links to the <a href="https://github.com/Cyan4973/xxHash">github project page</a> where an <a href="https://github.com/Cyan4973/xxHash/issues">issue board</a> can be used for further public discussions on the topic.</p>
<h1><a class="anchor" id="autotoc_md441"></a>
Version changes</h1>
<p>v0.2.0: added XXH3 specification, by Adrien Wu v0.1.1: added a note on rationale for selection of constants v0.1.0: initial release </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
