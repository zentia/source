<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: Asynchronous Tasking with Dependencies</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_dependent_async_tasking.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Asynchronous Tasking with Dependencies</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>目录</h3>
<ul>
  <li class="level1">
    <a href="#CreateADynamicTaskGraph">Create a Dynamic Task Graph</a>
  </li>
  <li class="level1">
    <a href="#SpecifyARagneOfDependentAsyncTasks">Specify a Range of Dependent Async Tasks</a>
  </li>
  <li class="level1">
    <a href="#UnderstandTheLifeTimeOfADependentAsyncTask">Understand the Lifetime of a Dependent Async Task</a>
  </li>
  <li class="level1">
    <a href="#CreateADynamicTaskGraphByMultipleThreads">Create a Dynamic Task Graph by Multiple Threads</a>
  </li>
  <li class="level1">
    <a href="#QueryTheComppletionStatusOfDependentAsyncTasks">Query the Completion Status of Dependent Async Tasks</a>
  </li>
</ul>
</div>
<div class="textblock"><p>This chapters discusses how to create a task graph dynamically using asynchronous tasks, which is extremely beneficial for workloads that want to (1) explore task graph parallelism out of dynamic control flow or (2) overlap task graph creation time with individual task execution time. We recommend that you first read <a class="el" href="_async_tasking.html">Asynchronous Tasking</a> before digesting this chapter.</p>
<h1><a class="anchor" id="CreateADynamicTaskGraph"></a>
Create a Dynamic Task Graph</h1>
<p>When the construct-and-run model of a task graph is not possible in your application, you can use <a class="el" href="classtf_1_1_executor.html#aee02b63d3a91ad5ca5a1c0e71f3e128f" title="runs the given function asynchronously when the given dependents finish">tf::Executor::dependent_async</a> and <a class="el" href="classtf_1_1_executor.html#a0e2d792f28136b8227b413d0c27d5c7f" title="runs the given function asynchronously when the given dependents finish">tf::Executor::silent_dependent_async</a> to create a task graph dynamically. This type of parallelism is also known as <em>on-the-fly</em> task graph parallelism, which offers great flexibility for expressing dynamic task graph parallelism. The example below dynamically creates a task graph of four dependent-async tasks, <code><a class="el" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a></code>, <code><a class="el" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a></code>, <code>C</code>, and <code>D</code>, where <code><a class="el" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a></code> runs before <code><a class="el" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a></code> and <code>C</code> and <code>D</code> runs after <code><a class="el" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a></code> and <code>C:</code> </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1_executor.html">tf::Executor</a> <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>;</div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;A\n&quot;</span>); });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_typedef" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;B\n&quot;</span>); }, <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a>);</div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_define" href="test__buffer__node_8cpp.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;C\n&quot;</span>); }, <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a>);</div>
<div class="line"><span class="keyword">auto</span> [<a class="code hl_variable" href="_eigen_solver___eigen_solver___matrix_type_8cpp.html#a925331f9b6e4844293d36a8df2256d38">D</a>, fuD] = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.<a class="code hl_function" href="classtf_1_1_executor.html#aee02b63d3a91ad5ca5a1c0e71f3e128f">dependent_async</a>([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;D\n&quot;</span>); }, <a class="code hl_typedef" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a>, <a class="code hl_define" href="test__buffer__node_8cpp.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a>);</div>
<div class="line">fuD.get();  <span class="comment">// wait for D to finish, which in turn means A, B, C have finished</span></div>
<div class="ttc" id="a_eigen_solver___eigen_solver___matrix_type_8cpp_html_a925331f9b6e4844293d36a8df2256d38"><div class="ttname"><a href="_eigen_solver___eigen_solver___matrix_type_8cpp.html#a925331f9b6e4844293d36a8df2256d38">D</a></div><div class="ttdeci">MatrixXcd D</div><div class="ttdef"><b>定义</b> EigenSolver_EigenSolver_MatrixType.cpp:14</div></div>
<div class="ttc" id="abench__gemm_8cpp_html_a37a83060ac796961b44991c836f083f7"><div class="ttname"><a href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a></div><div class="ttdeci">Matrix&lt; SCALARB, Dynamic, Dynamic &gt; B</div><div class="ttdef"><b>定义</b> bench_gemm.cpp:36</div></div>
<div class="ttc" id="abench__gemm_8cpp_html_addc86e8508f14411ec98f521c520f875"><div class="ttname"><a href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a></div><div class="ttdeci">Matrix&lt; SCALARA, Dynamic, Dynamic &gt; A</div><div class="ttdef"><b>定义</b> bench_gemm.cpp:35</div></div>
<div class="ttc" id="aclasstf_1_1_async_task_html"><div class="ttname"><a href="classtf_1_1_async_task.html">tf::AsyncTask</a></div><div class="ttdoc">class to create a dependent asynchronous task (async task)</div><div class="ttdef"><b>定义</b> async_task.hpp:42</div></div>
<div class="ttc" id="aclasstf_1_1_executor_html"><div class="ttname"><a href="classtf_1_1_executor.html">tf::Executor</a></div><div class="ttdoc">class to create an executor for running a taskflow graph</div><div class="ttdef"><b>定义</b> executor-dl.hpp:51</div></div>
<div class="ttc" id="aclasstf_1_1_executor_html_aee02b63d3a91ad5ca5a1c0e71f3e128f"><div class="ttname"><a href="classtf_1_1_executor.html#aee02b63d3a91ad5ca5a1c0e71f3e128f">tf::Executor::dependent_async</a></div><div class="ttdeci">auto dependent_async(F &amp;&amp;func, Tasks &amp;&amp;... tasks)</div><div class="ttdoc">runs the given function asynchronously when the given dependents finish</div><div class="ttdef"><b>定义</b> async.hpp:148</div></div>
<div class="ttc" id="aprintf_8h_html_aee3ed3a831f25f07e7be3919fff2203a"><div class="ttname"><a href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a></div><div class="ttdeci">auto printf(string_view fmt, const T &amp;... args) -&gt; int</div><div class="ttdef"><b>定义</b> printf.h:621</div></div>
<div class="ttc" id="atest__buffer__node_8cpp_html_ac4cf4b2ab929bd23951a8676eeac086b"><div class="ttname"><a href="test__buffer__node_8cpp.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a></div><div class="ttdeci">#define C</div><div class="ttdef"><b>定义</b> test_buffer_node.cpp:28</div></div>
<div class="ttc" id="athread__pool_8cpp_html_a543e564a8407bbeac15cb2d929fec755"><div class="ttname"><a href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a></div><div class="ttdeci">tf::Executor executor</div><div class="ttdef"><b>定义</b> thread_pool.cpp:6</div></div>
</div><!-- fragment --><p>Both <a class="el" href="classtf_1_1_executor.html#aee02b63d3a91ad5ca5a1c0e71f3e128f" title="runs the given function asynchronously when the given dependents finish">tf::Executor::dependent_async</a> and <a class="el" href="classtf_1_1_executor.html#a0e2d792f28136b8227b413d0c27d5c7f" title="runs the given function asynchronously when the given dependents finish">tf::Executor::silent_dependent_async</a> create a task of type <a class="el" href="classtf_1_1_async_task.html" title="class to create a dependent asynchronous task (async task)">tf::AsyncTask</a> to run the given function asynchronously. Additionally, <a class="el" href="classtf_1_1_executor.html#aee02b63d3a91ad5ca5a1c0e71f3e128f" title="runs the given function asynchronously when the given dependents finish">tf::Executor::dependent_async</a> returns a @std_future that eventually holds the result of the execution. When returning from both calls, the executor has scheduled a worker to run the task whenever its dependencies are met. That is, task execution happens <em>simultaneously</em> with the creation of the task graph, which is different from constructing a Taskflow and running it from an executor, illustrated in the figure below:</p>
<div class="image">
<img src="images/dependent_async_execution_diagram.png" alt=""/>
</div>
<p>Since this model only allows relating a dependency from the current task to a previously created task, you need a correct topological order of graph expression. In our example, there are only two possible topological orderings, either <code>ABCD</code> or <code>ACBD</code>. The code below shows another feasible order of expressing this dynamic task graph parallelism:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1_executor.html">tf::Executor</a> <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>;</div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;A\n&quot;</span>); });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_define" href="test__buffer__node_8cpp.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;C\n&quot;</span>); }, <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a>);</div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_typedef" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;B\n&quot;</span>); }, <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a>);</div>
<div class="line"><span class="keyword">auto</span> [<a class="code hl_variable" href="_eigen_solver___eigen_solver___matrix_type_8cpp.html#a925331f9b6e4844293d36a8df2256d38">D</a>, fuD] = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.<a class="code hl_function" href="classtf_1_1_executor.html#aee02b63d3a91ad5ca5a1c0e71f3e128f">dependent_async</a>([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;D\n&quot;</span>); }, <a class="code hl_typedef" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a>, <a class="code hl_define" href="test__buffer__node_8cpp.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a>);</div>
<div class="line">fuD.get();  <span class="comment">// wait for D to finish, which in turn means A, B, C have finished</span></div>
</div><!-- fragment --><p>In addition to using @std_future to synchronize the execution, you can use <a class="el" href="classtf_1_1_executor.html#ab9aa252f70e9a40020a1e5a89d485b85" title="waits for all tasks to complete">tf::Executor::wait_for_all</a> to wait for all scheduled tasks to finish:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1_executor.html">tf::Executor</a> <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>;</div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;A\n&quot;</span>); });</div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_typedef" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;B\n&quot;</span>); }, <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a>);</div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_define" href="test__buffer__node_8cpp.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;C\n&quot;</span>); }, <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a>);</div>
<div class="line">tf::AsyncTask <a class="code hl_variable" href="_eigen_solver___eigen_solver___matrix_type_8cpp.html#a925331f9b6e4844293d36a8df2256d38">D</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.<a class="code hl_function" href="classtf_1_1_executor.html#a0e2d792f28136b8227b413d0c27d5c7f">silent_dependent_async</a>([](){ <a class="code hl_function" href="printf_8h.html#aee3ed3a831f25f07e7be3919fff2203a">printf</a>(<span class="stringliteral">&quot;D\n&quot;</span>); }, <a class="code hl_typedef" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a>, <a class="code hl_define" href="test__buffer__node_8cpp.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a>);</div>
<div class="line"><a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.<a class="code hl_function" href="classtf_1_1_executor.html#ab9aa252f70e9a40020a1e5a89d485b85">wait_for_all</a>();</div>
<div class="ttc" id="aclasstf_1_1_executor_html_a0e2d792f28136b8227b413d0c27d5c7f"><div class="ttname"><a href="classtf_1_1_executor.html#a0e2d792f28136b8227b413d0c27d5c7f">tf::Executor::silent_dependent_async</a></div><div class="ttdeci">tf::AsyncTask silent_dependent_async(F &amp;&amp;func, Tasks &amp;&amp;... tasks)</div><div class="ttdoc">runs the given function asynchronously when the given dependents finish</div><div class="ttdef"><b>定义</b> async.hpp:85</div></div>
<div class="ttc" id="aclasstf_1_1_executor_html_ab9aa252f70e9a40020a1e5a89d485b85"><div class="ttname"><a href="classtf_1_1_executor.html#ab9aa252f70e9a40020a1e5a89d485b85">tf::Executor::wait_for_all</a></div><div class="ttdeci">void wait_for_all()</div><div class="ttdoc">waits for all tasks to complete</div><div class="ttdef"><b>定义</b> executor-dl.hpp:2237</div></div>
</div><!-- fragment --><h1><a class="anchor" id="SpecifyARagneOfDependentAsyncTasks"></a>
Specify a Range of Dependent Async Tasks</h1>
<p>Both <a class="el" href="classtf_1_1_executor.html#aee02b63d3a91ad5ca5a1c0e71f3e128f" title="runs the given function asynchronously when the given dependents finish">tf::Executor::dependent_async(F&amp;&amp; func, Tasks&amp;&amp;... tasks)</a> and <a class="el" href="classtf_1_1_executor.html#a0e2d792f28136b8227b413d0c27d5c7f" title="runs the given function asynchronously when the given dependents finish">tf::Executor::silent_dependent_async(F&amp;&amp; func, Tasks&amp;&amp;... tasks)</a> accept an arbitrary number of tasks in the dependency list. If the number of task dependencies (i.e., predecessors) is unknown at programming time, such as those relying on runtime variables, you can use the following two overloads to specify predecessor tasks in an iterable range <code>[first, last)</code>:</p>
<ul>
<li><a class="el" href="classtf_1_1_executor.html#a01e51e564f5def845506bcf6b4bb1664" title="runs the given function asynchronously when the given range of dependents finish">tf::Executor::dependent_async(F&amp;&amp; func, I first, I last)</a></li>
<li><a class="el" href="classtf_1_1_executor.html#aa9b08e47e68ae1e568f18aa7104cb9b1" title="runs the given function asynchronously when the given range of dependents finish">tf::Executor::silent_dependent_async(F&amp;&amp; func, I first, I last)</a></li>
</ul>
<p>The code below creates an asynchronous task that depends on <code>N</code> previously created asynchronous tasks stored in a vector, where <code>N</code> is a runtime variable:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1_executor.html">tf::Executor</a> <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>;</div>
<div class="line">std::vector&lt;tf::AsyncTask&gt; predecessors;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=0; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;<a class="code hl_define" href="main-override-static_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++) {  <span class="comment">// N is a runtime variable</span></div>
<div class="line">  predecessors.push_back(<a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){}));</div>
<div class="line">}</div>
<div class="line"><a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){}, predecessors.begin(), predecessors.end());</div>
<div class="line"><a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.wait_for_all();</div>
<div class="ttc" id="a_bi_c_g_s_t_a_b__step__by__step_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>定义</b> BiCGSTAB_step_by_step.cpp:9</div></div>
<div class="ttc" id="amain-override-static_8c_html_a0240ac851181b84ac374872dc5434ee4"><div class="ttname"><a href="main-override-static_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a></div><div class="ttdeci">#define N</div><div class="ttdef"><b>定义</b> main-override-static.c:141</div></div>
</div><!-- fragment --><h1><a class="anchor" id="UnderstandTheLifeTimeOfADependentAsyncTask"></a>
Understand the Lifetime of a Dependent Async Task</h1>
<p><a class="el" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a> <a class="el" href="classtf_1_1_async_task.html" title="class to create a dependent asynchronous task (async task)">tf::AsyncTask</a> is a lightweight handle that retains <em>shared</em> ownership of a dependent-async task created by an executor. This shared ownership ensures that the async task remains alive when adding it to the dependency list of another async task, thus avoiding the classical <a href="https://en.wikipedia.org/wiki/ABA_problem">ABA problem</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// main thread retains shared ownership of async task A</span></div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// task A remains alive (i.e., at least one ref count by the main thread) </span></div>
<div class="line"><span class="comment">// when being added to the dependency list of async task B</span></div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_typedef" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){}, <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a>);</div>
</div><!-- fragment --><p>Currently, <a class="el" href="classtf_1_1_async_task.html" title="class to create a dependent asynchronous task (async task)">tf::AsyncTask</a> is implemented based on the logic of C++ smart pointer std::shared_ptr and is considered cheap to copy or move as long as only a handful of objects own it. When a worker completes an async task, it will remove the task from the executor, decrementing the number of shared owners by one. If that counter reaches zero, the task is destroyed.</p>
<h1><a class="anchor" id="CreateADynamicTaskGraphByMultipleThreads"></a>
Create a Dynamic Task Graph by Multiple Threads</h1>
<p>You can use multiple threads to create a dynamic task graph as long as the order of simultaneously creating tasks is topologically correct. The example below uses creates a dynamic task graph using three threads (including the main thread), where task <code><a class="el" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a></code> runs before task <code><a class="el" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a></code> and task <code>C:</code> </p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1_executor.html">tf::Executor</a> <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// main thread creates a dependent-async task A</span></div>
<div class="line"><a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// spawn a new thread to create an async task B that runs after A</span></div>
<div class="line">std::thread t1([&amp;](){</div>
<div class="line">  <a class="code hl_class" href="classtf_1_1_async_task.html">tf::AsyncTask</a> <a class="code hl_typedef" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.silent_dependent_async([](){}, <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// spawn a new thread to create an async task C that runs after A</span></div>
<div class="line">std::thread t2([&amp;](){</div>
<div class="line">  tf::AsyncTask <a class="code hl_define" href="test__buffer__node_8cpp.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a> = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.<a class="code hl_function" href="classtf_1_1_executor.html#a0e2d792f28136b8227b413d0c27d5c7f">silent_dependent_async</a>([](){}, <a class="code hl_typedef" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a>);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.<a class="code hl_function" href="classtf_1_1_executor.html#ab9aa252f70e9a40020a1e5a89d485b85">wait_for_all</a>();</div>
<div class="line">t1.join();</div>
<div class="line">t2.join();</div>
</div><!-- fragment --><p>Regardless of <code>t1</code> runs before or after <code>t2</code>, the resulting topological order is always correct with the graph definition, either <code>ABC</code> or <code>ACB</code>.</p>
<h1><a class="anchor" id="QueryTheComppletionStatusOfDependentAsyncTasks"></a>
Query the Completion Status of Dependent Async Tasks</h1>
<p>When you create a dependent-async task, you can query its completion status by <a class="el" href="classtf_1_1_async_task.html#aefeefa30d7cafdfbb7dc8def542e8e51" title="checks if the async task finishes">tf::AsyncTask::is_done</a>, which returns <code>true</code> upon completion or <code>false</code> otherwise. <a class="el" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a> completed dependent-async task indicates that a worker has executed its associated callable.</p>
<div class="fragment"><div class="line"><span class="comment">// create a dependent-async task that returns 100</span></div>
<div class="line"><span class="keyword">auto</span> [<a class="code hl_define" href="test__partitioner__whitebox_8h.html#a5c4cf3d37a4eee22275de22cb9619863">task</a>, fu] = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.dependent_async([](){ <span class="keywordflow">return</span> 100; });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// loops until the dependent-async task completes</span></div>
<div class="line"><span class="keywordflow">while</span>(!<a class="code hl_define" href="test__partitioner__whitebox_8h.html#a5c4cf3d37a4eee22275de22cb9619863">task</a>.is_done());</div>
<div class="line">assert(fu.get() == 100);</div>
<div class="ttc" id="atest__partitioner__whitebox_8h_html_a5c4cf3d37a4eee22275de22cb9619863"><div class="ttname"><a href="test__partitioner__whitebox_8h.html#a5c4cf3d37a4eee22275de22cb9619863">task</a></div><div class="ttdeci">#define task</div><div class="ttdef"><b>定义</b> test_partitioner_whitebox.h:76</div></div>
</div><!-- fragment --><p><a class="el" href="classtf_1_1_async_task.html#aefeefa30d7cafdfbb7dc8def542e8e51" title="checks if the async task finishes">tf::AsyncTask::is_done</a> is useful when you need to wait on the result of a dependent-async task before moving onto the next program instruction. Often, <a class="el" href="classtf_1_1_async_task.html" title="class to create a dependent asynchronous task (async task)">tf::AsyncTask</a> is used together with <a class="el" href="classtf_1_1_executor.html#a0fc6eb19f168dc4a9cd0a7c6187c1d2d" title="keeps running the work-stealing loop until the predicate becomes true">tf::Executor::corun_until</a> to keep a worker awake in its work-stealing loop to avoid deadlock (see <a class="el" href="_execute_taskflow.html#ExecuteATaskflowFromAnInternalWorker">Execute a Taskflow from an Internal Worker</a> for more details). For instance, the code below implements the famous Fibonacci sequence using recursive asynchronous tasking:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classtf_1_1_executor.html">tf::Executor</a> <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>;</div>
<div class="line">std::function&lt;<a class="code hl_define" href="sugar_8h.html#ae4f82344f573c70aa1066a2394bba345">int</a>(<span class="keywordtype">int</span>)&gt; <a class="code hl_variable" href="test__dependent__asyncs_8cpp.html#a5c51181711204e158d6c437667b95c4b">fibonacci</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// calculate the Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89</span></div>
<div class="line"><a class="code hl_variable" href="test__dependent__asyncs_8cpp.html#a5c51181711204e158d6c437667b95c4b">fibonacci</a> = [&amp;](<span class="keywordtype">int</span> <a class="code hl_define" href="main-override-static_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>){</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_define" href="main-override-static_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a> &lt; 2) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_define" href="main-override-static_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>; </div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">auto</span> [t1, fu1] = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.dependent_async(std::bind(<a class="code hl_variable" href="test__dependent__asyncs_8cpp.html#a5c51181711204e158d6c437667b95c4b">fibonacci</a>, <a class="code hl_define" href="main-override-static_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>-1));</div>
<div class="line">  <span class="keyword">auto</span> [t2, fu2] = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.dependent_async(std::bind(<a class="code hl_variable" href="test__dependent__asyncs_8cpp.html#a5c51181711204e158d6c437667b95c4b">fibonacci</a>, <a class="code hl_define" href="main-override-static_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>-2));</div>
<div class="line">  <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.corun_until([&amp;](){ <span class="keywordflow">return</span> t1.is_done() &amp;&amp; t2.is_done(); });</div>
<div class="line">  <span class="keywordflow">return</span> fu1.get() + fu2.get();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> [<a class="code hl_define" href="test__partitioner__whitebox_8h.html#a5c4cf3d37a4eee22275de22cb9619863">task</a>, fib11] = <a class="code hl_variable" href="thread__pool_8cpp.html#a543e564a8407bbeac15cb2d929fec755">executor</a>.<a class="code hl_function" href="classtf_1_1_executor.html#aee02b63d3a91ad5ca5a1c0e71f3e128f">dependent_async</a>(std::bind(<a class="code hl_variable" href="test__dependent__asyncs_8cpp.html#a5c51181711204e158d6c437667b95c4b">fibonacci</a>, 11));</div>
<div class="line">assert(fib11 == 89);  <span class="comment">// the 11-th Fibonacci number is 89</span></div>
<div class="ttc" id="asugar_8h_html_ae4f82344f573c70aa1066a2394bba345"><div class="ttname"><a href="sugar_8h.html#ae4f82344f573c70aa1066a2394bba345">int</a></div><div class="ttdeci">#define int</div><div class="ttdef"><b>定义</b> sugar.h:37</div></div>
<div class="ttc" id="atest__dependent__asyncs_8cpp_html_a5c51181711204e158d6c437667b95c4b"><div class="ttname"><a href="test__dependent__asyncs_8cpp.html#a5c51181711204e158d6c437667b95c4b">fibonacci</a></div><div class="ttdeci">std::vector&lt; unsigned long long int &gt; fibonacci</div><div class="ttdef"><b>定义</b> test_dependent_asyncs.cpp:899</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
