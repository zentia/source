<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: &lt;tt&gt;rfl::Result&lt;/tt&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_external_2reflect-cpp_2docs_2result.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">&lt;tt&gt;rfl::Result&lt;/tt&gt;</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md619"></a></p>
<p>In this documentation, we have, on several occasions, read a JSON string like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> homer = <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read&lt;Person&gt;</a>(json_string).value();</div>
<div class="ttc" id="anamespacerfl_1_1json_html_a905573518eca04a9c269d1bb32de7dd1"><div class="ttname"><a href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read</a></div><div class="ttdeci">auto read(const InputVarType &amp;_obj)</div><div class="ttdoc">Parses an object from a JSON var.</div><div class="ttdef"><b>定义</b> read.hpp:26</div></div>
</div><!-- fragment --><p>However, so far we have not elaborated on why <code>.<a class="el" href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value()</a></code> is necessary. Why can't we just do this?</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> homer = <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read&lt;Person&gt;</a>(json_string);</div>
</div><!-- fragment --><p>The reason is that parsing a JSON string is something that might fail. We do not know much about the string that put into there. It might not be a valid JSON. And even if it is a valid JSON, then it might not conform to the assumptions that we have made about it and laid out in the type system in the form of various structs and containers.</p>
<p><code><a class="el" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1" title="Parses an object from a JSON var.">rfl::json::read</a></code> handles this by returning an <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a></code> type. <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a></code> is a way of error handling without exceptions. This is needed for two reasons:</p>
<p>1) Exceptions are controversial, because they add another, hidden control path to your program that it hard to follow or predict. For this reasons, and others, the Google C++ style guide <a href="https://google.github.io/styleguide/cppguide.html#Exceptions">disallows exceptions altogether</a>. Modern programming languages like Go and Rust don't even support them in the first place. The C++ standards committee has recognized this and introduced <a href="https://en.cppreference.com/w/cpp/utility/expected">std::expected</a> in C++-23. However, reflect-cpp is a library for C++-20 and until that changes, we need to implement our own result type.</p>
<p>2) In some cases, you want to signal to the parser that is fine if some things go wrong. <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a></code> is the way to do that.</p>
<p>If you do not care about these objections to exceptions, you can just call <code><a class="el" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1" title="Parses an object from a JSON var.">rfl::json::read</a>&lt;...&gt;(json_string).<a class="el" href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value()</a></code>, which throws an exception, if the result type contains an error and be done with it.</p>
<p><b>Note</b>: If you want to use <code>std::expected</code> instead of our own Result type, you can pass <code>-DREFLECTCPP_USE_STD_EXPECTED</code> during compilation. This requires C++-23 support and may not be supported on all C++ compilers.</p>
<h1><a class="anchor" id="autotoc_md620"></a>
What is <code>rfl::Result</code>?</h1>
<p><code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a></code> is similar to <code>std::optional</code> it that it contains an object that may or may not be there. However, unlike <code>std::optional</code>, it does not simply contain <code>std::nullopt</code> if the operation has not been successful. Instead, it contains an <code><a class="el" href="classrfl_1_1_error.html" title="Defines the error class to be returned when something went wrong">rfl::Error</a></code> with a clear error message.</p>
<p>In laying out our structs an containers, about the the type system, we are making <em>requirements</em> about the JSON input we are expecting from the outside world. <code><a class="el" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1" title="Parses an object from a JSON var.">rfl::json::read</a>&lt;T&gt;(...)</code> checks whether these requirements are met. If the requirements are met, <code><a class="el" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1" title="Parses an object from a JSON var.">rfl::json::read</a>&lt;T&gt;</code> returns T wrapped inside <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a></code>. If they are not met, it returns <code><a class="el" href="classrfl_1_1_error.html" title="Defines the error class to be returned when something went wrong">rfl::Error</a></code> containing an error message explaining what went wrong.</p>
<h1><a class="anchor" id="autotoc_md621"></a>
Using <code>rfl::Result</code> for parsing</h1>
<p>Suppose you have a vector with 1000 user-supplied configurations:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> configs = <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read&lt;std::vector&lt;Config&gt;</a>&gt;(json_string);</div>
</div><!-- fragment --><p>Chances are that the user of your software has made as mistake in at least some of these configurations. If you set it up as shown above, <code><a class="el" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1" title="Parses an object from a JSON var.">rfl::json::read</a></code> will fail if one or more <code>Config</code> items contain an error. But sometimes you don't want that. Sometimes you want your software to proceed with the remaining 999 configurations and gently point out to the user that some of the configurations were faulty.</p>
<p>The solution is to this instead:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> configs = <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read&lt;std::vector&lt;rfl::Result&lt;Config&gt;</a>&gt;&gt;(json_string);</div>
</div><!-- fragment --><p>This means <code><a class="el" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1" title="Parses an object from a JSON var.">rfl::json::read</a></code> is going to cut the end-users of your software some slack. But it also means that you, as the programmer, have to handle the fact that some of the configs might contain errors.</p>
<p>Below, we will show you how to do that.</p>
<h1><a class="anchor" id="autotoc_md622"></a>
Monadic operations</h1>
<p>From the point of view of category theory, <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a></code> is both a functor and a monad (actually, all monads are functors).</p>
<p>This is reflected in its member functions <code>.transform(...)</code> and <code>.and_then(...)</code>.</p>
<p><code>.transform(...)</code> requires a function <code>F</code> of the type <code>T -&gt; U</code>. If the <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a>&lt;T&gt;</code> contains a type <code>T</code>, then <code>r.transform(f)</code> <em>will</em> return an <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a>&lt;U&gt;</code> containing a type <code>U</code>, otherwise it will return an <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a>&lt;U&gt;</code> containing an error.</p>
<p><code>.and_then(...)</code> requires a function <code>F</code> of the type <code>T -&gt; <a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a>&lt;U&gt;</code>. If the <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a>&lt;T&gt;</code> contains a type <code>T</code>, then <code>r.and_then(f)</code> <em>might</em> return an <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a>&lt;U&gt;</code> containing a type <code>U</code>, depending on whether <code>f</code> failed. If <code>r</code> already contained an error, then <code>r.and_then(f)</code> will surely return an <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a>&lt;U&gt;</code> containing an error.</p>
<p>Throughout reflect-cpp's code, these functions are widely used by the parser. For instance, consider how we are reading <code>std::unique_ptr&lt;T&gt;</code> (note that this is somewhat simplified):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> to_ptr = [](<span class="keyword">auto</span>&amp;&amp; _t) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;T&gt;(std::move(_t));</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">return</span> Parser&lt;T&gt;::read(_r, _var).transform(to_ptr);</div>
</div><!-- fragment --><p>This code works as follows: First, we read in a type <code>T</code>, which is something that might fail. However, we know 100% that once we have <code>T</code> we can surely wrap it inside a pointer, so we can call <code>.transform(...)</code>.</p>
<p>On the other hand, consider the implementation of <code><a class="el" href="namespacerfl_1_1json.html#ad44cd984a06c20921fc621d115e17cab">rfl::json::load</a></code>, which loads a JSON from a file:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div>
<div class="line">Result&lt;T&gt; load(<span class="keyword">const</span> std::string&amp; _fname) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacerfl_1_1io.html#abef8f6773d8fd7258ba35772521c371a">rfl::io::load_string</a>(_fname).and_then(<a class="code hl_function" href="json_2write__and__read_8hpp.html#a120a0c0f4f8f27e389e841e6f5f6efcd">read&lt;T&gt;</a>);</div>
<div class="line">}</div>
<div class="ttc" id="ajson_2write__and__read_8hpp_html_a120a0c0f4f8f27e389e841e6f5f6efcd"><div class="ttname"><a href="json_2write__and__read_8hpp.html#a120a0c0f4f8f27e389e841e6f5f6efcd">read</a></div><div class="ttdeci">void read(const std::string &amp;_json, const auto &amp;_expected)</div><div class="ttdef"><b>定义</b> write_and_read.hpp:24</div></div>
<div class="ttc" id="anamespacerfl_1_1io_html_abef8f6773d8fd7258ba35772521c371a"><div class="ttname"><a href="namespacerfl_1_1io.html#abef8f6773d8fd7258ba35772521c371a">rfl::io::load_string</a></div><div class="ttdeci">Result&lt; std::string &gt; load_string(const std::string &amp;_fname)</div><div class="ttdef"><b>定义</b> load_string.hpp:13</div></div>
</div><!-- fragment --><p>This code works as follows: First, we read in the text file using <code><a class="el" href="namespacerfl_1_1io.html#abef8f6773d8fd7258ba35772521c371a">rfl::io::load_string</a></code>. This an operation that might fail (maybe the file doesn't exist, maybe it isn't readable, ...). Then we have to to parse its contents using <code><a class="el" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1" title="Parses an object from a JSON var.">rfl::json::read</a>&lt;T&gt;</code>. Again, this is an operation that might fail (might not be a proper JSON, might not conform to our requirements, ...). Therefore, we have to call <code>.and_then(...)</code>.</p>
<h1><a class="anchor" id="autotoc_md623"></a>
Retrieving values or errors</h1>
<p>If you want the underlying value of type T, you can use <code>.<a class="el" href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value(...)</a></code>. Note that this throws an exception, if <code><a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a>&lt;T&gt;</code> contains an error.</p>
<p>If you are 100% sure that the result does not contain error, you can also call the operator <code>*</code>. This will lead to undefined behavior, if you are wrong.</p>
<p>If you want the underlying value of type T or some kind of default value, you can call <code>.value_or(your_default_value)</code>.</p>
<p>If you want to retrieve the error, you can call <code>.error()</code>, which will return a value of type <code><a class="el" href="classrfl_1_1_error.html" title="Defines the error class to be returned when something went wrong">rfl::Error</a></code>.</p>
<p>If you want to check whether the result contains an error, you can just use the bool operator:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (my_result) {</div>
<div class="line">  <span class="comment">// my_result cannot contain an error,</span></div>
<div class="line">  <span class="comment">// so it is okay to call operator *.</span></div>
<div class="line">  <span class="keyword">auto</span> <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a> = *my_result;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// my_result must contain an error.</span></div>
<div class="line">  <span class="keyword">auto</span> err = my_result.error();</div>
<div class="line">}</div>
<div class="ttc" id="a_cwise__arg_8cpp_html_a49bb5a0db288a22a099643d44c5abbd6"><div class="ttname"><a href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a></div><div class="ttdeci">ArrayXcf v</div><div class="ttdef"><b>定义</b> Cwise_arg.cpp:1</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md624"></a>
<code>rfl::error</code></h1>
<p><code><a class="el" href="namespacerfl.html#a6625864c6c297dfdc3d3c3ee3181dd8c" title="Shorthand for unexpected error.">rfl::error</a>("error message")</code> is a simple utility function for <code><a class="el" href="structrfl_1_1_unexpected.html" title="This implementation is for cases where std::expected is defined">rfl::Unexpected</a>&lt;Error&gt;(Error("error message"))</code>.</p>
<h1><a class="anchor" id="autotoc_md625"></a>
<code>.or_else(...)</code>, <code>.transform_error(...)</code></h1>
<p><code>r.or_else(f)</code> expects a function <code>f</code> for type <code>Error -&gt; <a class="el" href="classrfl_1_1_result.html" title="The Result class is used for monadic error handling.">rfl::Result</a>&lt;T&gt;</code>. It returns <code>r</code> if <code>r</code> did not contain an error and the results of <code>f</code> otherwise.</p>
<p><code>r.transform_error(f)</code> expects a function <code>f</code> for type <code>Error -&gt; Error</code>.</p>
<p>This is often used to produce better error messages:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> embellish_error = [&amp;](<span class="keyword">const</span> Error&amp; _e) -&gt; <a class="code hl_class" href="classrfl_1_1_result.html">rfl::Result&lt;T&gt;</a> {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacerfl.html#a6625864c6c297dfdc3d3c3ee3181dd8c">rfl::error</a>(<span class="stringliteral">&quot;Failed to parse field &#39;&quot;</span> + <a class="code hl_variable" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a> + <span class="stringliteral">&quot;&#39;: &quot;</span> + _e.what());</div>
<div class="line">};</div>
<div class="line"><span class="keywordflow">return</span> Parser&lt;T&gt;::read(_r, &amp;_var).<a class="code hl_function" href="classrfl_1_1_result.html#a19e6dc6bc58d0ed3555f9d448ce6d78c">transform_error</a>(embellish_error);</div>
<div class="ttc" id="aclassrfl_1_1_result_html"><div class="ttname"><a href="classrfl_1_1_result.html">rfl::Result</a></div><div class="ttdoc">The Result class is used for monadic error handling.</div><div class="ttdef"><b>定义</b> Result.hpp:68</div></div>
<div class="ttc" id="aclassrfl_1_1_result_html_a19e6dc6bc58d0ed3555f9d448ce6d78c"><div class="ttname"><a href="classrfl_1_1_result.html#a19e6dc6bc58d0ed3555f9d448ce6d78c">rfl::Result::transform_error</a></div><div class="ttdeci">rfl::Result&lt; T &gt; transform_error(F &amp;&amp;f) &amp;&amp;</div><div class="ttdef"><b>定义</b> Result.hpp:314</div></div>
<div class="ttc" id="aittnotify__static_8h_html_aeeaf6235e69da2907f537f67e598fc9d"><div class="ttname"><a href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a></div><div class="ttdeci">void const char const char int ITT_FORMAT __itt_group_sync x void const char ITT_FORMAT __itt_group_sync s void ITT_FORMAT __itt_group_sync p void ITT_FORMAT p void ITT_FORMAT p no args __itt_suppress_mode_t unsigned int void size_t ITT_FORMAT d void ITT_FORMAT p void ITT_FORMAT p __itt_model_site __itt_model_site_instance ITT_FORMAT p __itt_model_task __itt_model_task_instance ITT_FORMAT p void ITT_FORMAT p void ITT_FORMAT p void size_t ITT_FORMAT d void ITT_FORMAT p const wchar_t ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s no args void ITT_FORMAT p size_t ITT_FORMAT d no args const wchar_t const wchar_t ITT_FORMAT s __itt_heap_function void size_t int ITT_FORMAT d __itt_heap_function void ITT_FORMAT p __itt_heap_function void void size_t int ITT_FORMAT d no args no args unsigned int ITT_FORMAT u const __itt_domain __itt_id ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain __itt_id ITT_FORMAT p const __itt_domain __itt_id __itt_timestamp __itt_timestamp ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain ITT_FORMAT p const __itt_domain __itt_string_handle unsigned long long ITT_FORMAT lu const __itt_domain __itt_string_handle unsigned long long ITT_FORMAT lu const __itt_domain __itt_id __itt_string_handle * key</div><div class="ttdef"><b>定义</b> ittnotify_static.h:198</div></div>
<div class="ttc" id="anamespacerfl_html_a6625864c6c297dfdc3d3c3ee3181dd8c"><div class="ttname"><a href="namespacerfl.html#a6625864c6c297dfdc3d3c3ee3181dd8c">rfl::error</a></div><div class="ttdeci">Unexpected&lt; Error &gt; error(const std::string &amp;_what)</div><div class="ttdoc">Shorthand for unexpected error.</div><div class="ttdef"><b>定义</b> Result.hpp:388</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
