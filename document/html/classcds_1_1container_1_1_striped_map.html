<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: cds::container::StripedMap&lt; Container, Options &gt; 模板类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classcds_1_1container_1_1_striped_map.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="classcds_1_1container_1_1_striped_map-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">cds::container::StripedMap&lt; Container, Options &gt; 模板类 参考<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__map.html">Map</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Striped hash map  
 <a href="#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="striped__map_8h_source.html">striped_map.h</a>&gt;</code></p>
<div class="dynheader">
类 cds::container::StripedMap&lt; Container, Options &gt; 继承关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1container_1_1_striped_map__inherit__graph.png" border="0" usemap="#acds_1_1container_1_1_striped_map_3_01_container_00_01_options_01_4_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<div class="dynheader">
cds::container::StripedMap&lt; Container, Options &gt; 的协作图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1container_1_1_striped_map__coll__graph.png" border="0" usemap="#acds_1_1container_1_1_striped_map_3_01_container_00_01_options_01_4_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:a2e8f54fde7d2f4330dbbd32e32da715a" id="r_a2e8f54fde7d2f4330dbbd32e32da715a"><td class="memItemLeft" align="right" valign="top">typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e8f54fde7d2f4330dbbd32e32da715a">underlying_container_type</a></td></tr>
<tr class="memdesc:a2e8f54fde7d2f4330dbbd32e32da715a"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket  <br /></td></tr>
<tr class="separator:a2e8f54fde7d2f4330dbbd32e32da715a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41155b6b3ff185f4ee4a64bdf256c7d" id="r_af41155b6b3ff185f4ee4a64bdf256c7d"><td class="memItemLeft" align="right" valign="top">typedef base_class::bucket_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af41155b6b3ff185f4ee4a64bdf256c7d">bucket_type</a></td></tr>
<tr class="memdesc:af41155b6b3ff185f4ee4a64bdf256c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set  <br /></td></tr>
<tr class="separator:af41155b6b3ff185f4ee4a64bdf256c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc37b83c74cd041b958aba25ff3ea079" id="r_abc37b83c74cd041b958aba25ff3ea079"><td class="memItemLeft" align="right" valign="top">typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc37b83c74cd041b958aba25ff3ea079">value_type</a></td></tr>
<tr class="memdesc:abc37b83c74cd041b958aba25ff3ea079"><td class="mdescLeft">&#160;</td><td class="mdescRight">pair type (<code> std::pair&lt;key_type const, mapped_type&gt; </code>)  <br /></td></tr>
<tr class="separator:abc37b83c74cd041b958aba25ff3ea079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d2f85653d88cea2e02fc6c39a5d2b3" id="r_a95d2f85653d88cea2e02fc6c39a5d2b3"><td class="memItemLeft" align="right" valign="top">typedef value_type::first_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95d2f85653d88cea2e02fc6c39a5d2b3">key_type</a></td></tr>
<tr class="memdesc:a95d2f85653d88cea2e02fc6c39a5d2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">key type  <br /></td></tr>
<tr class="separator:a95d2f85653d88cea2e02fc6c39a5d2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd34343ee928de44a8d121cfdbb11b9" id="r_abcd34343ee928de44a8d121cfdbb11b9"><td class="memItemLeft" align="right" valign="top">typedef value_type::second_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcd34343ee928de44a8d121cfdbb11b9">mapped_type</a></td></tr>
<tr class="memdesc:abcd34343ee928de44a8d121cfdbb11b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">mapped type  <br /></td></tr>
<tr class="separator:abcd34343ee928de44a8d121cfdbb11b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1b0a9b45e942498737a5652b325e26" id="r_a6b1b0a9b45e942498737a5652b325e26"><td class="memItemLeft" align="right" valign="top">typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b1b0a9b45e942498737a5652b325e26">hash</a></td></tr>
<tr class="memdesc:a6b1b0a9b45e942498737a5652b325e26"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_hash.html">Hash</a> functor  <br /></td></tr>
<tr class="separator:a6b1b0a9b45e942498737a5652b325e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4097c7d9306f06b3fb0ef3f351387040" id="r_a4097c7d9306f06b3fb0ef3f351387040"><td class="memItemLeft" align="right" valign="top">typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4097c7d9306f06b3fb0ef3f351387040">item_counter</a></td></tr>
<tr class="memdesc:a4097c7d9306f06b3fb0ef3f351387040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter  <br /></td></tr>
<tr class="separator:a4097c7d9306f06b3fb0ef3f351387040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3155c54ac7cc35f2ab627ce6eb7333e3" id="r_a3155c54ac7cc35f2ab627ce6eb7333e3"><td class="memItemLeft" align="right" valign="top">typedef base_class::resizing_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a></td></tr>
<tr class="memdesc:a3155c54ac7cc35f2ab627ce6eb7333e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy  <br /></td></tr>
<tr class="separator:a3155c54ac7cc35f2ab627ce6eb7333e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6492d65eb7a28cb6a6714b0c04b826df" id="r_a6492d65eb7a28cb6a6714b0c04b826df"><td class="memItemLeft" align="right" valign="top">typedef base_class::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6492d65eb7a28cb6a6714b0c04b826df">allocator_type</a></td></tr>
<tr class="memdesc:a6492d65eb7a28cb6a6714b0c04b826df"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options.  <br /></td></tr>
<tr class="separator:a6492d65eb7a28cb6a6714b0c04b826df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c68a4f3ca5a79fcffac0cb2624e0441" id="r_a0c68a4f3ca5a79fcffac0cb2624e0441"><td class="memItemLeft" align="right" valign="top">typedef base_class::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c68a4f3ca5a79fcffac0cb2624e0441">mutex_policy</a></td></tr>
<tr class="memdesc:a0c68a4f3ca5a79fcffac0cb2624e0441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy  <br /></td></tr>
<tr class="separator:a0c68a4f3ca5a79fcffac0cb2624e0441"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a2fb520f4aeda28167438e1f7ccd531df" id="r_a2fb520f4aeda28167438e1f7ccd531df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fb520f4aeda28167438e1f7ccd531df">StripedMap</a> ()</td></tr>
<tr class="memdesc:a2fb520f4aeda28167438e1f7ccd531df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16.  <br /></td></tr>
<tr class="separator:a2fb520f4aeda28167438e1f7ccd531df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892bd935c22aad68b394f3faa67ce8ec" id="r_a892bd935c22aad68b394f3faa67ce8ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a892bd935c22aad68b394f3faa67ce8ec">StripedMap</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a892bd935c22aad68b394f3faa67ce8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified  <br /></td></tr>
<tr class="separator:a892bd935c22aad68b394f3faa67ce8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c828a31c862660ff8b6ae35e89e8d0" id="r_ab1c828a31c862660ff8b6ae35e89e8d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1c828a31c862660ff8b6ae35e89e8d0">StripedMap</a> (size_t nCapacity, <a class="el" href="#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:ab1c828a31c862660ff8b6ae35e89e8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <br /></td></tr>
<tr class="separator:ab1c828a31c862660ff8b6ae35e89e8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad331b6324ae414f56df0324d3435a54f" id="r_ad331b6324ae414f56df0324d3435a54f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad331b6324ae414f56df0324d3435a54f">StripedMap</a> (size_t nCapacity, <a class="el" href="#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:ad331b6324ae414f56df0324d3435a54f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <br /></td></tr>
<tr class="separator:ad331b6324ae414f56df0324d3435a54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d5a55697a29b39d471dd71b580cbc3" id="r_a09d5a55697a29b39d471dd71b580cbc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09d5a55697a29b39d471dd71b580cbc3">~StripedMap</a> ()</td></tr>
<tr class="memdesc:a09d5a55697a29b39d471dd71b580cbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data  <br /></td></tr>
<tr class="separator:a09d5a55697a29b39d471dd71b580cbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8306ce18508455e5a4761f8a051f6c16" id="r_a8306ce18508455e5a4761f8a051f6c16"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; </td></tr>
<tr class="memitem:a8306ce18508455e5a4761f8a051f6c16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8306ce18508455e5a4761f8a051f6c16">insert</a> (K const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>)</td></tr>
<tr class="memdesc:a8306ce18508455e5a4761f8a051f6c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node with key and default value  <br /></td></tr>
<tr class="separator:a8306ce18508455e5a4761f8a051f6c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5543dba6bc798cb924b41de9f98cfedf" id="r_a5543dba6bc798cb924b41de9f98cfedf"><td class="memTemplParams" colspan="2">template&lt;typename K, typename <a class="el" href="_eigen_solver___eigen_solver___matrix_type_8cpp.html#a77c224aa52b434918ce65c33175aa8ad">V</a>&gt; </td></tr>
<tr class="memitem:a5543dba6bc798cb924b41de9f98cfedf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5543dba6bc798cb924b41de9f98cfedf">insert</a> (K const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, <a class="el" href="_eigen_solver___eigen_solver___matrix_type_8cpp.html#a77c224aa52b434918ce65c33175aa8ad">V</a> const &amp;val)</td></tr>
<tr class="memdesc:a5543dba6bc798cb924b41de9f98cfedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node  <br /></td></tr>
<tr class="separator:a5543dba6bc798cb924b41de9f98cfedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd563bbd37f3b08f2763c3cff9abaf49" id="r_abd563bbd37f3b08f2763c3cff9abaf49"><td class="memTemplParams" colspan="2">template&lt;typename K, typename Func&gt; </td></tr>
<tr class="memitem:abd563bbd37f3b08f2763c3cff9abaf49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abd563bbd37f3b08f2763c3cff9abaf49">insert_with</a> (const K &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Func <a class="el" href="structfunc.html">func</a>)</td></tr>
<tr class="memdesc:abd563bbd37f3b08f2763c3cff9abaf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node and initialize it by a functor  <br /></td></tr>
<tr class="separator:abd563bbd37f3b08f2763c3cff9abaf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1377e67bb7bf2b40ace6d8bb9f3f3da" id="r_ab1377e67bb7bf2b40ace6d8bb9f3f3da"><td class="memTemplParams" colspan="2">template&lt;typename K, typename... Args&gt; </td></tr>
<tr class="memitem:ab1377e67bb7bf2b40ace6d8bb9f3f3da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab1377e67bb7bf2b40ace6d8bb9f3f3da">emplace</a> (K &amp;&amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Args &amp;&amp;... <a class="el" href="tbbproxy_8cpp.html#acd08a6295eccfeb30c79985f047e4be5">args</a>)</td></tr>
<tr class="memdesc:ab1377e67bb7bf2b40ace6d8bb9f3f3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">For key <code class="param">key</code> inserts data of type <code class="param"><a class="el" href="#abcd34343ee928de44a8d121cfdbb11b9" title="mapped type">mapped_type</a></code> created in-place from <code class="param">args</code>  <br /></td></tr>
<tr class="separator:ab1377e67bb7bf2b40ace6d8bb9f3f3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61085c91459e53c8a6d817f64b16fb9" id="r_ad61085c91459e53c8a6d817f64b16fb9"><td class="memTemplParams" colspan="2">template&lt;typename K, typename Func&gt; </td></tr>
<tr class="memitem:ad61085c91459e53c8a6d817f64b16fb9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad61085c91459e53c8a6d817f64b16fb9">update</a> (K const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Func <a class="el" href="structfunc.html">func</a>, <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> bAllowInsert=<a class="el" href="yyjson_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="memdesc:ad61085c91459e53c8a6d817f64b16fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node  <br /></td></tr>
<tr class="separator:ad61085c91459e53c8a6d817f64b16fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4f29d2c1f58e1f92759f3fad808bb3" id="r_abf4f29d2c1f58e1f92759f3fad808bb3"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; </td></tr>
<tr class="memitem:abf4f29d2c1f58e1f92759f3fad808bb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abf4f29d2c1f58e1f92759f3fad808bb3">erase</a> (K const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>)</td></tr>
<tr class="memdesc:abf4f29d2c1f58e1f92759f3fad808bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code class="param">key</code> from the map  <br /></td></tr>
<tr class="separator:abf4f29d2c1f58e1f92759f3fad808bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f28cdf88f10e2fcc0910e00c9854f4e" id="r_a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="memTemplParams" colspan="2">template&lt;typename K, typename Less, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </td></tr>
<tr class="memitem:a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f28cdf88f10e2fcc0910e00c9854f4e">erase_with</a> (K const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Less pred)</td></tr>
<tr class="memdesc:a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:a0f28cdf88f10e2fcc0910e00c9854f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213858e29c6865981935d07665804048" id="r_a213858e29c6865981935d07665804048"><td class="memTemplParams" colspan="2">template&lt;typename K, typename Func&gt; </td></tr>
<tr class="memitem:a213858e29c6865981935d07665804048"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a213858e29c6865981935d07665804048">erase</a> (K const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a213858e29c6865981935d07665804048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code class="param">key</code> from the map  <br /></td></tr>
<tr class="separator:a213858e29c6865981935d07665804048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ebc1913a673717786c8f7598b9237b" id="r_af7ebc1913a673717786c8f7598b9237b"><td class="memTemplParams" colspan="2">template&lt;typename K, typename Less, typename Func, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </td></tr>
<tr class="memitem:af7ebc1913a673717786c8f7598b9237b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af7ebc1913a673717786c8f7598b9237b">erase_with</a> (K const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Less pred, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:af7ebc1913a673717786c8f7598b9237b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the map using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:af7ebc1913a673717786c8f7598b9237b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc91ff823125ec02014aab0911083f5" id="r_a7cc91ff823125ec02014aab0911083f5"><td class="memTemplParams" colspan="2">template&lt;typename K, typename Func&gt; </td></tr>
<tr class="memitem:a7cc91ff823125ec02014aab0911083f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7cc91ff823125ec02014aab0911083f5">find</a> (K const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a7cc91ff823125ec02014aab0911083f5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">key</code>  <br /></td></tr>
<tr class="separator:a7cc91ff823125ec02014aab0911083f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1353dfa60543a01fc0092733129a4fd" id="r_aa1353dfa60543a01fc0092733129a4fd"><td class="memTemplParams" colspan="2">template&lt;typename K, typename Less, typename Func, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:aa1353dfa60543a01fc0092733129a4fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa1353dfa60543a01fc0092733129a4fd">find_with</a> (K const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Less pred, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:aa1353dfa60543a01fc0092733129a4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate  <br /></td></tr>
<tr class="separator:aa1353dfa60543a01fc0092733129a4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b5e87952d9a31cb50707f71dfaef61" id="r_a00b5e87952d9a31cb50707f71dfaef61"><td class="memTemplParams" colspan="2">template&lt;typename K&gt; </td></tr>
<tr class="memitem:a00b5e87952d9a31cb50707f71dfaef61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00b5e87952d9a31cb50707f71dfaef61">contains</a> (K const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>)</td></tr>
<tr class="memdesc:a00b5e87952d9a31cb50707f71dfaef61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code class="param">key</code>  <br /></td></tr>
<tr class="separator:a00b5e87952d9a31cb50707f71dfaef61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d217945377cb14045e40c4ea862aafd" id="r_a9d217945377cb14045e40c4ea862aafd"><td class="memTemplParams" colspan="2">template&lt;typename K, typename Less, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:a9d217945377cb14045e40c4ea862aafd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9d217945377cb14045e40c4ea862aafd">contains</a> (K const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Less pred)</td></tr>
<tr class="memdesc:a9d217945377cb14045e40c4ea862aafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code class="param">key</code> using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:a9d217945377cb14045e40c4ea862aafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f13b4556ea60dfa9a77c9e44040812b" id="r_a0f13b4556ea60dfa9a77c9e44040812b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f13b4556ea60dfa9a77c9e44040812b">clear</a> ()</td></tr>
<tr class="memdesc:a0f13b4556ea60dfa9a77c9e44040812b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the map  <br /></td></tr>
<tr class="separator:a0f13b4556ea60dfa9a77c9e44040812b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e02f63d146c37c574d3432f84d1ba9" id="r_ac1e02f63d146c37c574d3432f84d1ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1e02f63d146c37c574d3432f84d1ba9">empty</a> () const</td></tr>
<tr class="memdesc:ac1e02f63d146c37c574d3432f84d1ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the map is empty  <br /></td></tr>
<tr class="separator:ac1e02f63d146c37c574d3432f84d1ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289aecf9771b5c4602375f89871583a3" id="r_a289aecf9771b5c4602375f89871583a3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a289aecf9771b5c4602375f89871583a3">size</a> () const</td></tr>
<tr class="memdesc:a289aecf9771b5c4602375f89871583a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the map  <br /></td></tr>
<tr class="separator:a289aecf9771b5c4602375f89871583a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856f6f7aa7bbeffd0e447c1fee9e3d4a" id="r_a856f6f7aa7bbeffd0e447c1fee9e3d4a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a856f6f7aa7bbeffd0e447c1fee9e3d4a">bucket_count</a> () const</td></tr>
<tr class="memdesc:a856f6f7aa7bbeffd0e447c1fee9e3d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table  <br /></td></tr>
<tr class="separator:a856f6f7aa7bbeffd0e447c1fee9e3d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a5fb6f0e6a0723b22e70520147407c" id="r_a82a5fb6f0e6a0723b22e70520147407c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82a5fb6f0e6a0723b22e70520147407c">lock_count</a> () const</td></tr>
<tr class="memdesc:a82a5fb6f0e6a0723b22e70520147407c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size  <br /></td></tr>
<tr class="separator:a82a5fb6f0e6a0723b22e70520147407c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc70a631a193852a1a03ea83aa9fa91" id="r_a1cc70a631a193852a1a03ea83aa9fa91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cc70a631a193852a1a03ea83aa9fa91">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:a1cc70a631a193852a1a03ea83aa9fa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object  <br /></td></tr>
<tr class="separator:a1cc70a631a193852a1a03ea83aa9fa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cc578587602d60d2fd65e9af0b701d" id="r_a57cc578587602d60d2fd65e9af0b701d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57cc578587602d60d2fd65e9af0b701d">get_resizing_policy</a> () const</td></tr>
<tr class="memdesc:a57cc578587602d60d2fd65e9af0b701d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version)  <br /></td></tr>
<tr class="separator:a57cc578587602d60d2fd65e9af0b701d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Container, typename... Options&gt;<br />
class cds::container::StripedMap&lt; Container, Options &gt;</div><p>Striped hash map </p>
<p>Source</p><ul>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>Lock striping is very simple technique. The map consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When the map is resized, bucket table capacity will be doubled but lock array will not. The lock <code class="param">i</code> protects each bucket <code class="param">j</code>, where <code> j = i mod L </code>, where <code class="param">L</code> - the size of lock array.</p>
<p>Template arguments:</p><ul>
<li><code class="param">Container</code> - the container class that is used as bucket entry. The <code class="param">Container</code> class should support an uniform interface described below.</li>
<li><code class="param">Options</code> - options</li>
</ul>
<p>The <code class="param">StripedMap</code> class does not exactly specify the type of container that should be used as a <code class="param">Container</code> bucket. Instead, the class supports different container type for the bucket, for exampe, <code class="param">std::list</code>, <code class="param">std::map</code> and others.</p>
<p>Remember that <code class="param">StripedMap</code> class algorithm ensures sequential blocking access to its bucket through the mutex type you specify among <code class="param">Options</code> template arguments.</p>
<p>The <code class="param">Options</code> are:</p><ul>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy">cds::opt::mutex_policy</a></code> - concurrent access policy. Available policies: <code class="param"><a class="el" href="namespacecds_1_1container_1_1striped__set.html#aaf61af57cc14c32b696e0a70593a30e4" title="Lock striping concurrent access policy">striped_set::striping</a></code>, <code class="param"><a class="el" href="namespacecds_1_1container_1_1striped__set.html#af1022e641c5c9fa7c8ae0de91c468f77" title="Refinable concurrent access policy">striped_set::refinable</a></code>. Default is <code class="param">striped_set::striping</code>.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function">cds::opt::hash</a></code> - hash functor. Default option value see <code>opt::v::hash_selector&lt;opt::none&gt; </code> which selects default hash functor for your compiler.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">cds::opt::compare</a></code> - key comparison functor. No default functor is provided. If the option is not specified, the <code class="param">opt::less</code> is used.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">cds::opt::less</a></code> - specifies binary predicate used for key comparison. Default is <code class="param">std::less&lt;T&gt;</code>.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">cds::opt::item_counter</a></code> - item counter type. Default is <code class="param"><a class="el" href="classcds_1_1atomicity_1_1item__counter.html" title="Atomic item counter">atomicity::item_counter</a></code> since some operation on the counter is performed without locks. Note that item counting is an essential part of the map algorithm, so dummy counter like as <code class="param"><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter">atomicity::empty_item_counter</a></code> is not suitable.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">cds::opt::allocator</a></code> - the allocator type using for memory allocation of bucket table and lock array. Default is <a class="el" href="external_2libcds_2cds_2user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1resizing__policy.html" title="Resizing policy option">cds::opt::resizing_policy</a></code> - the resizing policy that is a functor that decides when to resize the hash map. Default option value depends on bucket container type: for sequential containers like <code class="param">std::list</code>, <code class="param">std::vector</code> the resizing policy is <code><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a2934a868ebde410fca08353b1da5973e" title="Load factor based resizing policy">striped_set::load_factor_resizing&lt;4&gt;</a> </code>; for other type of containers like <code class="param">std::map</code>, <code class="param">std::unordered_map</code> the resizing policy is <code class="param"><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1a6926eacdbf9fb4fc264d6d85d353c2" title="Dummy resizing policy">striped_set::no_resizing</a></code>. See <a class="el" href="group__cds__striped__resizing__policy.html">available resizing policy</a>. Note that the choose of resizing policy depends of <code class="param">Container</code> type: for sequential containers like <code class="param">std::list</code>, <code class="param">std::vector</code> and so on, right choosing of the policy can significantly improve performance. For other, non-sequential types of <code class="param">Container</code> (like a <code class="param">std::map</code>) the resizing policy is not so important.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1copy__policy.html" title="Copy policy option">cds::opt::copy_policy</a></code> - the copy policy which is used to copy items from the old map to the new one when resizing. The policy can be optionally used in adapted bucket container for performance reasons of resizing. The detail of copy algorithm depends on type of bucket container and explains below.</li>
</ul>
<p><code class="param">opt::compare</code> or <code class="param">opt::less</code> options are used only in some <code class="param">Container</code> class for searching an item. <code class="param">opt::compare</code> option has the highest priority: if <code class="param">opt::compare</code> is specified, <code class="param">opt::less</code> is not used.</p>
<p>You can pass other option that would be passed to <code>adapt</code> metafunction, see below.</p>
<p><b>Internal details</b> </p><pre class="fragment">The \p %StripedMap class cannot utilize the \p Container container specified directly, but only its adapted variant which
supports an unified interface. Internally, the adaptation is made via \p striped_set::adapt metafunction that wraps bucket container
and provides the unified bucket interface suitable for \p %StripedMap. Such adaptation is completely transparent for you -
you don't need to call \p adapt metafunction directly, \p %StripedMap class's internal machinery itself invokes appropriate
\p adapt metafunction to adjust your \p Container container class to \p %StripedMap bucket's internal interface.
All you need is to include a right header before &lt;tt&gt;striped_hash_map.h&lt;/tt&gt;.

By default, &lt;tt&gt;striped_set::adapt&lt;AnyContainer, Options...&gt; &lt;/tt&gt; metafunction does not make any wrapping to \p AnyContainer,
so, the result &lt;tt&gt;striped_set::adapt&lt;AnyContainer, Options...&gt;::type &lt;/tt&gt; is the same as \p AnyContainer.
However, there are a lot of specializations of \p adapt for well-known containers, see table below.
Any of this specialization wraps corresponding container making it suitable for the map's bucket.
Remember, you should include the proper header file for \p adapt &lt;b&gt;before&lt;/b&gt; &lt;tt&gt;striped_map.h&lt;/tt&gt;.
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Container&lt;/th&gt;
        &lt;th&gt;.h-file for \p adapt&lt;/th&gt;
        &lt;th&gt;Example&lt;/th&gt;
        &lt;th&gt;Notes&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p std::list&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_map/std_list.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_map/std_list.h&gt;
            #include &lt;cds/container/striped_hash_map.h&gt;
            typedef cds::container::StripedMap&lt;
                std::list&lt; std::pair&lt; const Key, V &gt; &gt;,
                cds::opt::less&lt; std::less&lt;Key&gt; &gt;
            &gt; striped_map;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            The type of values stored in the \p std::list must be &lt;tt&gt; std::pair&lt; const Key, V &gt; &lt;/tt&gt;, where \p Key - key type,  and \p V - value type
            The list is ordered by key \p Key.
            Template argument pack \p Options &lt;b&gt;must&lt;/b&gt; contain \p cds::opt::less or \p cds::opt::compare for type \p Key stored in the list.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p std::map&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_map/std_map.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_map/std_map.h&gt;
            #include &lt;cds/container/striped_hash_map.h&gt;
            typedef cds::container::StripedMap&lt;
                std::map&lt; Key, T, std::less&lt;Key&gt; &gt;
            &gt; striped_map;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p std::unordered_map&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_map/std_hash_map.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_map/std_hash_map.h&gt;
            #include &lt;cds/container/striped_hash_map.h&gt;
            typedef cds::container::StripedMap&lt;
                std::unordered_map&lt;
                    Key, T,
                    std::hash&lt;Key&gt;,
                    std::equal_to&lt;Key&gt;
                &gt;
            &gt; striped_map;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            You should provide two different hash function \p h1 and \p h2 - one for std::unordered_map and other for \p %StripedMap.
            For the best result, \p h1 and \p h2 must be orthogonal i.e. &lt;tt&gt; h1(X) != h2(X) &lt;/tt&gt; for any value \p X of type \p Key.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::slist&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_map/boost_slist.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/hash_smap/boost_slist.h&gt;
            #include &lt;cds/container/striped_hash_map.h&gt;
            typedef cds::container::StripedMap&lt;
                boost::container::slist&lt; std::pair&lt; const Key, T &gt; &gt;
            &gt; striped_map;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            The type of values stored in the \p boost::container::slist must be &lt;tt&gt; std::pair&lt; const Key, T &gt; &lt;/tt&gt;,
            where \p Key - key type,  and \p T - value type. The list is ordered.
            \p Options &lt;b&gt;must&lt;/b&gt; contain \p cds::opt::less or \p cds::opt::compare.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::list&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_map/boost_list.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_map/boost_list.h&gt;
            #include &lt;cds/container/striped_hash_map.h&gt;
            typedef cds::container::StripedMap&lt;
                boost::container::list&lt; std::pair&lt; const Key, T &gt; &gt;
            &gt; striped_map;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            The type of values stored in the \p boost::container::list must be &lt;tt&gt; std::pair&lt; const Key, T &gt; &lt;/tt&gt;,
            where \p Key - key type,  and \p T - value type. The list is ordered.
            \p Options &lt;b&gt;must&lt;/b&gt; contain \p cds::opt::less or \p cds::opt::compare.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::map&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_map/boost_map.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_map/boost_map.h&gt;
            #include &lt;cds/container/striped_hash_map.h&gt;
            typedef cds::container::StripedMap&lt;
                boost::container::map&lt; Key, T, std::less&lt;Key&gt; &gt;
            &gt; striped_map;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::flat_map&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_map/boost_flat_map.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_map/boost_flat_map.h&gt;
            #include &lt;cds/container/striped_hash_map.h&gt;
            typedef cds::container::StripedMap&lt;
                boost::container::flat_map&lt; Key, T,
                    std::less&lt; std::less&lt;Key&gt; &gt;
                &gt;
            &gt; striped_map;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::unordered_map&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_map/boost_unordered_map.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_map/boost_unordered_map.h&gt;
            #include &lt;cds/container/refinable_hash_map.h&gt;
            typedef cds::container::StripedMap&lt;
                boost::unordered_map&lt; Key, T, boost::hash&lt;Key&gt;, std::equal_to&lt;Key&gt; &gt;
            &gt; refinable_map;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;


You can use another container type as map's bucket.
Suppose, you have a container class \p MyBestContainer and you want to integrate it with \p %StripedMap as bucket type.
There are two possibility:
- either your \p MyBestContainer class has native support of bucket's interface;
    in this case, you can use default &lt;tt&gt;striped_set::adapt&lt;/tt&gt; metafunction;
- or your \p MyBestContainer class does not support bucket's interface; it means you should develop a specialization
    &lt;tt&gt;cds::container::striped_set::adapt&lt;MyBestContainer&gt; &lt;/tt&gt; metafunction providing necessary interface.

The &lt;tt&gt;striped_set::adapt&lt; Container, Options... &gt;&lt;/tt&gt; metafunction has two template argument:
- \p Container is the class that should be used as the bucket, for example, &lt;tt&gt;std::list&lt; std::pair&lt; Key, T &gt; &gt;&lt;/tt&gt;.
- \p Options pack is the options from \p %StripedMap declaration. The \p adapt metafunction can use
    any option from \p Options for its internal use. For example, a \p compare option can be passed to \p adapt
    metafunction via \p Options argument of \p %StripedMap declaration.

See \p striped_set::adapt metafunction for the description of interface that the bucket container must provide
to be \p %StripedMap compatible.
</pre><p><b>Copy policy</b> There are three predefined copy policy:</p><ul>
<li><code class="param">cds::container::striped_set::copy_item</code> - copy item from old bucket to new one when resizing using copy ctor. It is default policy for any compiler that do not support move semantics</li>
<li><code class="param">cds::container::striped_set::move_item</code> - move item from old bucket to new one when resizing using move semantics. It is default policy for any compiler that support move semantics. If compiler does not support move semantics, the move policy is the same as <code class="param">copy_item</code> </li>
<li><code class="param">cds::container::striped_set::swap_item</code> - copy item from old bucket to new one when resizing using <code class="param"><a class="el" href="namespacestd.html#a3acbe51b6415e9284430194bf04944e1">std::swap</a></code>. Not all containers support this copy policy, see details in table below.</li>
</ul>
<p>You can define your own copy policy specifically for your case. Note, right copy policy can significantly improve the performance of resizing.</p>
<table class="doxtable">
<tr>
<th>Container </th><th>Policies  </th></tr>
<tr>
<td><ul>
<li><code class="param">std::list</code> </li>
<li><code class="param">boost::list</code> </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        std::list&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert( itInsert, *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// The type T stored in the list must be swappable</span></div>
<div class="line"><span class="keyword">struct </span>swap_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        std::list&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        std::pair&lt;Key, T&gt; newVal( itWhat-&gt;first, <a class="code hl_define" href="test__overwrite__node_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>());</div>
<div class="line">        <a class="code hl_function" href="namespacestd.html#a3acbe51b6415e9284430194bf04944e1">std::swap</a>( list.insert( itInsert, newVal )-&gt;second, itWhat-&gt;second );</div>
<div class="line">    }</div>
<div class="line">} </div>
<div class="ttc" id="anamespacestd_html_a3acbe51b6415e9284430194bf04944e1"><div class="ttname"><a href="namespacestd.html#a3acbe51b6415e9284430194bf04944e1">std::swap</a></div><div class="ttdeci">void swap(rfl::Box&lt; T &gt; &amp;_b1, rfl::Box&lt; T &gt; &amp;_b2)</div><div class="ttdef"><b>定义</b> Box.hpp:154</div></div>
<div class="ttc" id="atest__overwrite__node_8cpp_html_a0acb682b8260ab1c60b918599864e2e5"><div class="ttname"><a href="test__overwrite__node_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a></div><div class="ttdeci">#define T</div><div class="ttdef"><b>定义</b> test_overwrite_node.cpp:29</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        std::list&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        std::list&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert( itInsert, std::move( *itWhat ));</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->   </td></tr>
<tr>
<td><ul>
<li><code class="param">std::map</code> </li>
<li><code class="param">std::unordered_map</code> </li>
<li><code class="param">boost::container::map</code> </li>
<li><code class="param">boost::container::flat_map</code> </li>
<li><code class="param">boost::unordered_map</code> </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::map&lt; Key, T&gt;&amp; <a class="code hl_namespace" href="namespacemap.html">map</a>, std::map&lt;Key, T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_namespace" href="namespacemap.html">map</a>.insert( *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
<div class="ttc" id="anamespacemap_html"><div class="ttname"><a href="namespacemap.html">map</a></div><div class="ttdef"><b>定义</b> map_del3.cpp:8</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>swap_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::map&lt; Key, T&gt;&amp; <a class="code hl_namespace" href="namespacemap.html">map</a>, std::map&lt;Key, T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_function" href="namespacestd.html#a3acbe51b6415e9284430194bf04944e1">std::swap</a>(</div>
<div class="line">            <a class="code hl_namespace" href="namespacemap.html">map</a>.insert(</div>
<div class="line">                std::map::value_type( itWhat-&gt;first, <a class="code hl_define" href="test__overwrite__node_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>())).first-&gt;second</div>
<div class="line">                , itWhat-&gt;second</div>
<div class="line">        ));</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><p> <code class="param">T</code> type must be swappable.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::map&lt; Key, T&gt;&amp; <a class="code hl_namespace" href="namespacemap.html">map</a>, std::map&lt;Key, T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_namespace" href="namespacemap.html">map</a>.insert( std::move( *itWhat ));</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->  </td></tr>
<tr>
<td><code class="param">boost::container::slist</code>  </td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        bc::slist&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert_after( itInsert, *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// The type T stored in the list must be swappable</span></div>
<div class="line"><span class="keyword">struct </span>swap_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        bc::slist&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        std::pair&lt;Key, T&gt; newVal( itWhat-&gt;first, <a class="code hl_define" href="test__overwrite__node_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>());</div>
<div class="line">        <a class="code hl_function" href="namespacestd.html#a3acbe51b6415e9284430194bf04944e1">std::swap</a>( list.insert( itInsert, newVal )-&gt;second, itWhat-&gt;second );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(</div>
<div class="line">        bc::slist&lt; std::pair&lt;const Key, T&gt; &gt;&amp; list,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itInsert,</div>
<div class="line">        bc::slist&lt;std::pair&lt;const Key, T&gt; &gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert_after( itInsert, std::move( *itWhat ));</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->   </td></tr>
</table>
<p><b>Advanced functions</b></p>
<p>The library provides some advanced functions like <code class="param"><a class="el" href="#a0f28cdf88f10e2fcc0910e00c9854f4e" title="Deletes the item from the map using pred predicate for searching">erase_with()</a></code>, <code class="param"><a class="el" href="#aa1353dfa60543a01fc0092733129a4fd" title="Find the key val using pred predicate">find_with()</a></code>, that cannot be supported by all underlying containers. The table below shows whether underlying container supports those functions (the sign "+" means "container supports the function"):</p>
<table class="doxtable">
<tr>
<th>Container </th><th><code class="param">find_with</code>  </th><th><code class="param">erse_with</code>   </th></tr>
<tr>
<td><code class="param">std::list</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code class="param">std::map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code class="param">std::unordered_map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code class="param">boost::container::slist</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code class="param">boost::container::list</code>  </td><td>+ </td><td>+  </td></tr>
<tr>
<td><code class="param">boost::container::map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code class="param">boost::container::flat_map</code>  </td><td>- </td><td>-  </td></tr>
<tr>
<td><code class="param">boost::unordered_map</code>  </td><td>- </td><td>-  </td></tr>
</table>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a id="a6492d65eb7a28cb6a6714b0c04b826df" name="a6492d65eb7a28cb6a6714b0c04b826df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6492d65eb7a28cb6a6714b0c04b826df">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::allocator_type <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocator type specified in options. </p>

</div>
</div>
<a id="af41155b6b3ff185f4ee4a64bdf256c7d" name="af41155b6b3ff185f4ee4a64bdf256c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41155b6b3ff185f4ee4a64bdf256c7d">&#9670;&#160;</a></span>bucket_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::bucket_type <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::bucket_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>container type adapted for hash set </p>

</div>
</div>
<a id="a6b1b0a9b45e942498737a5652b325e26" name="a6b1b0a9b45e942498737a5652b325e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1b0a9b45e942498737a5652b325e26">&#9670;&#160;</a></span>hash</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::hash <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;<a class="el" href="structhash.html">::hash</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_hash.html">Hash</a> functor </p>

</div>
</div>
<a id="a4097c7d9306f06b3fb0ef3f351387040" name="a4097c7d9306f06b3fb0ef3f351387040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4097c7d9306f06b3fb0ef3f351387040">&#9670;&#160;</a></span>item_counter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::item_counter <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::item_counter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Item counter </p>

</div>
</div>
<a id="a95d2f85653d88cea2e02fc6c39a5d2b3" name="a95d2f85653d88cea2e02fc6c39a5d2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d2f85653d88cea2e02fc6c39a5d2b3">&#9670;&#160;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_type::first_type <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;<a class="el" href="structis__key__matching__join.html">::key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>key type </p>

</div>
</div>
<a id="abcd34343ee928de44a8d121cfdbb11b9" name="abcd34343ee928de44a8d121cfdbb11b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd34343ee928de44a8d121cfdbb11b9">&#9670;&#160;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef value_type::second_type <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::mapped_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mapped type </p>

</div>
</div>
<a id="a0c68a4f3ca5a79fcffac0cb2624e0441" name="a0c68a4f3ca5a79fcffac0cb2624e0441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c68a4f3ca5a79fcffac0cb2624e0441">&#9670;&#160;</a></span>mutex_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::mutex_policy <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::mutex_policy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutex policy </p>

</div>
</div>
<a id="a3155c54ac7cc35f2ab627ce6eb7333e3" name="a3155c54ac7cc35f2ab627ce6eb7333e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3155c54ac7cc35f2ab627ce6eb7333e3">&#9670;&#160;</a></span>resizing_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::resizing_policy <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::resizing_policy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizing policy </p>

</div>
</div>
<a id="a2e8f54fde7d2f4330dbbd32e32da715a" name="a2e8f54fde7d2f4330dbbd32e32da715a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8f54fde7d2f4330dbbd32e32da715a">&#9670;&#160;</a></span>underlying_container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Container <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::underlying_container_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>original intrusive container type for the bucket </p>

</div>
</div>
<a id="abc37b83c74cd041b958aba25ff3ea079" name="abc37b83c74cd041b958aba25ff3ea079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc37b83c74cd041b958aba25ff3ea079">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bucket_type::value_type <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pair type (<code> std::pair&lt;key_type const, mapped_type&gt; </code>) </p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a id="a2fb520f4aeda28167438e1f7ccd531df" name="a2fb520f4aeda28167438e1f7ccd531df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb520f4aeda28167438e1f7ccd531df">&#9670;&#160;</a></span>StripedMap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::StripedMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default ctor. The initial capacity is 16. </p>

</div>
</div>
<a id="a892bd935c22aad68b394f3faa67ce8ec" name="a892bd935c22aad68b394f3faa67ce8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892bd935c22aad68b394f3faa67ce8ec">&#9670;&#160;</a></span>StripedMap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::StripedMap </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nCapacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with initial capacity specified </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c828a31c862660ff8b6ae35e89e8d0" name="ab1c828a31c862660ff8b6ae35e89e8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c828a31c862660ff8b6ae35e89e8d0">&#9670;&#160;</a></span>StripedMap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::StripedMap </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nCapacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>resizingPolicy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (copy semantics) </p>
<p>This constructor initializes m_ResizingPolicy member with copy of <code class="param">resizingPolicy</code> parameter </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16.  </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad331b6324ae414f56df0324d3435a54f" name="ad331b6324ae414f56df0324d3435a54f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad331b6324ae414f56df0324d3435a54f">&#9670;&#160;</a></span>StripedMap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::StripedMap </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nCapacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>resizingPolicy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (move semantics) </p>
<p>This constructor initializes m_ResizingPolicy member moving <code class="param">resizingPolicy</code> parameter Move semantics is used. Available only for the compilers that supports C++11 rvalue reference. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16.  </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09d5a55697a29b39d471dd71b580cbc3" name="a09d5a55697a29b39d471dd71b580cbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d5a55697a29b39d471dd71b580cbc3">&#9670;&#160;</a></span>~StripedMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::~<a class="el" href="classcds_1_1container_1_1_striped_map.html">StripedMap</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor destroys internal data </p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a856f6f7aa7bbeffd0e447c1fee9e3d4a" name="a856f6f7aa7bbeffd0e447c1fee9e3d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856f6f7aa7bbeffd0e447c1fee9e3d4a">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a id="a0f13b4556ea60dfa9a77c9e44040812b" name="a0f13b4556ea60dfa9a77c9e44040812b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f13b4556ea60dfa9a77c9e44040812b">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the map </p>

</div>
</div>
<a id="a00b5e87952d9a31cb50707f71dfaef61" name="a00b5e87952d9a31cb50707f71dfaef61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b5e87952d9a31cb50707f71dfaef61">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code class="param">key</code> </p>
<p>The function searches the item with key equal to <code class="param">key</code> and returns <code class="param">true</code> if it is found, and <code class="param">false</code> otherwise. </p>

</div>
</div>
<a id="a9d217945377cb14045e40c4ea862aafd" name="a9d217945377cb14045e40c4ea862aafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d217945377cb14045e40c4ea862aafd">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename Less, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">K const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code class="param">key</code> using <code class="param">pred</code> predicate for searching </p>
<p>The function is similar to <code>contains( key )</code> but <code class="param">pred</code> is used for key comparing. <code class="param">Less</code> functor has the interface like <code class="param">std::less</code>. <code class="param">Less</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>注解</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code class="param">contains</code>() feature. </dd></dl>

</div>
</div>
<a id="ab1377e67bb7bf2b40ace6d8bb9f3f3da" name="ab1377e67bb7bf2b40ace6d8bb9f3f3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1377e67bb7bf2b40ace6d8bb9f3f3da">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For key <code class="param">key</code> inserts data of type <code class="param"><a class="el" href="#abcd34343ee928de44a8d121cfdbb11b9" title="mapped type">mapped_type</a></code> created in-place from <code class="param">args</code> </p>
<p>Returns <code class="param">true</code> if inserting successful, <code class="param">false</code> otherwise. </p>

</div>
</div>
<a id="ac1e02f63d146c37c574d3432f84d1ba9" name="ac1e02f63d146c37c574d3432f84d1ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e02f63d146c37c574d3432f84d1ba9">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the map is empty </p>
<p>Emptiness is checked by item counting: if item count is zero then the map is empty. </p>

</div>
</div>
<a id="abf4f29d2c1f58e1f92759f3fad808bb3" name="abf4f29d2c1f58e1f92759f3fad808bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4f29d2c1f58e1f92759f3fad808bb3">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code class="param">key</code> from the map </p>
<p><a class="anchor" id="cds_nonintrusive_StripedMap_erase"></a> Return <code class="param">true</code> if <code class="param">key</code> is found and deleted, <code class="param">false</code> otherwise </p>

</div>
</div>
<a id="a213858e29c6865981935d07665804048" name="a213858e29c6865981935d07665804048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213858e29c6865981935d07665804048">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">K const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code class="param">key</code> from the map </p>
<p><a class="anchor" id="cds_nonintrusive_StripedMap_erase_func"></a> The function searches an item with key <code class="param">key</code>, calls <code class="param">f</code> functor and deletes the item. If <code class="param">key</code> is not found, the functor is not called.</p>
<p>The functor <code class="param">Func</code> interface: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>extractor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code hl_typedef" href="#abc37b83c74cd041b958aba25ff3ea079">value_type</a>&amp; item) { ... }</div>
<div class="line">};</div>
<div class="ttc" id="aclasscds_1_1container_1_1_striped_map_html_abc37b83c74cd041b958aba25ff3ea079"><div class="ttname"><a href="#abc37b83c74cd041b958aba25ff3ea079">cds::container::StripedMap::value_type</a></div><div class="ttdeci">bucket_type::value_type value_type</div><div class="ttdoc">pair type ( std::pair&lt;key_type const, mapped_type&gt; )</div><div class="ttdef"><b>定义</b> striped_map.h:487</div></div>
</div><!-- fragment --><p>Return <code class="param">true</code> if key is found and deleted, <code class="param">false</code> otherwise </p>

</div>
</div>
<a id="a0f28cdf88f10e2fcc0910e00c9854f4e" name="a0f28cdf88f10e2fcc0910e00c9854f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f28cdf88f10e2fcc0910e00c9854f4e">&#9670;&#160;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename Less, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code class="param">pred</code> predicate for searching </p>
<p>The function is an analog of <a class="el" href="#cds_nonintrusive_StripedMap_erase">erase(K const&amp;)</a> but <code class="param">pred</code> is used for key comparing. <code class="param">Less</code> functor has the interface like <code class="param">std::less</code>. <code class="param">pred</code> must imply the same element order as the comparator used for building the map.</p>
<dl class="section note"><dt>注解</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code class="param">erase_with</code> feature. </dd></dl>

</div>
</div>
<a id="af7ebc1913a673717786c8f7598b9237b" name="af7ebc1913a673717786c8f7598b9237b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ebc1913a673717786c8f7598b9237b">&#9670;&#160;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename Less, typename Func, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the map using <code class="param">pred</code> predicate for searching </p>
<p>The function is an analog of <a class="el" href="#cds_nonintrusive_StripedMap_erase_func">erase(K const&amp;, Func)</a> but <code class="param">pred</code> is used for key comparing. <code class="param">Less</code> functor has the interface like <code class="param">std::less</code>. <code class="param">pred</code> must imply the same element order as the comparator used for building the map.</p>
<dl class="section note"><dt>注解</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code class="param">erase_with</code> feature. </dd></dl>

</div>
</div>
<a id="a7cc91ff823125ec02014aab0911083f5" name="a7cc91ff823125ec02014aab0911083f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc91ff823125ec02014aab0911083f5">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype">K const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_find.html">Find</a> the key <code class="param">key</code> </p>
<p><a class="anchor" id="cds_nonintrusive_StripedMap_find_func"></a> The function searches the item with key equal to <code class="param">key</code> and calls the functor <code class="param">f</code> for item found. The interface of <code class="param">Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code hl_typedef" href="#abc37b83c74cd041b958aba25ff3ea079">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code class="param">item</code> is the item found.</p>
<p>The functor may change <code class="param">item.second</code>.</p>
<p>The function returns <code class="param">true</code> if <code class="param">key</code> is found, <code class="param">false</code> otherwise. </p>

</div>
</div>
<a id="aa1353dfa60543a01fc0092733129a4fd" name="aa1353dfa60543a01fc0092733129a4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1353dfa60543a01fc0092733129a4fd">&#9670;&#160;</a></span>find_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename Less, typename Func, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype">K const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate </p>
<p>The function is an analog of <a class="el" href="#cds_nonintrusive_StripedMap_find_func">find(K const&amp;, Func)</a> but <code class="param">pred</code> is used for key comparing <code class="param">Less</code> has the interface like <code class="param">std::less</code>. <code class="param">pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>注解</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code class="param">find_with</code> feature. </dd></dl>

</div>
</div>
<a id="a1cc70a631a193852a1a03ea83aa9fa91" name="a1cc70a631a193852a1a03ea83aa9fa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc70a631a193852a1a03ea83aa9fa91">&#9670;&#160;</a></span>get_resizing_policy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> &amp; <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::get_resizing_policy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns resizing policy object </p>

</div>
</div>
<a id="a57cc578587602d60d2fd65e9af0b701d" name="a57cc578587602d60d2fd65e9af0b701d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cc578587602d60d2fd65e9af0b701d">&#9670;&#160;</a></span>get_resizing_policy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3155c54ac7cc35f2ab627ce6eb7333e3">resizing_policy</a> const  &amp; <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::get_resizing_policy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns resizing policy (const version) </p>

</div>
</div>
<a id="a8306ce18508455e5a4761f8a051f6c16" name="a8306ce18508455e5a4761f8a051f6c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8306ce18508455e5a4761f8a051f6c16">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node with key and default value </p>
<p>The function creates a node with <code class="param">key</code> and default value, and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code class="param"><a class="el" href="#a95d2f85653d88cea2e02fc6c39a5d2b3" title="key type">key_type</a></code> should be constructible from a value of type <code class="param">K</code>. In trivial case, <code class="param">K</code> is equal to <code class="param"><a class="el" href="#a95d2f85653d88cea2e02fc6c39a5d2b3" title="key type">key_type</a></code>.</li>
<li>The <code class="param"><a class="el" href="#abcd34343ee928de44a8d121cfdbb11b9" title="mapped type">mapped_type</a></code> should be default-constructible.</li>
</ul>
<p>Returns <code class="param">true</code> if inserting successful, <code class="param">false</code> otherwise. </p>

</div>
</div>
<a id="a5543dba6bc798cb924b41de9f98cfedf" name="a5543dba6bc798cb924b41de9f98cfedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5543dba6bc798cb924b41de9f98cfedf">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename <a class="el" href="_eigen_solver___eigen_solver___matrix_type_8cpp.html#a77c224aa52b434918ce65c33175aa8ad">V</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">K const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_eigen_solver___eigen_solver___matrix_type_8cpp.html#a77c224aa52b434918ce65c33175aa8ad">V</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node </p>
<p>The function creates a node with copy of <code class="param">val</code> value and then inserts the node created into the map.</p>
<p>Preconditions:</p><ul>
<li>The <code class="param"><a class="el" href="#a95d2f85653d88cea2e02fc6c39a5d2b3" title="key type">key_type</a></code> should be constructible from <code class="param">key</code> of type <code class="param">K</code>.</li>
<li>The <code class="param"><a class="el" href="#abcd34343ee928de44a8d121cfdbb11b9" title="mapped type">mapped_type</a></code> should be constructible from <code class="param">val</code> of type <code class="param">V</code>.</li>
</ul>
<p>Returns <code class="param">true</code> if <code class="param">val</code> is inserted into the set, <code class="param">false</code> otherwise. </p>

</div>
</div>
<a id="abd563bbd37f3b08f2763c3cff9abaf49" name="abd563bbd37f3b08f2763c3cff9abaf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd563bbd37f3b08f2763c3cff9abaf49">&#9670;&#160;</a></span>insert_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::insert_with </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node and initialize it by a functor </p>
<p>This function inserts new node with key <code class="param">key</code> and if inserting is successful then it calls <code class="param">func</code> functor with signature </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code hl_typedef" href="#abc37b83c74cd041b958aba25ff3ea079">value_type</a>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p>The argument <code class="param">item</code> of user-defined functor <code class="param">func</code> is the reference to the map's item inserted:</p><ul>
<li><code>item.first</code> is a const reference to item's key that cannot be changed.</li>
<li><code>item.second</code> is a reference to item's value that may be changed.</li>
</ul>
<p>The <a class="el" href="#a95d2f85653d88cea2e02fc6c39a5d2b3" title="key type">key_type</a> should be constructible from value of type <code class="param">K</code>.</p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item from <code class="param">key</code>;</li>
<li>insert new item into the map;</li>
<li>if inserting is successful, initialize the value of item by calling <code class="param">func</code> functor</li>
</ul>
<p>This can be useful if complete initialization of object of <code class="param"><a class="el" href="#abcd34343ee928de44a8d121cfdbb11b9" title="mapped type">mapped_type</a></code> is heavyweight and it is preferable that the initialization should be completed only if inserting is successful. </p>

</div>
</div>
<a id="a82a5fb6f0e6a0723b22e70520147407c" name="a82a5fb6f0e6a0723b22e70520147407c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a5fb6f0e6a0723b22e70520147407c">&#9670;&#160;</a></span>lock_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::lock_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns lock array size </p>
<p>The lock array size is constant. </p>

</div>
</div>
<a id="a289aecf9771b5c4602375f89871583a3" name="a289aecf9771b5c4602375f89871583a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289aecf9771b5c4602375f89871583a3">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;<a class="el" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">::size</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the map </p>

</div>
</div>
<a id="ad61085c91459e53c8a6d817f64b16fb9" name="ad61085c91459e53c8a6d817f64b16fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61085c91459e53c8a6d817f64b16fb9">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename K, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt; <a class="el" href="classcds_1_1container_1_1_striped_map.html">cds::container::StripedMap</a>&lt; Container, Options &gt;::update </td>
          <td>(</td>
          <td class="paramtype">K const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>bAllowInsert</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="yyjson_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the node </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If <code class="param">key</code> is not found in the map, then <code class="param">key</code> is inserted iff <code class="param">bAllowInsert</code> is <code class="param">true</code>. Otherwise, the functor <code class="param">func</code> is called with item found.</p>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structmy__functor.html">my_functor</a> {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code hl_typedef" href="#abc37b83c74cd041b958aba25ff3ea079">value_type</a>&amp; item );</div>
<div class="line">};</div>
<div class="ttc" id="astructmy__functor_html"><div class="ttname"><a href="structmy__functor.html">my_functor</a></div><div class="ttdef"><b>定义</b> NumericalDiff.cpp:35</div></div>
</div><!-- fragment --><p> with arguments:</p><ul>
<li><code class="param">bNew</code> - <code class="param">true</code> if the item has been inserted, <code class="param">false</code> otherwise</li>
<li><code class="param">item</code> - item of the map</li>
</ul>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code class="param">first</code> is true if operation is successful, <code class="param">second</code> is true if new item has been added or <code class="param">false</code> if the item with <code class="param">key</code> already is in the map. </p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>external/libcds/cds/container/<a class="el" href="striped__map_8h_source.html">striped_map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_striped_map.html">StripedMap</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
