<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: Processors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_external_2reflect-cpp_2docs_2concepts_2processors.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Processors</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md537"></a></p>
<p>Processors can be used to apply transformations to struct serialization and deserialization.</p>
<p>For instance, C++ <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rl-camel">usually</a> uses <code>snake_case</code>, but JSON uses <code>camelCase</code>. One way to handle this is <code><a class="el" href="structrfl_1_1_rename.html">rfl::Rename</a></code>, but a more automated way would be to use a <em>processor</em>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::string first_name;</div>
<div class="line">    std::string last_name;</div>
<div class="line">    std::vector&lt;Person&gt; children;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> homer =</div>
<div class="line">    Person{.first_name = <span class="stringliteral">&quot;Homer&quot;</span>,</div>
<div class="line">           .last_name = <span class="stringliteral">&quot;Simpson&quot;</span>,</div>
<div class="line">           .age = 45};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> json_string = </div>
<div class="line">  <a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write&lt;rfl::SnakeCaseToCamelCase&gt;</a>(homer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> homer2 = </div>
<div class="line">  <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read&lt;Person, rfl::SnakeCaseToCamelCase&gt;</a>(json_string).value();</div>
<div class="ttc" id="anamespacerfl_1_1json_html_a905573518eca04a9c269d1bb32de7dd1"><div class="ttname"><a href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read</a></div><div class="ttdeci">auto read(const InputVarType &amp;_obj)</div><div class="ttdoc">Parses an object from a JSON var.</div><div class="ttdef"><b>定义</b> read.hpp:26</div></div>
<div class="ttc" id="anamespacerfl_1_1json_html_af39a23539424555b8c970d12a58e547f"><div class="ttname"><a href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write</a></div><div class="ttdeci">std::string write(const auto &amp;_obj, const yyjson_write_flag _flag=0)</div><div class="ttdoc">Returns a JSON string.</div><div class="ttdef"><b>定义</b> write.hpp:26</div></div>
</div><!-- fragment --><p>The resulting JSON string looks like this:</p>
<div class="fragment"><div class="line">{&quot;firstName&quot;:&quot;Homer&quot;,&quot;lastName&quot;:&quot;Simpson&quot;,&quot;age&quot;:45}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md538"></a>
Supported processors</h1>
<p>reflect-cpp currently supports the following processors:</p>
<ul>
<li><code><a class="el" href="structrfl_1_1_add_struct_name.html">rfl::AddStructName</a></code></li>
<li><code><a class="el" href="structrfl_1_1_add_tags_to_variants.html">rfl::AddTagsToVariants</a></code></li>
<li><code><a class="el" href="structrfl_1_1_allow_raw_ptrs.html">rfl::AllowRawPtrs</a></code></li>
<li><code><a class="el" href="structrfl_1_1_default_if_missing.html">rfl::DefaultIfMissing</a></code></li>
<li><code><a class="el" href="structrfl_1_1_no_extra_fields.html">rfl::NoExtraFields</a></code></li>
<li><code><a class="el" href="structrfl_1_1_no_field_names.html">rfl::NoFieldNames</a></code></li>
<li><code><a class="el" href="structrfl_1_1_no_optionals.html">rfl::NoOptionals</a></code></li>
<li><code><a class="el" href="structrfl_1_1_underlying_enums.html">rfl::UnderlyingEnums</a></code></li>
<li><code><a class="el" href="structrfl_1_1_snake_case_to_camel_case.html">rfl::SnakeCaseToCamelCase</a></code></li>
<li><code><a class="el" href="structrfl_1_1_snake_case_to_pascal_case.html">rfl::SnakeCaseToPascalCase</a></code></li>
</ul>
<h2><a class="anchor" id="autotoc_md539"></a>
<code>rfl::AddStructName</code></h2>
<p>It is also possible to add the struct name as an additional field, like this:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> json_string = </div>
<div class="line">  <a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write</a>&lt;<a class="code hl_struct" href="structrfl_1_1_add_struct_name.html">rfl::AddStructName</a>&lt;<span class="stringliteral">&quot;type&quot;</span>&gt;&gt;(homer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> homer2 = </div>
<div class="line">  <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read</a>&lt;Person, <a class="code hl_struct" href="structrfl_1_1_add_struct_name.html">rfl::AddStructName</a>&lt;<span class="stringliteral">&quot;type&quot;</span>&gt;&gt;(json_string).<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value</a>();</div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_abe8e049f756b5ba547bda825af81b645"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value</a></div><div class="ttdeci">GLsizei GLboolean const GLfloat * value</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:325</div></div>
<div class="ttc" id="astructrfl_1_1_add_struct_name_html"><div class="ttname"><a href="structrfl_1_1_add_struct_name.html">rfl::AddStructName</a></div><div class="ttdef"><b>定义</b> AddStructName.hpp:17</div></div>
</div><!-- fragment --><p>The resulting JSON string looks like this:</p>
<div class="fragment"><div class="line">{&quot;type&quot;:&quot;Person&quot;,&quot;first_name&quot;:&quot;Homer&quot;,&quot;last_name&quot;:&quot;Simpson&quot;,&quot;age&quot;:45}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md540"></a>
<code>rfl::AddTagsToVariants</code></h2>
<p>This processor automatically adds tags to variants. Consider the following example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>button_pressed_t {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>button_released_t {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>key_pressed_t {</div>
<div class="line">  <span class="keywordtype">char</span> <a class="code hl_variable" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="namespacetest__add__tag__to__rfl__variant.html#a77e735c13ac4c14a79da5b14b0cfdb41">my_event_type_t</a> =</div>
<div class="line">    std::variant&lt;button_pressed_t, button_released_t, key_pressed_t, int&gt;;</div>
<div class="ttc" id="aittnotify__static_8h_html_aeeaf6235e69da2907f537f67e598fc9d"><div class="ttname"><a href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a></div><div class="ttdeci">void const char const char int ITT_FORMAT __itt_group_sync x void const char ITT_FORMAT __itt_group_sync s void ITT_FORMAT __itt_group_sync p void ITT_FORMAT p void ITT_FORMAT p no args __itt_suppress_mode_t unsigned int void size_t ITT_FORMAT d void ITT_FORMAT p void ITT_FORMAT p __itt_model_site __itt_model_site_instance ITT_FORMAT p __itt_model_task __itt_model_task_instance ITT_FORMAT p void ITT_FORMAT p void ITT_FORMAT p void size_t ITT_FORMAT d void ITT_FORMAT p const wchar_t ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s const char ITT_FORMAT s no args void ITT_FORMAT p size_t ITT_FORMAT d no args const wchar_t const wchar_t ITT_FORMAT s __itt_heap_function void size_t int ITT_FORMAT d __itt_heap_function void ITT_FORMAT p __itt_heap_function void void size_t int ITT_FORMAT d no args no args unsigned int ITT_FORMAT u const __itt_domain __itt_id ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain __itt_id ITT_FORMAT p const __itt_domain __itt_id __itt_timestamp __itt_timestamp ITT_FORMAT lu const __itt_domain __itt_id __itt_id __itt_string_handle ITT_FORMAT p const __itt_domain ITT_FORMAT p const __itt_domain __itt_string_handle unsigned long long ITT_FORMAT lu const __itt_domain __itt_string_handle unsigned long long ITT_FORMAT lu const __itt_domain __itt_id __itt_string_handle * key</div><div class="ttdef"><b>定义</b> ittnotify_static.h:198</div></div>
<div class="ttc" id="anamespacetest__add__tag__to__rfl__variant_html_a77e735c13ac4c14a79da5b14b0cfdb41"><div class="ttname"><a href="namespacetest__add__tag__to__rfl__variant.html#a77e735c13ac4c14a79da5b14b0cfdb41">test_add_tag_to_rfl_variant::my_event_type_t</a></div><div class="ttdeci">rfl::Variant&lt; button_pressed_t, button_released_t, key_pressed_t, int &gt; my_event_type_t</div><div class="ttdef"><b>定义</b> test_add_tag_to_rfl_variant.cpp:22</div></div>
</div><!-- fragment --><p>The problem here is that <code>button_pressed_t</code> and <code>button_released_t</code> virtually look indistinguishable when they are serialized. The will both be serialized to <code>{}</code>.</p>
<p>But you can add this processor to automatically add tags and avoid the problem:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a> = std::vector&lt;my_event_type_t&gt;(</div>
<div class="line">  {button_pressed_t{}, button_released_t{}, key_pressed_t{<span class="charliteral">&#39;c&#39;</span>}, 3});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> json_string = <a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write&lt;rfl::AddTagsToVariants&gt;</a>(<a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write&lt;std::vector&lt;my_event_type_t&gt;</a>, <a class="code hl_struct" href="structrfl_1_1_add_tags_to_variants.html">rfl::AddTagsToVariants</a>&gt;(json_string);</div>
<div class="ttc" id="abenchmarks_2for__each_2for__each_8hpp_html_ad86cbaae2e3f21959301250e9f7c2701"><div class="ttname"><a href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a></div><div class="ttdeci">std::vector&lt; double &gt; vec</div><div class="ttdef"><b>定义</b> for_each.hpp:14</div></div>
<div class="ttc" id="astructrfl_1_1_add_tags_to_variants_html"><div class="ttname"><a href="structrfl_1_1_add_tags_to_variants.html">rfl::AddTagsToVariants</a></div><div class="ttdef"><b>定义</b> AddTagsToVariants.hpp:9</div></div>
</div><!-- fragment --><p><code>vec</code> will now be serialized as follows:</p>
<div class="fragment"><div class="line">[{&quot;button_pressed_t&quot;:{}},{&quot;button_released_t&quot;:{}},{&quot;key_pressed_t&quot;:{&quot;key&quot;:99}},{&quot;int&quot;:3}]</div>
</div><!-- fragment --><p>You can also set your own custom tags like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>key_pressed_t {</div>
<div class="line">  <span class="keyword">using </span>Tag = <a class="code hl_class" href="classrfl_1_1_literal.html">rfl::Literal</a>&lt;<span class="stringliteral">&quot;your_custom_tag&quot;</span>&gt;;</div>
<div class="line">  <span class="keywordtype">char</span> <a class="code hl_variable" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassrfl_1_1_literal_html"><div class="ttname"><a href="classrfl_1_1_literal.html">rfl::Literal</a></div><div class="ttdef"><b>定义</b> Literal.hpp:26</div></div>
</div><!-- fragment --><p><code>key_pressed_t</code> will now be serialized as follows:</p>
<div class="fragment"><div class="line">{&quot;your_custom_tag&quot;:{&quot;key&quot;:99}}</div>
</div><!-- fragment --><p>Note that there are other ways to address problems like this, for instance <code><a class="el" href="structrfl_1_1_tagged_union.html">rfl::TaggedUnion</a></code>. Please refer to the relevant sections of the documentation.</p>
<h2><a class="anchor" id="autotoc_md541"></a>
<code>rfl::AllowRawPtrs</code></h2>
<p>By default, reflect-cpp does not allow <em>reading into</em> raw pointers. (<em>Writing from</em> raw pointers is never a problem.) This is because reading into raw pointers means that the library will allocate memory that the user then has to manually delete. This can lead to misunderstandings and memory leaks.</p>
<p>You might want to consider using some alternatives, such as <code>std::unique_ptr</code>, <code><a class="el" href="classrfl_1_1_box.html">rfl::Box</a></code>, <code>std::shared_ptr</code>, <code><a class="el" href="classrfl_1_1_ref.html">rfl::Ref</a></code> or <code>std::optional</code>. But if you absolutely have to use raw pointers, you can pass <code><a class="el" href="structrfl_1_1_allow_raw_ptrs.html">rfl::AllowRawPtrs</a></code> to <code>read</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">  <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;firstName&quot;</span>, std::string&gt; first_name;</div>
<div class="line">  <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;lastName&quot;</span>, std::string&gt; last_name = <span class="stringliteral">&quot;Simpson&quot;</span>;</div>
<div class="line">  std::vector&lt;Person&gt;* children;`</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> person =</div>
<div class="line">  <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read&lt;Person, rfl::AllowRawPtrs&gt;</a>(json_str);</div>
<div class="ttc" id="astructrfl_1_1_rename_html"><div class="ttname"><a href="structrfl_1_1_rename.html">rfl::Rename</a></div><div class="ttdef"><b>定义</b> Rename.hpp:19</div></div>
</div><!-- fragment --><p>However, you must keep in mind that it is now <b>YOUR</b> responsibility to clean up. Otherwise, there <b>WILL</b> be a memory leak.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> delete_raw_pointers(<span class="keyword">const</span> Person&amp; _person) {</div>
<div class="line">    <span class="keywordflow">if</span> (!_person.children) {</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; child: _person.children) {</div>
<div class="line">        delete_raw_pointers(child);</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">delete</span> _person.children;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">delete_raw_pointers(person);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md542"></a>
<code>rfl::DefaultIfMissing</code></h2>
<p>The <code><a class="el" href="structrfl_1_1_default_if_missing.html">rfl::DefaultIfMissing</a></code> processor is only relevant for reading data. For writing data, it will make no difference.</p>
<p>Usually, when fields are missing in the input data, this will lead to an error (unless they are optional fields). But if you pass the <code><a class="el" href="structrfl_1_1_default_if_missing.html">rfl::DefaultIfMissing</a></code> processor, then missing fields will be replaced by their default value.</p>
<p>For instance, consider the following struct:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">  std::string first_name;</div>
<div class="line">  std::string last_name = <span class="stringliteral">&quot;Simpson&quot;</span>;</div>
<div class="line">  std::string town;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Suppose you are reading a JSON like this:</p>
<div class="fragment"><div class="line">{&quot;first_name&quot;:&quot;Homer&quot;}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read&lt;Person, rfl::DefaultIfMissing&gt;</a>(json_string);</div>
</div><!-- fragment --><p>Then the resulting struct will be equivalent to what you would have gotten had you read the following JSON string:</p>
<div class="fragment"><div class="line">{&quot;first_name&quot;:&quot;Homer&quot;,&quot;last_name&quot;:&quot;Simpson&quot;,&quot;town&quot;:&quot;&quot;}</div>
</div><!-- fragment --><p><code>last_name</code> and <code>town</code> have been replaced by the default values. Because you have not passed a default value to town, the default value of the type is used instead.</p>
<h2><a class="anchor" id="autotoc_md543"></a>
<code>rfl::NoExtraFields</code></h2>
<p>When reading an object and the object contains a field that cannot be matched to any of the fields in the struct, that field is simply ignored.</p>
<p>However, when <code><a class="el" href="structrfl_1_1_no_extra_fields.html">rfl::NoExtraFields</a></code> is added to <code>read</code>, then such extra fields will lead to an error.</p>
<p>This can be overriden by adding <code><a class="el" href="classrfl_1_1_extra_fields.html">rfl::ExtraFields</a></code> to the struct.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">  std::string first_name;</div>
<div class="line">  std::string last_name = <span class="stringliteral">&quot;Simpson&quot;</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line">{&quot;first_name&quot;:&quot;Homer&quot;,&quot;last_name&quot;:&quot;Simpson&quot;,&quot;extra_field&quot;:0}</div>
</div><!-- fragment --><p>If you call <code><a class="el" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1" title="Parses an object from a JSON var.">rfl::json::read</a>&lt;Person&gt;(json_string)</code>, then <code>extra_field</code> will simply be ignored.</p>
<p>But if you call <code><a class="el" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1" title="Parses an object from a JSON var.">rfl::json::read</a>&lt;Person, <a class="el" href="structrfl_1_1_no_extra_fields.html">rfl::NoExtraFields</a>&gt;(json_string)</code>, you will get an error.</p>
<p>However, suppose the struct looked like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">  std::string first_name;</div>
<div class="line">  std::string last_name = <span class="stringliteral">&quot;Simpson&quot;</span>;</div>
<div class="line">  <a class="code hl_class" href="classrfl_1_1_extra_fields.html">rfl::ExtraFields&lt;int&gt;</a> extras;</div>
<div class="line">};</div>
<div class="ttc" id="aclassrfl_1_1_extra_fields_html"><div class="ttname"><a href="classrfl_1_1_extra_fields.html">rfl::ExtraFields</a></div><div class="ttdef"><b>定义</b> ExtraFields.hpp:11</div></div>
</div><!-- fragment --><p>In this case, <code><a class="el" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1" title="Parses an object from a JSON var.">rfl::json::read</a>&lt;Person, <a class="el" href="structrfl_1_1_no_extra_fields.html">rfl::NoExtraFields</a>&gt;(json_string)</code> will not fail, because <code>extra_field</code> would be included in <code>extras</code>.</p>
<h2><a class="anchor" id="autotoc_md544"></a>
<code>rfl::NoFieldNames</code></h2>
<p>We can also remove the field names altogether:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> json_string = </div>
<div class="line">  <a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write&lt;rfl::NoFieldNames&gt;</a>(homer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> homer2 = </div>
<div class="line">  <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read&lt;Person, rfl::NoFieldNames&gt;</a>(json_string).value();</div>
</div><!-- fragment --><p>The resulting JSON string looks like this:</p>
<div class="fragment"><div class="line">[&quot;Homer&quot;,&quot;Simpson&quot;,45]</div>
</div><!-- fragment --><p>This is particularly relevant for binary formats, which do not emphasize readability, like msgpack or flexbuffers. Removing the field names can reduce the size of the resulting bytestrings and significantly speed up read and write time, depending on the dataset.</p>
<p>However, it makes it more difficult to maintain backwards compatability.</p>
<p>Note that <code><a class="el" href="structrfl_1_1_no_field_names.html">rfl::NoFieldNames</a></code> is not supported for BSON, TOML, XML, or YAML, due to limitations of these formats.</p>
<h2><a class="anchor" id="autotoc_md545"></a>
<code>rfl::NoOptionals</code></h2>
<p>As we have seen in the section on optional fields, when a <code>std::optional</code> is <code>std::nullopt</code>, it is usually not written at all. But if you want them to be explicitly written as <code>null</code>, you can use this processor. The same thing applies to <code>std::shared_ptr</code> and <code>std::unique_ptr</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">  std::string first_name;</div>
<div class="line">  std::string last_name = <span class="stringliteral">&quot;Simpson&quot;</span>;</div>
<div class="line">  std::optional&lt;std::string&gt; town = std::nullopt;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> homer = Person{.first_name = <span class="stringliteral">&quot;Homer&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write&lt;rfl::NoOptionals&gt;</a>(homer);</div>
</div><!-- fragment --><p>The resulting JSON string looks like this:</p>
<div class="fragment"><div class="line">{&quot;first_name&quot;:&quot;Homer&quot;,&quot;last_name&quot;:&quot;Simpson&quot;,&quot;town&quot;:null}</div>
</div><!-- fragment --><p>By default, <code><a class="el" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1" title="Parses an object from a JSON var.">rfl::json::read</a></code> will accept both <code>"town":null</code> and just leaving out the field <code>town</code>. However, if you want to require the field <code>town</code> to be included, you can add <code><a class="el" href="structrfl_1_1_no_optionals.html">rfl::NoOptionals</a></code> to <code>read</code>:</p>
<div class="fragment"><div class="line">rfl::json::read&lt;Person, rfl::NoOptionals&gt;(json_string);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md546"></a>
<code>rfl::UnderlyingEnums</code></h2>
<p>By passing the processor <code><a class="el" href="structrfl_1_1_underlying_enums.html">rfl::UnderlyingEnums</a></code>, fields of the enum type will be written and read as integers</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> <a class="code hl_enumeration" href="external_2magic__enum_2example_2example_8cpp.html#a692f5062ca261bdb3a62a63faddfd27f">Color</a> { <a class="code hl_enumvalue" href="runtime_2spdlog_2include_2spdlog_2fmt_2bundled_2color_8h.html#a80d1dc5f416b97f92939a4166d41203cabda9643ac6601722a28f238714274da4">red</a>, <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#aef30e4e3dccbffce99b7509d5366faef">green</a>, <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab4fcc6ff520ae4d9de259c8468a5cd93">blue</a>, <a class="code hl_enumvalue" href="runtime_2spdlog_2include_2spdlog_2fmt_2bundled_2color_8h.html#a80d1dc5f416b97f92939a4166d41203cad487dd0b55dfcacdd920ccbdaeafa351">yellow</a> };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Circle {</div>
<div class="line">  <span class="keywordtype">float</span> radius;</div>
<div class="line">  <a class="code hl_enumeration" href="external_2magic__enum_2example_2example_8cpp.html#a692f5062ca261bdb3a62a63faddfd27f">Color</a> <a class="code hl_struct" href="structcolor.html">color</a>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> circle = Circle{.radius = 2.0, .color = Color::green};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write&lt;rfl::UnderlyingEnums&gt;</a>(circle);</div>
<div class="ttc" id="aexternal_2magic__enum_2example_2example_8cpp_html_a692f5062ca261bdb3a62a63faddfd27f"><div class="ttname"><a href="external_2magic__enum_2example_2example_8cpp.html#a692f5062ca261bdb3a62a63faddfd27f">Color</a></div><div class="ttdeci">Color</div><div class="ttdef"><b>定义</b> example.cpp:28</div></div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_ab4fcc6ff520ae4d9de259c8468a5cd93"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#ab4fcc6ff520ae4d9de259c8468a5cd93">blue</a></div><div class="ttdeci">GLfloat GLfloat blue</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:192</div></div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_aef30e4e3dccbffce99b7509d5366faef"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#aef30e4e3dccbffce99b7509d5366faef">green</a></div><div class="ttdeci">GLfloat green</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:192</div></div>
<div class="ttc" id="aruntime_2spdlog_2include_2spdlog_2fmt_2bundled_2color_8h_html_a80d1dc5f416b97f92939a4166d41203cabda9643ac6601722a28f238714274da4"><div class="ttname"><a href="runtime_2spdlog_2include_2spdlog_2fmt_2bundled_2color_8h.html#a80d1dc5f416b97f92939a4166d41203cabda9643ac6601722a28f238714274da4">color::red</a></div><div class="ttdeci">@ red</div><div class="ttdef"><b>定义</b> color.h:131</div></div>
<div class="ttc" id="aruntime_2spdlog_2include_2spdlog_2fmt_2bundled_2color_8h_html_a80d1dc5f416b97f92939a4166d41203cad487dd0b55dfcacdd920ccbdaeafa351"><div class="ttname"><a href="runtime_2spdlog_2include_2spdlog_2fmt_2bundled_2color_8h.html#a80d1dc5f416b97f92939a4166d41203cad487dd0b55dfcacdd920ccbdaeafa351">color::yellow</a></div><div class="ttdeci">@ yellow</div><div class="ttdef"><b>定义</b> color.h:156</div></div>
<div class="ttc" id="astructcolor_html"><div class="ttname"><a href="structcolor.html">color</a></div><div class="ttdef"><b>定义</b> types.h:105</div></div>
</div><!-- fragment --><p>The resulting JSON string looks like this:</p>
<div class="fragment"><div class="line">{&quot;radius&quot;:2.0,&quot;color&quot;:1}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md547"></a>
<code>rfl::SnakeCaseToCamelCase</code></h2>
<p>Please refer to the example above.</p>
<h2><a class="anchor" id="autotoc_md548"></a>
<code>rfl::SnakeCaseToPascalCase</code></h2>
<p>If you want <code>PascalCase</code> instead of <code>camelCase</code>, you can use the appropriate processor:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> json_string = </div>
<div class="line">  <a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write&lt;rfl::SnakeCaseToPascalCase&gt;</a>(homer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> homer2 = </div>
<div class="line">  <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read&lt;Person, rfl::SnakeCaseToPascalCase&gt;</a>(json_string).value();</div>
</div><!-- fragment --><p>The resulting JSON string looks like this:</p>
<div class="fragment"><div class="line">{&quot;FirstName&quot;:&quot;Homer&quot;,&quot;LastName&quot;:&quot;Simpson&quot;,&quot;Age&quot;:45}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md549"></a>
Combining several processors</h1>
<p>You can combine several processors:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> json_string = </div>
<div class="line">  <a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write</a>&lt;<a class="code hl_struct" href="structrfl_1_1_snake_case_to_camel_case.html">rfl::SnakeCaseToCamelCase</a>, <a class="code hl_struct" href="structrfl_1_1_add_struct_name.html">rfl::AddStructName</a>&lt;<span class="stringliteral">&quot;type&quot;</span>&gt;&gt;(homer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> homer2 = </div>
<div class="line">  <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read</a>&lt;Person, <a class="code hl_struct" href="structrfl_1_1_snake_case_to_camel_case.html">rfl::SnakeCaseToCamelCase</a>, <a class="code hl_struct" href="structrfl_1_1_add_struct_name.html">rfl::AddStructName</a>&lt;<span class="stringliteral">&quot;type&quot;</span>&gt;&gt;(json_string).<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value</a>();</div>
<div class="ttc" id="astructrfl_1_1_snake_case_to_camel_case_html"><div class="ttname"><a href="structrfl_1_1_snake_case_to_camel_case.html">rfl::SnakeCaseToCamelCase</a></div><div class="ttdef"><b>定义</b> SnakeCaseToCamelCase.hpp:10</div></div>
</div><!-- fragment --><p>The resulting JSON string looks like this:</p>
<div class="fragment"><div class="line">{&quot;type&quot;:&quot;Person&quot;,&quot;firstName&quot;:&quot;Homer&quot;,&quot;lastName&quot;:&quot;Simpson&quot;,&quot;age&quot;:45}</div>
</div><!-- fragment --><p>When you have several processors, it is probably more convenient to combine them like this:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>Processors = <a class="code hl_struct" href="structrfl_1_1_processors.html">rfl::Processors</a>&lt;</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_snake_case_to_camel_case.html">rfl::SnakeCaseToCamelCase</a>, <a class="code hl_struct" href="structrfl_1_1_add_struct_name.html">rfl::AddStructName</a>&lt;<span class="stringliteral">&quot;type&quot;</span>&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> json_string = <a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write&lt;Processors&gt;</a>(homer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> homer2 = <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read&lt;Person, Processors&gt;</a>(json_string).value();</div>
<div class="ttc" id="astructrfl_1_1_processors_html"><div class="ttname"><a href="structrfl_1_1_processors.html">rfl::Processors</a></div><div class="ttdef"><b>定义</b> Processors.hpp:17</div></div>
</div><!-- fragment --><p>The resulting JSON string looks like this:</p>
<div class="fragment"><div class="line">{&quot;type&quot;:&quot;Person&quot;,&quot;firstName&quot;:&quot;Homer&quot;,&quot;lastName&quot;:&quot;Simpson&quot;,&quot;age&quot;:45}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md550"></a>
Writing your own processors</h1>
<p>In principle, writing your own processors is not very difficult. You need to define a struct, which takes has a static method called <code>process</code> taking a named tuple as an input and then returning a modified named tuple. The <code>process</code> method should accept the type of the original struct as a template parameter.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyOwnProcessor {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> StructType&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">auto</span> process(<span class="keyword">auto</span>&amp;&amp; _named_tuple) {...}</div>
<div class="line">};</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
