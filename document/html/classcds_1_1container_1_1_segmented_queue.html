<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: cds::container::SegmentedQueue&lt; GC, T, Traits &gt; 模板类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classcds_1_1container_1_1_segmented_queue.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-attribs">静态 Public 属性</a> &#124;
<a href="classcds_1_1container_1_1_segmented_queue-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">cds::container::SegmentedQueue&lt; GC, T, Traits &gt; 模板类 参考<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__queue.html">Queue</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Segmented queue  
 <a href="#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="container_2segmented__queue_8h_source.html">segmented_queue.h</a>&gt;</code></p>
<div class="dynheader">
类 cds::container::SegmentedQueue&lt; GC, T, Traits &gt; 继承关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1container_1_1_segmented_queue__inherit__graph.png" border="0" usemap="#acds_1_1container_1_1_segmented_queue_3_01_g_c_00_01_t_00_01_traits_01_4_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<div class="dynheader">
cds::container::SegmentedQueue&lt; GC, T, Traits &gt; 的协作图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1container_1_1_segmented_queue__coll__graph.png" border="0" usemap="#acds_1_1container_1_1_segmented_queue_3_01_g_c_00_01_t_00_01_traits_01_4_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:a59826927713723924eff80a9a7f08bfb" id="r_a59826927713723924eff80a9a7f08bfb"><td class="memItemLeft" align="right" valign="top">typedef GC&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59826927713723924eff80a9a7f08bfb">gc</a></td></tr>
<tr class="memdesc:a59826927713723924eff80a9a7f08bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Garbage collector  <br /></td></tr>
<tr class="separator:a59826927713723924eff80a9a7f08bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883d4d55057800bdd4b607602ed76060" id="r_a883d4d55057800bdd4b607602ed76060"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a></td></tr>
<tr class="memdesc:a883d4d55057800bdd4b607602ed76060"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the value stored in the queue  <br /></td></tr>
<tr class="separator:a883d4d55057800bdd4b607602ed76060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd924efe0fd69d05949774ca12877a3b" id="r_afd924efe0fd69d05949774ca12877a3b"><td class="memItemLeft" align="right" valign="top">typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd924efe0fd69d05949774ca12877a3b">traits</a></td></tr>
<tr class="memdesc:afd924efe0fd69d05949774ca12877a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue traits  <br /></td></tr>
<tr class="separator:afd924efe0fd69d05949774ca12877a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471b48a9c3fa634f691f9e7a63eff8d8" id="r_a471b48a9c3fa634f691f9e7a63eff8d8"><td class="memItemLeft" align="right" valign="top">typedef traits::node_allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a471b48a9c3fa634f691f9e7a63eff8d8">node_allocator</a></td></tr>
<tr class="memdesc:a471b48a9c3fa634f691f9e7a63eff8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_node.html">Node</a> allocator  <br /></td></tr>
<tr class="separator:a471b48a9c3fa634f691f9e7a63eff8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12d5bd97d8e04bd37404acd81d78c62" id="r_af12d5bd97d8e04bd37404acd81d78c62"><td class="memItemLeft" align="right" valign="top">typedef base_class::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af12d5bd97d8e04bd37404acd81d78c62">memory_model</a></td></tr>
<tr class="memdesc:af12d5bd97d8e04bd37404acd81d78c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">cds::opt::memory_model</a> option  <br /></td></tr>
<tr class="separator:af12d5bd97d8e04bd37404acd81d78c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf2cf07cf36bafadccc7b510d32c761" id="r_afbf2cf07cf36bafadccc7b510d32c761"><td class="memItemLeft" align="right" valign="top">typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbf2cf07cf36bafadccc7b510d32c761">item_counter</a></td></tr>
<tr class="memdesc:afbf2cf07cf36bafadccc7b510d32c761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counting policy, see <a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">cds::opt::item_counter</a> option setter  <br /></td></tr>
<tr class="separator:afbf2cf07cf36bafadccc7b510d32c761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdb5f79369b42a242228cea23c7e510" id="r_acbdb5f79369b42a242228cea23c7e510"><td class="memItemLeft" align="right" valign="top">typedef base_class::stat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acbdb5f79369b42a242228cea23c7e510">stat</a></td></tr>
<tr class="memdesc:acbdb5f79369b42a242228cea23c7e510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics policy  <br /></td></tr>
<tr class="separator:acbdb5f79369b42a242228cea23c7e510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2d482ad3c5a90ab74e20b00a95a00b" id="r_a8f2d482ad3c5a90ab74e20b00a95a00b"><td class="memItemLeft" align="right" valign="top">typedef base_class::lock_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f2d482ad3c5a90ab74e20b00a95a00b">lock_type</a></td></tr>
<tr class="memdesc:a8f2d482ad3c5a90ab74e20b00a95a00b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="ir__common_8h.html#a1ac75f8fee198af783521627f1fecfbc">Type</a> of mutex for maintaining an internal list of allocated segments.  <br /></td></tr>
<tr class="separator:a8f2d482ad3c5a90ab74e20b00a95a00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8088cbf1759789823b681ad3e07eec27" id="r_a8088cbf1759789823b681ad3e07eec27"><td class="memItemLeft" align="right" valign="top">typedef base_class::permutation_generator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8088cbf1759789823b681ad3e07eec27">permutation_generator</a></td></tr>
<tr class="memdesc:a8088cbf1759789823b681ad3e07eec27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random permutation generator for sequence [0, quasi-factor)  <br /></td></tr>
<tr class="separator:a8088cbf1759789823b681ad3e07eec27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a3f6a0c367d9fa4b92663e5d2d8c4c10a" id="r_a3f6a0c367d9fa4b92663e5d2d8c4c10a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f6a0c367d9fa4b92663e5d2d8c4c10a">SegmentedQueue</a> (size_t nQuasiFactor)</td></tr>
<tr class="memdesc:a3f6a0c367d9fa4b92663e5d2d8c4c10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the empty queue  <br /></td></tr>
<tr class="separator:a3f6a0c367d9fa4b92663e5d2d8c4c10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bbdefa56194fb90c37f66ea160126a" id="r_a98bbdefa56194fb90c37f66ea160126a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98bbdefa56194fb90c37f66ea160126a">~SegmentedQueue</a> ()</td></tr>
<tr class="memdesc:a98bbdefa56194fb90c37f66ea160126a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the queue and deletes all internal data  <br /></td></tr>
<tr class="separator:a98bbdefa56194fb90c37f66ea160126a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada9d85d68dcf1293c9eadf03b2e4ecd" id="r_aada9d85d68dcf1293c9eadf03b2e4ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aada9d85d68dcf1293c9eadf03b2e4ecd">enqueue</a> (<a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> const &amp;val)</td></tr>
<tr class="memdesc:aada9d85d68dcf1293c9eadf03b2e4ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at last segment of the queue  <br /></td></tr>
<tr class="separator:aada9d85d68dcf1293c9eadf03b2e4ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c8cb66a5feebace931adbe80801387" id="r_ae0c8cb66a5feebace931adbe80801387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0c8cb66a5feebace931adbe80801387">enqueue</a> (<a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:ae0c8cb66a5feebace931adbe80801387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at last segment of the queue, move semantics  <br /></td></tr>
<tr class="separator:ae0c8cb66a5feebace931adbe80801387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fd9b1e189ecfefb3fe7dbe8718c529" id="r_a19fd9b1e189ecfefb3fe7dbe8718c529"><td class="memTemplParams" colspan="2">template&lt;typename Func&gt; </td></tr>
<tr class="memitem:a19fd9b1e189ecfefb3fe7dbe8718c529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a19fd9b1e189ecfefb3fe7dbe8718c529">enqueue_with</a> (Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a19fd9b1e189ecfefb3fe7dbe8718c529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues data to the queue using a functor  <br /></td></tr>
<tr class="separator:a19fd9b1e189ecfefb3fe7dbe8718c529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35bcc292299af2a5ae13129e11f62f7" id="r_ac35bcc292299af2a5ae13129e11f62f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac35bcc292299af2a5ae13129e11f62f7">push</a> (<a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> const &amp;val)</td></tr>
<tr class="memdesc:ac35bcc292299af2a5ae13129e11f62f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code class="param"><a class="el" href="#aada9d85d68dcf1293c9eadf03b2e4ecd" title="Inserts a new element at last segment of the queue">enqueue( value_type const&amp; )</a></code> member function  <br /></td></tr>
<tr class="separator:ac35bcc292299af2a5ae13129e11f62f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1f90754c93d18d535ad0ab36866e1b" id="r_a9a1f90754c93d18d535ad0ab36866e1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a1f90754c93d18d535ad0ab36866e1b">push</a> (<a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:a9a1f90754c93d18d535ad0ab36866e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code class="param"><a class="el" href="#ae0c8cb66a5feebace931adbe80801387" title="Inserts a new element at last segment of the queue, move semantics">enqueue( value_type&amp;&amp; )</a></code> member function  <br /></td></tr>
<tr class="separator:a9a1f90754c93d18d535ad0ab36866e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f49fd6f8db730c0b2253767c34724a" id="r_a70f49fd6f8db730c0b2253767c34724a"><td class="memTemplParams" colspan="2">template&lt;typename Func&gt; </td></tr>
<tr class="memitem:a70f49fd6f8db730c0b2253767c34724a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70f49fd6f8db730c0b2253767c34724a">push_with</a> (Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a70f49fd6f8db730c0b2253767c34724a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code class="param"><a class="el" href="#a19fd9b1e189ecfefb3fe7dbe8718c529" title="Enqueues data to the queue using a functor">enqueue_with()</a></code> member function  <br /></td></tr>
<tr class="separator:a70f49fd6f8db730c0b2253767c34724a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfaeac8e454a53b0e1944cd4ba00347f" id="r_abfaeac8e454a53b0e1944cd4ba00347f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abfaeac8e454a53b0e1944cd4ba00347f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abfaeac8e454a53b0e1944cd4ba00347f">emplace</a> (Args &amp;&amp;... <a class="el" href="tbbproxy_8cpp.html#acd08a6295eccfeb30c79985f047e4be5">args</a>)</td></tr>
<tr class="memdesc:abfaeac8e454a53b0e1944cd4ba00347f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues data of type <a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <br /></td></tr>
<tr class="separator:abfaeac8e454a53b0e1944cd4ba00347f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a625c6917029a03b6ba788ce658ceec" id="r_a8a625c6917029a03b6ba788ce658ceec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a625c6917029a03b6ba788ce658ceec">dequeue</a> (<a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> &amp;dest)</td></tr>
<tr class="memdesc:a8a625c6917029a03b6ba788ce658ceec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues a value from the queue  <br /></td></tr>
<tr class="separator:a8a625c6917029a03b6ba788ce658ceec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6492f153a1550d06bad6553ed45e62" id="r_a3d6492f153a1550d06bad6553ed45e62"><td class="memTemplParams" colspan="2">template&lt;typename Func&gt; </td></tr>
<tr class="memitem:a3d6492f153a1550d06bad6553ed45e62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3d6492f153a1550d06bad6553ed45e62">dequeue_with</a> (Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a3d6492f153a1550d06bad6553ed45e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues a value using a functor  <br /></td></tr>
<tr class="separator:a3d6492f153a1550d06bad6553ed45e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e78346d948abde6b8f7f97f0ef08fee" id="r_a6e78346d948abde6b8f7f97f0ef08fee"><td class="memTemplParams" colspan="2">template&lt;typename Func&gt; </td></tr>
<tr class="memitem:a6e78346d948abde6b8f7f97f0ef08fee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e78346d948abde6b8f7f97f0ef08fee">pop_with</a> (Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a6e78346d948abde6b8f7f97f0ef08fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code class="param"><a class="el" href="#a3d6492f153a1550d06bad6553ed45e62" title="Dequeues a value using a functor">dequeue_with()</a></code> function  <br /></td></tr>
<tr class="separator:a6e78346d948abde6b8f7f97f0ef08fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e22d05bef8070c2edeb3fac666607f" id="r_af5e22d05bef8070c2edeb3fac666607f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5e22d05bef8070c2edeb3fac666607f">pop</a> (<a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> &amp;dest)</td></tr>
<tr class="memdesc:af5e22d05bef8070c2edeb3fac666607f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code class="param"><a class="el" href="#a8a625c6917029a03b6ba788ce658ceec" title="Dequeues a value from the queue">dequeue()</a></code> function  <br /></td></tr>
<tr class="separator:af5e22d05bef8070c2edeb3fac666607f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb72c3154c28c375edba95ad4120e4a1" id="r_abb72c3154c28c375edba95ad4120e4a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb72c3154c28c375edba95ad4120e4a1">empty</a> () const</td></tr>
<tr class="memdesc:abb72c3154c28c375edba95ad4120e4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the queue is empty  <br /></td></tr>
<tr class="separator:abb72c3154c28c375edba95ad4120e4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90185a12f72dcb4beb2de01fca1cd54" id="r_ae90185a12f72dcb4beb2de01fca1cd54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae90185a12f72dcb4beb2de01fca1cd54">clear</a> ()</td></tr>
<tr class="memdesc:ae90185a12f72dcb4beb2de01fca1cd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the queue  <br /></td></tr>
<tr class="separator:ae90185a12f72dcb4beb2de01fca1cd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c64e67c14e2eff31b8fd87d2f3d8ea9" id="r_a9c64e67c14e2eff31b8fd87d2f3d8ea9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c64e67c14e2eff31b8fd87d2f3d8ea9">size</a> () const</td></tr>
<tr class="memdesc:a9c64e67c14e2eff31b8fd87d2f3d8ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns queue's item count  <br /></td></tr>
<tr class="separator:a9c64e67c14e2eff31b8fd87d2f3d8ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc781c4f8a47de771862ec9f823263ba" id="r_adc781c4f8a47de771862ec9f823263ba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="#acbdb5f79369b42a242228cea23c7e510">stat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc781c4f8a47de771862ec9f823263ba">statistics</a> () const</td></tr>
<tr class="memdesc:adc781c4f8a47de771862ec9f823263ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to internal statistics  <br /></td></tr>
<tr class="separator:adc781c4f8a47de771862ec9f823263ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade149d9d1677a24de1c3b51c0d5ad02d" id="r_ade149d9d1677a24de1c3b51c0d5ad02d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade149d9d1677a24de1c3b51c0d5ad02d">quasi_factor</a> () const</td></tr>
<tr class="memdesc:ade149d9d1677a24de1c3b51c0d5ad02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns quasi factor, a power-of-two number  <br /></td></tr>
<tr class="separator:ade149d9d1677a24de1c3b51c0d5ad02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
静态 Public 属性</h2></td></tr>
<tr class="memitem:a025e4461b9a74c04010e16c98a7bf440" id="r_a025e4461b9a74c04010e16c98a7bf440"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a025e4461b9a74c04010e16c98a7bf440">c_nHazardPtrCount</a> = base_class::c_nHazardPtrCount</td></tr>
<tr class="memdesc:a025e4461b9a74c04010e16c98a7bf440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count of hazard pointer required for the algorithm  <br /></td></tr>
<tr class="separator:a025e4461b9a74c04010e16c98a7bf440"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt;<br />
class cds::container::SegmentedQueue&lt; GC, T, Traits &gt;</div><p>Segmented queue </p>
<p>The queue is based on work</p><ul>
<li>[2010] Afek, Korland, Yanovsky "Quasi-Linearizability: relaxed consistency for improved concurrency"</li>
</ul>
<p>In this paper the authors offer a relaxed version of linearizability, so-called quasi-linearizability, that preserves some of the intuition, provides a flexible way to control the level of relaxation and supports th implementation of more concurrent and scalable data structure. Intuitively, the linearizability requires each run to be equivalent in some sense to a serial run of the algorithm. This equivalence to some serial run imposes strong synchronization requirements that in many cases results in limited scalability and synchronization bottleneck.</p>
<p>The general idea is that the queue maintains a linked list of segments, each segment is an array of nodes in the size of the quasi factor, and each node has a deleted boolean marker, which states if it has been dequeued. Each producer iterates over last segment in the linked list in some random permutation order. Whet it finds an empty cell it performs a CAS operation attempting to enqueue its new element. In case the entire segment has been scanned and no available cell is found (implying that the segment is full), then it attempts to add a new segment to the list.</p>
<p>The dequeue operation is similar: the consumer iterates over the first segment in the linked list in some random permutation order. When it finds an item which has not yet been dequeued, it performs CAS on its deleted marker in order to "delete" it, if succeeded this item is considered dequeued. In case the entire segment was scanned and all the nodes have already been dequeued (implying that the segment is empty), then it attempts to remove this segment from the linked list and starts the same process on the next segment. If there is no next segment, the queue is considered empty.</p>
<p>Based on the fact that most of the time threads do not add or remove segments, most of the work is done in parallel on different cells in the segments. This ensures a controlled contention depending on the segment size, which is quasi factor.</p>
<p>The segmented queue is an <em>unfair</em> queue since it violates the strong FIFO order but no more than quasi factor. It means that the consumer dequeues any item from the current first segment.</p>
<p>Template parameters:</p><ul>
<li><code class="param">GC</code> - a garbage collector, possible types are <a class="el" href="namespacecds_1_1gc.html#af0523881f089593a7559d194ee2b5dd9" title="Default Hazard Pointer schema with hp::details::DefaultTLSManager">cds::gc::HP</a>, <a class="el" href="classcds_1_1gc_1_1_d_h_p.html" title="Dynamic (adaptie) Hazard Pointer SMR">cds::gc::DHP</a></li>
<li><code class="param">T</code> - the type of values stored in the queue</li>
<li><code class="param">Traits</code> - queue type traits, default is <code class="param"><a class="el" href="structcds_1_1container_1_1segmented__queue_1_1traits.html" title="SegmentedQueue default type traits">segmented_queue::traits</a></code>. <code class="param"><a class="el" href="structcds_1_1container_1_1segmented__queue_1_1make__traits.html" title="Metafunction converting option list to traits for SegmentedQueue">segmented_queue::make_traits</a></code> metafunction can be used to construct your type traits. </li>
</ul>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a id="a59826927713723924eff80a9a7f08bfb" name="a59826927713723924eff80a9a7f08bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59826927713723924eff80a9a7f08bfb">&#9670;&#160;</a></span>gc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef GC <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::gc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Garbage collector </p>

</div>
</div>
<a id="afbf2cf07cf36bafadccc7b510d32c761" name="afbf2cf07cf36bafadccc7b510d32c761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf2cf07cf36bafadccc7b510d32c761">&#9670;&#160;</a></span>item_counter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::item_counter <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::item_counter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Item counting policy, see <a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">cds::opt::item_counter</a> option setter </p>

</div>
</div>
<a id="a8f2d482ad3c5a90ab74e20b00a95a00b" name="a8f2d482ad3c5a90ab74e20b00a95a00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2d482ad3c5a90ab74e20b00a95a00b">&#9670;&#160;</a></span>lock_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::lock_type <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::lock_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="ir__common_8h.html#a1ac75f8fee198af783521627f1fecfbc">Type</a> of mutex for maintaining an internal list of allocated segments. </p>

</div>
</div>
<a id="af12d5bd97d8e04bd37404acd81d78c62" name="af12d5bd97d8e04bd37404acd81d78c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12d5bd97d8e04bd37404acd81d78c62">&#9670;&#160;</a></span>memory_model</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::memory_model <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::memory_model</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory ordering. See <a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model">cds::opt::memory_model</a> option </p>

</div>
</div>
<a id="a471b48a9c3fa634f691f9e7a63eff8d8" name="a471b48a9c3fa634f691f9e7a63eff8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471b48a9c3fa634f691f9e7a63eff8d8">&#9670;&#160;</a></span>node_allocator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef traits::node_allocator <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::node_allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_node.html">Node</a> allocator </p>

</div>
</div>
<a id="a8088cbf1759789823b681ad3e07eec27" name="a8088cbf1759789823b681ad3e07eec27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8088cbf1759789823b681ad3e07eec27">&#9670;&#160;</a></span>permutation_generator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::permutation_generator <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::permutation_generator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Random permutation generator for sequence [0, quasi-factor) </p>

</div>
</div>
<a id="acbdb5f79369b42a242228cea23c7e510" name="acbdb5f79369b42a242228cea23c7e510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbdb5f79369b42a242228cea23c7e510">&#9670;&#160;</a></span>stat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::stat <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;<a class="el" href="structcds_1_1container_1_1segmented__queue_1_1stat.html">::stat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal statistics policy </p>

</div>
</div>
<a id="afd924efe0fd69d05949774ca12877a3b" name="afd924efe0fd69d05949774ca12877a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd924efe0fd69d05949774ca12877a3b">&#9670;&#160;</a></span>traits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Traits <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::traits</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue traits </p>

</div>
</div>
<a id="a883d4d55057800bdd4b607602ed76060" name="a883d4d55057800bdd4b607602ed76060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883d4d55057800bdd4b607602ed76060">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type of the value stored in the queue </p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a id="a3f6a0c367d9fa4b92663e5d2d8c4c10a" name="a3f6a0c367d9fa4b92663e5d2d8c4c10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6a0c367d9fa4b92663e5d2d8c4c10a">&#9670;&#160;</a></span>SegmentedQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::SegmentedQueue </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nQuasiFactor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the empty queue </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">nQuasiFactor</td><td>Quasi factor. If it is not a power of 2 it is rounded up to nearest power of 2. Minimum is 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98bbdefa56194fb90c37f66ea160126a" name="a98bbdefa56194fb90c37f66ea160126a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98bbdefa56194fb90c37f66ea160126a">&#9670;&#160;</a></span>~SegmentedQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::~<a class="el" href="classcds_1_1container_1_1_segmented_queue.html">SegmentedQueue</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the queue and deletes all internal data </p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="ae90185a12f72dcb4beb2de01fca1cd54" name="ae90185a12f72dcb4beb2de01fca1cd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90185a12f72dcb4beb2de01fca1cd54">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the queue </p>
<p>The function repeatedly calls <code class="param"><a class="el" href="#a8a625c6917029a03b6ba788ce658ceec" title="Dequeues a value from the queue">dequeue()</a></code> until it returns <code class="param">nullptr</code>. The disposer specified in <code class="param">Traits</code> template argument is called for each removed item. </p>

</div>
</div>
<a id="a8a625c6917029a03b6ba788ce658ceec" name="a8a625c6917029a03b6ba788ce658ceec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a625c6917029a03b6ba788ce658ceec">&#9670;&#160;</a></span>dequeue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeues a value from the queue </p>
<p>If queue is not empty, the function returns <code class="param">true</code>, <code class="param">dest</code> contains copy of dequeued value. The assignment operator for type <a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> is invoked. If queue is empty, the function returns <code class="param">false</code>, <code class="param">dest</code> is unchanged. </p>

</div>
</div>
<a id="a3d6492f153a1550d06bad6553ed45e62" name="a3d6492f153a1550d06bad6553ed45e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6492f153a1550d06bad6553ed45e62">&#9670;&#160;</a></span>dequeue_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::dequeue_with </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeues a value using a functor </p>
<p><code class="param">Func</code> is a functor called to copy dequeued value. The functor takes one argument - a reference to removed node: </p><div class="fragment"><div class="line"><a class="code hl_namespace" href="namespacecds.html">cds</a>:<a class="code hl_class" href="classcds_1_1container_1_1_m_s_queue.html">container::MSQueue&lt; cds::gc::HP, Foo &gt;</a> myQueue;</div>
<div class="line"><a class="code hl_class" href="class_bar.html">Bar</a> bar;</div>
<div class="line">myQueue.<a class="code hl_function" href="classcds_1_1container_1_1_m_s_queue.html#a54e89eb82856814ffc12a99af1fefb60">dequeue_with</a>( [&amp;bar]( <a class="code hl_namespace" href="namespace_foo.html">Foo</a>&amp; <a class="code hl_variable" href="shortpath_8cpp.html#a8648ffe7342bea77e2698690589da3c1">src</a> ) { bar = std::move( <a class="code hl_variable" href="shortpath_8cpp.html#a8648ffe7342bea77e2698690589da3c1">src</a> );});</div>
<div class="ttc" id="aclass_bar_html"><div class="ttname"><a href="class_bar.html">Bar</a></div><div class="ttdef"><b>定义</b> test_concurrent_queue.cpp:447</div></div>
<div class="ttc" id="aclasscds_1_1container_1_1_m_s_queue_html"><div class="ttname"><a href="classcds_1_1container_1_1_m_s_queue.html">cds::container::MSQueue</a></div><div class="ttdoc">Michael &amp; Scott lock-free queue</div><div class="ttdef"><b>定义</b> msqueue.h:174</div></div>
<div class="ttc" id="aclasscds_1_1container_1_1_m_s_queue_html_a54e89eb82856814ffc12a99af1fefb60"><div class="ttname"><a href="classcds_1_1container_1_1_m_s_queue.html#a54e89eb82856814ffc12a99af1fefb60">cds::container::MSQueue::dequeue_with</a></div><div class="ttdeci">bool dequeue_with(Func f)</div><div class="ttdoc">Dequeues a value using a functor</div><div class="ttdef"><b>定义</b> msqueue.h:356</div></div>
<div class="ttc" id="anamespace_foo_html"><div class="ttname"><a href="namespace_foo.html">Foo</a></div><div class="ttdef"><b>定义</b> jacobisvd.cpp:72</div></div>
<div class="ttc" id="anamespacecds_html"><div class="ttname"><a href="namespacecds.html">cds</a></div><div class="ttdoc">The main library namespace</div><div class="ttdef"><b>定义</b> atomic.h:12</div></div>
<div class="ttc" id="ashortpath_8cpp_html_a8648ffe7342bea77e2698690589da3c1"><div class="ttname"><a href="shortpath_8cpp.html#a8648ffe7342bea77e2698690589da3c1">src</a></div><div class="ttdeci">size_t src</div><div class="ttdef"><b>定义</b> shortpath.cpp:81</div></div>
</div><!-- fragment --><p> The functor is called only if the queue is not empty. </p>

</div>
</div>
<a id="abfaeac8e454a53b0e1944cd4ba00347f" name="abfaeac8e454a53b0e1944cd4ba00347f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfaeac8e454a53b0e1944cd4ba00347f">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues data of type <a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>

</div>
</div>
<a id="abb72c3154c28c375edba95ad4120e4a1" name="abb72c3154c28c375edba95ad4120e4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb72c3154c28c375edba95ad4120e4a1">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the queue is empty </p>
<p>The original segmented queue algorithm does not allow to check emptiness accurately because <code class="param"><a class="el" href="#abb72c3154c28c375edba95ad4120e4a1" title="Checks if the queue is empty">empty()</a></code> is unlinearizable. This function tests queue's emptiness checking <code><a class="el" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size()</a> == 0</code>, so, the item counting feature is an essential part of queue's algorithm. </p>

</div>
</div>
<a id="ae0c8cb66a5feebace931adbe80801387" name="ae0c8cb66a5feebace931adbe80801387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c8cb66a5feebace931adbe80801387">&#9670;&#160;</a></span>enqueue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element at last segment of the queue, move semantics </p>

</div>
</div>
<a id="aada9d85d68dcf1293c9eadf03b2e4ecd" name="aada9d85d68dcf1293c9eadf03b2e4ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada9d85d68dcf1293c9eadf03b2e4ecd">&#9670;&#160;</a></span>enqueue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new element at last segment of the queue </p>
<p>The function makes queue node in dynamic memory calling copy constructor for <code class="param">val</code> and then it calls intrusive::SEgmentedQueue::enqueue. Returns <code class="param">true</code> if success, <code class="param">false</code> otherwise. </p>

</div>
</div>
<a id="a19fd9b1e189ecfefb3fe7dbe8718c529" name="a19fd9b1e189ecfefb3fe7dbe8718c529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fd9b1e189ecfefb3fe7dbe8718c529">&#9670;&#160;</a></span>enqueue_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::enqueue_with </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues data to the queue using a functor </p>
<p><code class="param">Func</code> is a functor called to create node. The functor <code class="param">f</code> takes one argument - a reference to a new node of type <a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> : </p><div class="fragment"><div class="line"><a class="code hl_class" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue&lt; cds::gc::HP, Foo &gt;</a> myQueue;</div>
<div class="line"><a class="code hl_class" href="class_bar.html">Bar</a> bar;</div>
<div class="line">myQueue.<a class="code hl_function" href="#a19fd9b1e189ecfefb3fe7dbe8718c529">enqueue_with</a>( [&amp;bar]( <a class="code hl_namespace" href="namespace_foo.html">Foo</a>&amp; dest ) { dest = bar; } );</div>
<div class="ttc" id="aclasscds_1_1container_1_1_segmented_queue_html"><div class="ttname"><a href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a></div><div class="ttdoc">Segmented queue</div><div class="ttdef"><b>定义</b> segmented_queue.h:189</div></div>
<div class="ttc" id="aclasscds_1_1container_1_1_segmented_queue_html_a19fd9b1e189ecfefb3fe7dbe8718c529"><div class="ttname"><a href="#a19fd9b1e189ecfefb3fe7dbe8718c529">cds::container::SegmentedQueue::enqueue_with</a></div><div class="ttdeci">bool enqueue_with(Func f)</div><div class="ttdoc">Enqueues data to the queue using a functor</div><div class="ttdef"><b>定义</b> segmented_queue.h:280</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af5e22d05bef8070c2edeb3fac666607f" name="af5e22d05bef8070c2edeb3fac666607f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e22d05bef8070c2edeb3fac666607f">&#9670;&#160;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonym for <code class="param"><a class="el" href="#a8a625c6917029a03b6ba788ce658ceec" title="Dequeues a value from the queue">dequeue()</a></code> function </p>

</div>
</div>
<a id="a6e78346d948abde6b8f7f97f0ef08fee" name="a6e78346d948abde6b8f7f97f0ef08fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e78346d948abde6b8f7f97f0ef08fee">&#9670;&#160;</a></span>pop_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::pop_with </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonym for <code class="param"><a class="el" href="#a3d6492f153a1550d06bad6553ed45e62" title="Dequeues a value using a functor">dequeue_with()</a></code> function </p>

</div>
</div>
<a id="a9a1f90754c93d18d535ad0ab36866e1b" name="a9a1f90754c93d18d535ad0ab36866e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1f90754c93d18d535ad0ab36866e1b">&#9670;&#160;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonym for <code class="param"><a class="el" href="#ae0c8cb66a5feebace931adbe80801387" title="Inserts a new element at last segment of the queue, move semantics">enqueue( value_type&amp;&amp; )</a></code> member function </p>

</div>
</div>
<a id="ac35bcc292299af2a5ae13129e11f62f7" name="ac35bcc292299af2a5ae13129e11f62f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35bcc292299af2a5ae13129e11f62f7">&#9670;&#160;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a883d4d55057800bdd4b607602ed76060">value_type</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonym for <code class="param"><a class="el" href="#aada9d85d68dcf1293c9eadf03b2e4ecd" title="Inserts a new element at last segment of the queue">enqueue( value_type const&amp; )</a></code> member function </p>

</div>
</div>
<a id="a70f49fd6f8db730c0b2253767c34724a" name="a70f49fd6f8db730c0b2253767c34724a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f49fd6f8db730c0b2253767c34724a">&#9670;&#160;</a></span>push_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::push_with </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonym for <code class="param"><a class="el" href="#a19fd9b1e189ecfefb3fe7dbe8718c529" title="Enqueues data to the queue using a functor">enqueue_with()</a></code> member function </p>

</div>
</div>
<a id="ade149d9d1677a24de1c3b51c0d5ad02d" name="ade149d9d1677a24de1c3b51c0d5ad02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade149d9d1677a24de1c3b51c0d5ad02d">&#9670;&#160;</a></span>quasi_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::quasi_factor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns quasi factor, a power-of-two number </p>

</div>
</div>
<a id="a9c64e67c14e2eff31b8fd87d2f3d8ea9" name="a9c64e67c14e2eff31b8fd87d2f3d8ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c64e67c14e2eff31b8fd87d2f3d8ea9">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;<a class="el" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">::size</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns queue's item count </p>

</div>
</div>
<a id="adc781c4f8a47de771862ec9f823263ba" name="adc781c4f8a47de771862ec9f823263ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc781c4f8a47de771862ec9f823263ba">&#9670;&#160;</a></span>statistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="#acbdb5f79369b42a242228cea23c7e510">stat</a> &amp; <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::statistics </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns reference to internal statistics </p>
<p>The type of internal statistics is specified by <code class="param">Traits</code> template argument. </p>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="a025e4461b9a74c04010e16c98a7bf440" name="a025e4461b9a74c04010e16c98a7bf440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025e4461b9a74c04010e16c98a7bf440">&#9670;&#160;</a></span>c_nHazardPtrCount</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class GC, typename <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, typename Traits = segmented_queue::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classcds_1_1container_1_1_segmented_queue.html">cds::container::SegmentedQueue</a>&lt; GC, <a class="el" href="_tutorial__sparse__example_8cpp.html#af639fb96631ba0018f0b2259fc95edfb">T</a>, Traits &gt;::c_nHazardPtrCount = base_class::c_nHazardPtrCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count of hazard pointer required for the algorithm </p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>external/libcds/cds/container/<a class="el" href="container_2segmented__queue_8h_source.html">segmented_queue.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_segmented_queue.html">SegmentedQueue</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
