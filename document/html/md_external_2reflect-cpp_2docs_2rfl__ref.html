<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: &lt;tt&gt;rfl::Box&lt;/tt&gt; and &lt;tt&gt;rfl::Ref&lt;/tt&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_external_2reflect-cpp_2docs_2rfl__ref.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">&lt;tt&gt;rfl::Box&lt;/tt&gt; and &lt;tt&gt;rfl::Ref&lt;/tt&gt;</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md626"></a></p>
<p>In previous sections, we have defined the <code>Person</code> class recursively:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;firstName&quot;</span>, std::string&gt; first_name;</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;lastName&quot;</span>, std::string&gt; last_name;</div>
<div class="line">    std::vector&lt;Person&gt; children;</div>
<div class="line">};</div>
<div class="ttc" id="astructrfl_1_1_rename_html"><div class="ttname"><a href="structrfl_1_1_rename.html">rfl::Rename</a></div><div class="ttdef"><b>定义</b> Rename.hpp:19</div></div>
</div><!-- fragment --><p>This works, because <code>std::vector</code> contains a pointer under-the-hood. But what wouldn't work is something like this:</p>
<div class="fragment"><div class="line"><span class="comment">// WILL NOT COMPILE</span></div>
<div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;firstName&quot;</span>, std::string&gt; first_name;</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;lastName&quot;</span>, std::string&gt; last_name;</div>
<div class="line">    Person child;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This is because the compiler cannot figure out the intended size of the struct. But recursively defined structures are important. For instance, if you deal with machine learning, you might be familiar with a decision tree.</p>
<p><a class="el" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a> decision tree consists of a <code>Leaf</code> containing the prediction and a <code><a class="el" href="class_node.html">Node</a></code> which splits the decision tree into two subtrees.</p>
<p><a class="el" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a> naive implementation might look like this:</p>
<div class="fragment"><div class="line"><span class="comment">// WILL NOT COMPILE</span></div>
<div class="line"><span class="keyword">struct </span>DecisionTree {</div>
<div class="line">    <span class="keyword">struct </span>Leaf {</div>
<div class="line">        <span class="keyword">using </span>Tag = <a class="code hl_class" href="classrfl_1_1_literal.html">rfl::Literal</a>&lt;<span class="stringliteral">&quot;Leaf&quot;</span>&gt;;</div>
<div class="line">        <span class="keywordtype">double</span> prediction;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span><a class="code hl_struct" href="class_node.html">Node</a> {</div>
<div class="line">        <span class="keyword">using </span>Tag = <a class="code hl_class" href="classrfl_1_1_literal.html">rfl::Literal</a>&lt;<span class="stringliteral">&quot;Node&quot;</span>&gt;;</div>
<div class="line">        <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;criticalValue&quot;</span>, <span class="keywordtype">double</span>&gt; critical_value;</div>
<div class="line">        DecisionTree lesser;</div>
<div class="line">        DecisionTree greater;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>LeafOrNode = rfl::TaggedUnion&lt;<span class="stringliteral">&quot;type&quot;</span>, Leaf, Node&gt;;</div>
<div class="line"> </div>
<div class="line">    rfl::Field&lt;<span class="stringliteral">&quot;leafOrNode&quot;</span>, LeafOrNode&gt; leaf_or_node;</div>
<div class="line">};</div>
<div class="ttc" id="aclass_node_html"><div class="ttname"><a href="class_node.html">Node</a></div><div class="ttdef"><b>定义</b> levelgraph.hpp:22</div></div>
<div class="ttc" id="aclassrfl_1_1_literal_html"><div class="ttname"><a href="classrfl_1_1_literal.html">rfl::Literal</a></div><div class="ttdef"><b>定义</b> Literal.hpp:26</div></div>
</div><!-- fragment --><p>Again, this will not compile, because the compiler cannot figure out the intended size of the struct.</p>
<p><a class="el" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a> possible solution might be to use <code>std::unique_ptr</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Will compile, but not an ideal design.</span></div>
<div class="line"><span class="keyword">struct </span>DecisionTree {</div>
<div class="line">    <span class="keyword">struct </span>Leaf {</div>
<div class="line">        <span class="keyword">using </span>Tag = <a class="code hl_class" href="classrfl_1_1_literal.html">rfl::Literal</a>&lt;<span class="stringliteral">&quot;Leaf&quot;</span>&gt;;</div>
<div class="line">        <span class="keywordtype">double</span> prediction;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span><a class="code hl_struct" href="class_node.html">Node</a> {</div>
<div class="line">        <span class="keyword">using </span>Tag = <a class="code hl_class" href="classrfl_1_1_literal.html">rfl::Literal</a>&lt;<span class="stringliteral">&quot;Node&quot;</span>&gt;;</div>
<div class="line">        <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;criticalValue&quot;</span>, <span class="keywordtype">double</span>&gt; critical_value;</div>
<div class="line">        std::unique_ptr&lt;DecisionTree&gt; lesser;</div>
<div class="line">        std::unique_ptr&lt;DecisionTree&gt; greater;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>LeafOrNode = rfl::TaggedUnion&lt;<span class="stringliteral">&quot;type&quot;</span>, Leaf, Node&gt;;</div>
<div class="line"> </div>
<div class="line">    rfl::Field&lt;<span class="stringliteral">&quot;leafOrNode&quot;</span>, LeafOrNode&gt; leaf_or_node;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This will compile, but the design is less than ideal. We know for a fact that a <code><a class="el" href="class_node.html">Node</a></code> must have exactly two subtrees. But this is not reflected in the type system. In this encoding, the fields "lesser" and "greater" are marked optional and you will have to check at runtime that they are indeed set.</p>
<p>But this violates the principles of reflection. Reflection is all about validating as much of our assumptions upfront as we possibly can. For a great theoretical discussion of this topic, check out <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, don't validate</a> by Alexis King.</p>
<p>So how would we encode our assumptions that the fields "lesser" and "greater" must exist in the type system and still have code that compiles? By using <code><a class="el" href="classrfl_1_1_box.html">rfl::Box</a></code> instead of <code>std::unique_ptr</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>DecisionTree {</div>
<div class="line">    <span class="keyword">struct </span>Leaf {</div>
<div class="line">        <span class="keyword">using </span>Tag = <a class="code hl_class" href="classrfl_1_1_literal.html">rfl::Literal</a>&lt;<span class="stringliteral">&quot;Leaf&quot;</span>&gt;;</div>
<div class="line">        <span class="keywordtype">double</span> prediction;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span><a class="code hl_struct" href="class_node.html">Node</a> {</div>
<div class="line">        <span class="keyword">using </span>Tag = <a class="code hl_class" href="classrfl_1_1_literal.html">rfl::Literal</a>&lt;<span class="stringliteral">&quot;Node&quot;</span>&gt;;</div>
<div class="line">        <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;criticalValue&quot;</span>, <span class="keywordtype">double</span>&gt; critical_value;</div>
<div class="line">        <a class="code hl_class" href="classrfl_1_1_box.html">rfl::Box&lt;DecisionTree&gt;</a> lesser;</div>
<div class="line">        <a class="code hl_class" href="classrfl_1_1_box.html">rfl::Box&lt;DecisionTree&gt;</a> greater;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>LeafOrNode = rfl::TaggedUnion&lt;<span class="stringliteral">&quot;type&quot;</span>, Leaf, Node&gt;;</div>
<div class="line"> </div>
<div class="line">    rfl::Field&lt;<span class="stringliteral">&quot;leafOrNode&quot;</span>, LeafOrNode&gt; leaf_or_node;</div>
<div class="line">};</div>
<div class="ttc" id="aclassrfl_1_1_box_html"><div class="ttname"><a href="classrfl_1_1_box.html">rfl::Box</a></div><div class="ttdef"><b>定义</b> Box.hpp:27</div></div>
</div><!-- fragment --><p><code><a class="el" href="classrfl_1_1_box.html">rfl::Box</a></code> is a thin wrapper around <code>std::unique_ptr</code>, but it is guaranteed to <b>never be null</b> (unless you do something egregious such as trying to access it after calling <code>std::move</code>). It is a <code>std::unique_ptr</code> without the <code>nullptr</code>.</p>
<p>If you want to learn more about the evils of null references, check out the <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">Null References: The Billion Dollar Mistake</a> by Tony Hoare, who invented the concept in the first place.</p>
<p>You <b>must</b> initialize <code><a class="el" href="classrfl_1_1_box.html">rfl::Box</a></code> the moment you create it and it cannot be dereferenced until it is destroyed.</p>
<p><code><a class="el" href="classrfl_1_1_box.html">rfl::Box</a></code> can be initialized using <code><a class="el" href="namespacerfl.html#abe491c0b107ed7c5e2c8baaf1a116b01" title="Generates a new Ref&lt;T&gt;.">rfl::make_box</a>&lt;...&gt;(...)</code>, just like <code>std::make_unique&lt;...&gt;(...)</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> leaf1 = DecisionTree::Leaf{.value = 3.0};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> leaf2 = DecisionTree::Leaf{.value = 5.0};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> node =</div>
<div class="line">    DecisionTree::Node{.critical_value = 10.0,</div>
<div class="line">                       .lesser = <a class="code hl_function" href="namespacerfl.html#abe491c0b107ed7c5e2c8baaf1a116b01">rfl::make_box&lt;DecisionTree&gt;</a>(leaf1),</div>
<div class="line">                       .greater = <a class="code hl_function" href="namespacerfl.html#abe491c0b107ed7c5e2c8baaf1a116b01">rfl::make_box&lt;DecisionTree&gt;</a>(leaf2)};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> DecisionTree tree{.leaf_or_node = std::move(node)};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> json_string = <a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write</a>(tree);</div>
<div class="ttc" id="anamespacerfl_1_1json_html_af39a23539424555b8c970d12a58e547f"><div class="ttname"><a href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write</a></div><div class="ttdeci">std::string write(const auto &amp;_obj, const yyjson_write_flag _flag=0)</div><div class="ttdoc">Returns a JSON string.</div><div class="ttdef"><b>定义</b> write.hpp:26</div></div>
<div class="ttc" id="anamespacerfl_html_abe491c0b107ed7c5e2c8baaf1a116b01"><div class="ttname"><a href="namespacerfl.html#abe491c0b107ed7c5e2c8baaf1a116b01">rfl::make_box</a></div><div class="ttdeci">auto make_box(Args &amp;&amp;... _args)</div><div class="ttdoc">Generates a new Ref&lt;T&gt;.</div><div class="ttdef"><b>定义</b> Box.hpp:117</div></div>
</div><!-- fragment --><p>This will result in the following JSON string:</p>
<div class="fragment"><div class="line">{&quot;leafOrNode&quot;:{&quot;type&quot;:&quot;Node&quot;,&quot;criticalValue&quot;:10.0,&quot;lesser&quot;:{&quot;leafOrNode&quot;:{&quot;type&quot;:&quot;Leaf&quot;,&quot;value&quot;:3.0}},&quot;greater&quot;:{&quot;leafOrNode&quot;:{&quot;type&quot;:&quot;Leaf&quot;,&quot;value&quot;:5.0}}}}</div>
</div><!-- fragment --><p>You can also initialize <code><a class="el" href="classrfl_1_1_box.html">rfl::Box</a>&lt;T&gt;</code> from a <code>std::unique_ptr&lt;T&gt;</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code hl_variable" href="yyjson_8h.html#a26c622783fa717b24fe0bbd3e060f74a">ptr</a> = std::make_unique&lt;std::string&gt;(<span class="stringliteral">&quot;Hello World!&quot;</span>);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classrfl_1_1_result.html">rfl::Result&lt;rfl::Box&lt;std::string&gt;</a>&gt; <a class="code hl_struct" href="structbox.html">box</a> = <a class="code hl_function" href="namespacerfl.html#abe491c0b107ed7c5e2c8baaf1a116b01">rfl::make_box&lt;std::string&gt;</a>(std::move(<a class="code hl_variable" href="yyjson_8h.html#a26c622783fa717b24fe0bbd3e060f74a">ptr</a>));</div>
<div class="ttc" id="aclassrfl_1_1_result_html"><div class="ttname"><a href="classrfl_1_1_result.html">rfl::Result</a></div><div class="ttdoc">The Result class is used for monadic error handling.</div><div class="ttdef"><b>定义</b> Result.hpp:68</div></div>
<div class="ttc" id="astructbox_html"><div class="ttname"><a href="structbox.html">box</a></div><div class="ttdef"><b>定义</b> box.h:53</div></div>
<div class="ttc" id="ayyjson_8h_html_a26c622783fa717b24fe0bbd3e060f74a"><div class="ttname"><a href="yyjson_8h.html#a26c622783fa717b24fe0bbd3e060f74a">ptr</a></div><div class="ttdeci">const char * ptr</div><div class="ttdef"><b>定义</b> yyjson.h:7639</div></div>
</div><!-- fragment --><p>Note that <code>box</code> is wrapped in a <code>Result</code>. That is, because we cannot guarantee at compile time that <code>ptr</code> is not <code>nullptr</code>, therefore we need to account for that.</p>
<p>If you want to use reference-counted pointers, instead of unique pointers, you can use <code><a class="el" href="classrfl_1_1_ref.html">rfl::Ref</a></code>. <code><a class="el" href="classrfl_1_1_ref.html">rfl::Ref</a></code> is the same concept as <code><a class="el" href="classrfl_1_1_box.html">rfl::Box</a></code>, but using <code>std::shared_ptr</code> under-the-hood.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>DecisionTree {</div>
<div class="line">    <span class="keyword">struct </span>Leaf {</div>
<div class="line">        <span class="keyword">using </span>Tag = <a class="code hl_class" href="classrfl_1_1_literal.html">rfl::Literal</a>&lt;<span class="stringliteral">&quot;Leaf&quot;</span>&gt;;</div>
<div class="line">        <span class="keywordtype">double</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value</a>;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span><a class="code hl_struct" href="class_node.html">Node</a> {</div>
<div class="line">        <span class="keyword">using </span>Tag = <a class="code hl_class" href="classrfl_1_1_literal.html">rfl::Literal</a>&lt;<span class="stringliteral">&quot;Node&quot;</span>&gt;;</div>
<div class="line">        <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;criticalValue&quot;</span>, <span class="keywordtype">double</span>&gt; critical_value;</div>
<div class="line">        <a class="code hl_class" href="classrfl_1_1_ref.html">rfl::Ref&lt;DecisionTree&gt;</a> lesser;</div>
<div class="line">        <a class="code hl_class" href="classrfl_1_1_ref.html">rfl::Ref&lt;DecisionTree&gt;</a> greater;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>LeafOrNode = rfl::TaggedUnion&lt;<span class="stringliteral">&quot;type&quot;</span>, Leaf, Node&gt;;</div>
<div class="line"> </div>
<div class="line">    rfl::Field&lt;<span class="stringliteral">&quot;leafOrNode&quot;</span>, LeafOrNode&gt; leaf_or_node;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> leaf1 = DecisionTree::Leaf{.value = 3.0};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> leaf2 = DecisionTree::Leaf{.value = 5.0};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> node =</div>
<div class="line">    DecisionTree::Node{.critical_value = 10.0,</div>
<div class="line">                       .lesser = <a class="code hl_function" href="namespacerfl.html#aed181c75f7cf189893248a95bb2d588e">rfl::make_ref&lt;DecisionTree&gt;</a>(leaf1),</div>
<div class="line">                       .greater = <a class="code hl_function" href="namespacerfl.html#aed181c75f7cf189893248a95bb2d588e">rfl::make_ref&lt;DecisionTree&gt;</a>(leaf2)};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> DecisionTree tree{.leaf_or_node = std::move(node)};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> json_string = <a class="code hl_function" href="namespacerfl_1_1json.html#af39a23539424555b8c970d12a58e547f">rfl::json::write</a>(tree);</div>
<div class="ttc" id="aclassrfl_1_1_ref_html"><div class="ttname"><a href="classrfl_1_1_ref.html">rfl::Ref</a></div><div class="ttdef"><b>定义</b> Ref.hpp:16</div></div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_abe8e049f756b5ba547bda825af81b645"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value</a></div><div class="ttdeci">GLsizei GLboolean const GLfloat * value</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:325</div></div>
<div class="ttc" id="anamespacerfl_html_aed181c75f7cf189893248a95bb2d588e"><div class="ttname"><a href="namespacerfl.html#aed181c75f7cf189893248a95bb2d588e">rfl::make_ref</a></div><div class="ttdeci">auto make_ref(Args &amp;&amp;... _args)</div><div class="ttdoc">Generates a new Ref&lt;T&gt;.</div><div class="ttdef"><b>定义</b> Ref.hpp:113</div></div>
</div><!-- fragment --><p>The resulting JSON string is identical:</p>
<div class="fragment"><div class="line">{&quot;leafOrNode&quot;:{&quot;type&quot;:&quot;Node&quot;,&quot;criticalValue&quot;:10.0,&quot;lesser&quot;:{&quot;leafOrNode&quot;:{&quot;type&quot;:&quot;Leaf&quot;,&quot;value&quot;:3.0}},&quot;greater&quot;:{&quot;leafOrNode&quot;:{&quot;type&quot;:&quot;Leaf&quot;,&quot;value&quot;:5.0}}}}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md627"></a>
Deep Copying</h1>
<p>The default <code><a class="el" href="classrfl_1_1_box.html">rfl::Box</a></code> implementation behaves the same as <code>std::unique_ptr</code> in relation to copying, disabling the copy assignment operator and the copy constructor.</p>
<p>An opt-in box implementation, <code><a class="el" href="namespacerfl.html#ab1ef9e7a3fb11bf9f09eecd8a49addf4" title="Template specialization for a box that is copyable.">rfl::CopyableBox</a></code>, bypasses the <code>std::unique_ptr</code> operators and allows copying by calling the contained type's copy constructor and copy assignment operator directly, but otherwise behaves the same as <code><a class="el" href="classrfl_1_1_box.html">rfl::Box</a></code>.</p>
<p>When using <code><a class="el" href="namespacerfl.html#ab1ef9e7a3fb11bf9f09eecd8a49addf4" title="Template specialization for a box that is copyable.">rfl::CopyableBox</a></code>, <code><a class="el" href="namespacerfl.html#abe491c0b107ed7c5e2c8baaf1a116b01" title="Generates a new Ref&lt;T&gt;.">rfl::make_box</a>&lt;...&gt;(...)</code> must be replaced with <code><a class="el" href="namespacerfl.html#ac3716bee653bc1e6b885441a28382830">rfl::make_copyable_box</a>&lt;...&gt;(...)</code>.</p>
<p>This allows for deep-copying of arbitrary-complexity types that contain nested recursive elements:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>DecisionTree {</div>
<div class="line">    <span class="keyword">struct </span>Leaf {</div>
<div class="line">        <span class="keyword">using </span>Tag = <a class="code hl_class" href="classrfl_1_1_literal.html">rfl::Literal</a>&lt;<span class="stringliteral">&quot;Leaf&quot;</span>&gt;;</div>
<div class="line">        <span class="keywordtype">double</span> prediction;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span><a class="code hl_struct" href="class_node.html">Node</a> {</div>
<div class="line">        <span class="keyword">using </span>Tag = <a class="code hl_class" href="classrfl_1_1_literal.html">rfl::Literal</a>&lt;<span class="stringliteral">&quot;Node&quot;</span>&gt;;</div>
<div class="line">        <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;criticalValue&quot;</span>, <span class="keywordtype">double</span>&gt; critical_value;</div>
<div class="line">        <a class="code hl_typedef" href="namespacerfl.html#ab1ef9e7a3fb11bf9f09eecd8a49addf4">rfl::CopyableBox&lt;DecisionTree&gt;</a> lesser;</div>
<div class="line">        <a class="code hl_typedef" href="namespacerfl.html#ab1ef9e7a3fb11bf9f09eecd8a49addf4">rfl::CopyableBox&lt;DecisionTree&gt;</a> greater;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>LeafOrNode = rfl::TaggedUnion&lt;<span class="stringliteral">&quot;type&quot;</span>, Leaf, Node&gt;;</div>
<div class="line"> </div>
<div class="line">    rfl::Field&lt;<span class="stringliteral">&quot;leafOrNode&quot;</span>, LeafOrNode&gt; leaf_or_node;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> leaf1 = DecisionTree::Leaf{.value = 3.0};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> leaf2 = DecisionTree::Leaf{.value = 5.0};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> node =</div>
<div class="line">    DecisionTree::Node{.critical_value = 10.0,</div>
<div class="line">                       .lesser = <a class="code hl_function" href="namespacerfl.html#ac3716bee653bc1e6b885441a28382830">rfl::make_copyable_box&lt;DecisionTree&gt;</a>(leaf1),</div>
<div class="line">                       .greater = <a class="code hl_function" href="namespacerfl.html#ac3716bee653bc1e6b885441a28382830">rfl::make_copyable_box&lt;DecisionTree&gt;</a>(leaf2)};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> DecisionTree tree{.leaf_or_node = std::move(node)};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> different_leaf = DecisionTree::Leaf{.value = 1.0};</div>
<div class="line">DecisionTree <a class="code hl_function" href="level1__impl_8h.html#a7ffc26122ca6f9bec01f9bc5e64f3006">copy</a> = tree;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="namespacerfl.html#ac379420409251e5a3c0bea4a701daf0a">rfl::get&lt;DecisionTree::Node&gt;</a>(<a class="code hl_function" href="level1__impl_8h.html#a7ffc26122ca6f9bec01f9bc5e64f3006">copy</a>.leaf_or_node.get().variant()).lesser = <a class="code hl_function" href="namespacerfl.html#ac3716bee653bc1e6b885441a28382830">rfl::make_copyable_box&lt;DecisionTree&gt;</a>(different_leaf);</div>
<div class="ttc" id="alevel1__impl_8h_html_a7ffc26122ca6f9bec01f9bc5e64f3006"><div class="ttname"><a href="level1__impl_8h.html#a7ffc26122ca6f9bec01f9bc5e64f3006">copy</a></div><div class="ttdeci">int EIGEN_BLAS_FUNC copy(int *n, RealScalar *px, int *incx, RealScalar *py, int *incy)</div><div class="ttdef"><b>定义</b> level1_impl.h:29</div></div>
<div class="ttc" id="anamespacerfl_html_ab1ef9e7a3fb11bf9f09eecd8a49addf4"><div class="ttname"><a href="namespacerfl.html#ab1ef9e7a3fb11bf9f09eecd8a49addf4">rfl::CopyableBox</a></div><div class="ttdeci">Box&lt; T, Copyability::COPYABLE &gt; CopyableBox</div><div class="ttdoc">Template specialization for a box that is copyable.</div><div class="ttdef"><b>定义</b> Box.hpp:123</div></div>
<div class="ttc" id="anamespacerfl_html_ac3716bee653bc1e6b885441a28382830"><div class="ttname"><a href="namespacerfl.html#ac3716bee653bc1e6b885441a28382830">rfl::make_copyable_box</a></div><div class="ttdeci">auto make_copyable_box(Args &amp;&amp;... _args)</div><div class="ttdef"><b>定义</b> Box.hpp:126</div></div>
<div class="ttc" id="anamespacerfl_html_ac379420409251e5a3c0bea4a701daf0a"><div class="ttname"><a href="namespacerfl.html#ac379420409251e5a3c0bea4a701daf0a">rfl::get</a></div><div class="ttdeci">auto &amp; get(NamedTupleType &amp;_tup)</div><div class="ttdoc">Gets a field by index.</div><div class="ttdef"><b>定义</b> get.hpp:11</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
