<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: Custom parsers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_external_2reflect-cpp_2docs_2custom__parser.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Custom parsers</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md560"></a></p>
<h1><a class="anchor" id="autotoc_md561"></a>
<code>rfl::Reflector</code></h1>
<p>If you absolutely do not want to make any changes to your original classes whatsoever, You can create a Reflector template specialization for your type:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacerfl.html">rfl</a> {</div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Reflector&lt;Person&gt; {</div>
<div class="line">  <span class="keyword">struct </span>ReflType {</div>
<div class="line">    std::string first_name;</div>
<div class="line">    std::string last_name;</div>
<div class="line">  };</div>
<div class="line">  </div>
<div class="line">  <span class="keyword">static</span> Person to(<span class="keyword">const</span> ReflType&amp; <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">return</span> {<a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>.first_name, <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>.last_name};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> ReflType from(<span class="keyword">const</span> Person&amp; <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> {<a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>.first_name, <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>.last_name};</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">}</div>
<div class="ttc" id="a_cwise__arg_8cpp_html_a49bb5a0db288a22a099643d44c5abbd6"><div class="ttname"><a href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a></div><div class="ttdeci">ArrayXcf v</div><div class="ttdef"><b>定义</b> Cwise_arg.cpp:1</div></div>
<div class="ttc" id="anamespacerfl_html"><div class="ttname"><a href="namespacerfl.html">rfl</a></div><div class="ttdef"><b>定义</b> AddStructName.hpp:14</div></div>
</div><!-- fragment --><p>It's also fine to define just the <code>from</code> method when the original class is only written, or <code>to</code> when the original class is only read:</p>
<div class="fragment"><div class="line"><span class="comment">// This can only be used for writing.</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacerfl.html">rfl</a> {</div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Reflector&lt;Person&gt; {</div>
<div class="line">  <span class="keyword">struct </span>ReflType {</div>
<div class="line">    std::string first_name;</div>
<div class="line">    std::string last_name;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> ReflType from(<span class="keyword">const</span> Person&amp; <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> {<a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>.first_name, <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>.last_name};</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the <code>ReflType</code> does not have to be a struct. For instance, if you have a custom type called <code>MyCustomType</code> that you want to be serialized as a string, you can do the following:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacerfl.html">rfl</a> {</div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span>Reflector&lt;MyCustomType&gt; {</div>
<div class="line">  <span class="keyword">using </span>ReflType = std::string;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> MyCustomType to(<span class="keyword">const</span> ReflType&amp; str) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">return</span> MyCustomType::from_string(str);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> ReflType from(<span class="keyword">const</span> MyCustomType&amp; <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>.to_string();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md562"></a>
<code>rfl::parsing::CustomParser</code></h1>
<p>Alternatively, you can implement a custom parser using <code><a class="el" href="structrfl_1_1parsing_1_1_custom_parser.html">rfl::parsing::CustomParser</a></code>.</p>
<p>In order to do so, you must do the following:</p>
<p>You must create a helper struct that <em>can</em> be parsed. The helper struct must fulfill the following conditions:</p>
<p>1) It must contain a static method called <code>from_class</code> that takes your original class as an input and returns the helper struct. This method must not throw an exception. 2) (Optional) It must contain a method called <code>to_class</code> that transforms the helper struct into your original class. This method may throw an exception, if you want to. If you can directly construct your custom class from the field values in the order they were declared in the helper struct, you do not have to write a <code>to_class</code> method.</p>
<p>You can then implement a custom parser for your class like this:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacerfl_1_1parsing.html">rfl::parsing</a> {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ReaderType, <span class="keyword">class</span> WriterType, <span class="keyword">class</span> ProcessorsType&gt;</div>
<div class="line"><span class="keyword">struct </span>Parser&lt;ReaderType, WriterType, YourOriginalClass, ProcessorsType&gt;</div>
<div class="line">    : <span class="keyword">public</span> CustomParser&lt;ReaderType, WriterType, ProcessorsType, YourOriginalClass,</div>
<div class="line">                          YourHelperStruct&gt; {};</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace rfl::parsing</span></div>
<div class="ttc" id="anamespacerfl_1_1parsing_html"><div class="ttname"><a href="namespacerfl_1_1parsing.html">rfl::parsing</a></div><div class="ttdef"><b>定义</b> Parser.hpp:12</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md563"></a>
Example</h1>
<p>Suppose your original class looks like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    Person(<span class="keyword">const</span> std::string&amp; _first_name, <span class="keyword">const</span> std::string&amp; _last_name,</div>
<div class="line">           <span class="keyword">const</span> <span class="keywordtype">int</span> _age)</div>
<div class="line">        : first_name_(_first_name), last_name_(_last_name), age_(_age) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; first_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> first_name_; }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; last_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> last_name_; }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_enumvalue" href="namespacectre.html#af1ab492eac22f0bfaebe58d37347ce28a7d637d275668ed6d41a9b97e6ad3a556">age</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> age_; }</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">private</span>:</div>
<div class="line">    std::string first_name_;</div>
<div class="line">    std::string last_name_;</div>
<div class="line">    <span class="keywordtype">int</span> age_;</div>
<div class="line">};</div>
<div class="ttc" id="anamespacectre_html_af1ab492eac22f0bfaebe58d37347ce28a7d637d275668ed6d41a9b97e6ad3a556"><div class="ttname"><a href="namespacectre.html#af1ab492eac22f0bfaebe58d37347ce28a7d637d275668ed6d41a9b97e6ad3a556">ctre::property_type::age</a></div><div class="ttdeci">@ age</div><div class="ttdef"><b>定义</b> ctre.hpp:1910</div></div>
</div><!-- fragment --><p>You can then write a helper struct:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PersonImpl {</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;firstName&quot;</span>, std::string&gt; first_name;</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;lastName&quot;</span>, std::string&gt; last_name;</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 1) Static method that takes your original class as an input and</span></div>
<div class="line">    <span class="comment">//    returns the helper struct.</span></div>
<div class="line">    <span class="comment">//    MUST NOT THROW AN EXCEPTION!</span></div>
<div class="line">    <span class="keyword">static</span> PersonImpl from_class(<span class="keyword">const</span> Person&amp; _p) <span class="keyword">noexcept</span> {</div>
<div class="line">        <span class="keywordflow">return</span> PersonImpl{.first_name = _p.first_name(),</div>
<div class="line">                          .last_name = _p.last_name(),</div>
<div class="line">                          .age = _p.age()};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 2) Const method called `to_class` that transforms the helper struct</span></div>
<div class="line">    <span class="comment">//    into your original class.</span></div>
<div class="line">    <span class="comment">//    In this case, the `to_class` method is actually optional, because</span></div>
<div class="line">    <span class="comment">//    you can directly create Person from the field values.</span></div>
<div class="line">    Person to_class()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Person(first_name(), last_name(), age); }</div>
<div class="line">};</div>
<div class="ttc" id="astructrfl_1_1_rename_html"><div class="ttname"><a href="structrfl_1_1_rename.html">rfl::Rename</a></div><div class="ttdef"><b>定义</b> Rename.hpp:19</div></div>
</div><!-- fragment --><p>You then implement the custom parser:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacerfl_1_1parsing.html">rfl::parsing</a> {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ReaderType, <span class="keyword">class</span> WriterType, <span class="keyword">class</span> ProcessorsType&gt;</div>
<div class="line"><span class="keyword">struct </span>Parser&lt;ReaderType, WriterType, Person, ProcessorsType&gt;</div>
<div class="line">    : <span class="keyword">public</span> CustomParser&lt;ReaderType, WriterType, ProcessorsType, Person, PersonImpl&gt; {};</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace rfl::parsing</span></div>
</div><!-- fragment --><p>Now your custom class is fully supported by reflect-cpp. So for instance, you could parse it inside a vector:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> people = <a class="code hl_function" href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read&lt;std::vector&lt;Person&gt;</a>&gt;(json_str).<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value</a>();</div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_abe8e049f756b5ba547bda825af81b645"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value</a></div><div class="ttdeci">GLsizei GLboolean const GLfloat * value</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:325</div></div>
<div class="ttc" id="anamespacerfl_1_1json_html_a905573518eca04a9c269d1bb32de7dd1"><div class="ttname"><a href="namespacerfl_1_1json.html#a905573518eca04a9c269d1bb32de7dd1">rfl::json::read</a></div><div class="ttdeci">auto read(const InputVarType &amp;_obj)</div><div class="ttdoc">Parses an object from a JSON var.</div><div class="ttdef"><b>定义</b> read.hpp:26</div></div>
</div><!-- fragment --><p>As we have noted, in this particular example, the <code>Person</code> class can be constructed from the field values in <code>PersonImpl</code> in the exact same order they were declared in <code>PersonImpl</code>. So we can drop the <code>.to_class</code> method:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PersonImpl {</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;firstName&quot;</span>, std::string&gt; first_name;</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_rename.html">rfl::Rename</a>&lt;<span class="stringliteral">&quot;lastName&quot;</span>, std::string&gt; last_name;</div>
<div class="line">    <span class="keywordtype">int</span> age;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> PersonImpl from_class(<span class="keyword">const</span> Person&amp; _p) <span class="keyword">noexcept</span> {</div>
<div class="line">        <span class="keywordflow">return</span> PersonImpl{.first_name = _p.first_name(),</div>
<div class="line">                          .last_name = _p.last_name(),</div>
<div class="line">                          .age = _p.age()};</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
