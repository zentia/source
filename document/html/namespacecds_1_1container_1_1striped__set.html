<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: cds::container::striped_set 命名空间参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacecds_1_1container_1_1striped__set.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">类</a> &#124;
<a href="#typedef-members">类型定义</a>  </div>
  <div class="headertitle"><div class="title">cds::container::striped_set 命名空间参考</div></div>
</div><!--header-->
<div class="contents">

<p>Striped hash set related definitions  
<a href="#details">更多...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1striped__set_1_1adapt.html">adapt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default adapter for intrusive striped/refinable hash set  <a href="classcds_1_1container_1_1striped__set_1_1adapt.html#details">更多...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
类型定义</h2></td></tr>
<tr class="memitem:a2934a868ebde410fca08353b1da5973e" id="r_a2934a868ebde410fca08353b1da5973e"><td class="memTemplParams" colspan="2">template&lt;size_t LoadFactor&gt; </td></tr>
<tr class="memitem:a2934a868ebde410fca08353b1da5973e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2934a868ebde410fca08353b1da5973e">load_factor_resizing</a> = <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1load__factor__resizing.html">cds::intrusive::striped_set::load_factor_resizing</a>&lt;LoadFactor&gt;</td></tr>
<tr class="memdesc:a2934a868ebde410fca08353b1da5973e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load factor based resizing policy     <br /></td></tr>
<tr class="separator:a2934a868ebde410fca08353b1da5973e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d92ebe8893f51590311f8518509e116" id="r_a6d92ebe8893f51590311f8518509e116"><td class="memTemplParams" colspan="2">template&lt;size_t Numerator, size_t Denominator = 1&gt; </td></tr>
<tr class="memitem:a6d92ebe8893f51590311f8518509e116"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d92ebe8893f51590311f8518509e116">rational_load_factor_resizing</a> = <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1rational__load__factor__resizing.html">cds::intrusive::striped_set::rational_load_factor_resizing</a>&lt;Numerator, Denominator&gt;</td></tr>
<tr class="memdesc:a6d92ebe8893f51590311f8518509e116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rational load factor resizing policy     <br /></td></tr>
<tr class="separator:a6d92ebe8893f51590311f8518509e116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bcbbda8462f13876de492298df10a4" id="r_a01bcbbda8462f13876de492298df10a4"><td class="memTemplParams" colspan="2">template&lt;size_t Threshold&gt; </td></tr>
<tr class="memitem:a01bcbbda8462f13876de492298df10a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a01bcbbda8462f13876de492298df10a4">single_bucket_size_threshold</a> = <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1single__bucket__size__threshold.html">cds::intrusive::striped_set::single_bucket_size_threshold</a>&lt;Threshold&gt;</td></tr>
<tr class="memdesc:a01bcbbda8462f13876de492298df10a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single bucket threshold resizing policy     <br /></td></tr>
<tr class="separator:a01bcbbda8462f13876de492298df10a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6926eacdbf9fb4fc264d6d85d353c2" id="r_a1a6926eacdbf9fb4fc264d6d85d353c2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1no__resizing.html">cds::intrusive::striped_set::no_resizing</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a6926eacdbf9fb4fc264d6d85d353c2">no_resizing</a></td></tr>
<tr class="memdesc:a1a6926eacdbf9fb4fc264d6d85d353c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy resizing policy     <br /></td></tr>
<tr class="separator:a1a6926eacdbf9fb4fc264d6d85d353c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf61af57cc14c32b696e0a70593a30e4" id="r_aaf61af57cc14c32b696e0a70593a30e4"><td class="memTemplParams" colspan="2">template&lt;class Lock = std::mutex, class Alloc = CDS_DEFAULT_ALLOCATOR&gt; </td></tr>
<tr class="memitem:aaf61af57cc14c32b696e0a70593a30e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaf61af57cc14c32b696e0a70593a30e4">striping</a> = <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1striping.html">cds::intrusive::striped_set::striping</a>&lt;Lock, Alloc&gt;</td></tr>
<tr class="memdesc:aaf61af57cc14c32b696e0a70593a30e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock striping concurrent access policy     <br /></td></tr>
<tr class="separator:aaf61af57cc14c32b696e0a70593a30e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1022e641c5c9fa7c8ae0de91c468f77" id="r_af1022e641c5c9fa7c8ae0de91c468f77"><td class="memTemplParams" colspan="2">template&lt;class RecursiveLock = std::recursive_mutex, typename BackOff = cds::backoff::yield, class Alloc = CDS_DEFAULT_ALLOCATOR&gt; </td></tr>
<tr class="memitem:af1022e641c5c9fa7c8ae0de91c468f77"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af1022e641c5c9fa7c8ae0de91c468f77">refinable</a> = <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1refinable.html">cds::intrusive::striped_set::refinable</a>&lt;RecursiveLock, BackOff, Alloc &gt;</td></tr>
<tr class="memdesc:af1022e641c5c9fa7c8ae0de91c468f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refinable concurrent access policy     <br /></td></tr>
<tr class="separator:af1022e641c5c9fa7c8ae0de91c468f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>Striped hash set related definitions </p>
</div><h2 class="groupheader">类型定义说明</h2>
<a id="a2934a868ebde410fca08353b1da5973e" name="a2934a868ebde410fca08353b1da5973e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2934a868ebde410fca08353b1da5973e">&#9670;&#160;</a></span>load_factor_resizing</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t LoadFactor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2934a868ebde410fca08353b1da5973e">cds::container::striped_set::load_factor_resizing</a> = <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1load__factor__resizing.html">cds::intrusive::striped_set::load_factor_resizing</a>&lt;LoadFactor&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load factor based resizing policy    </p>
<p>When total item count in a container exceeds <code>container.bucket_count() * LoadFactor</code> then resizing is needed.</p>
<p>This policy is stateless.</p>
<p>The <code>reset()</code> function is called after the resizing is done. The function is intended for resetting internal state of the policy.    </p>

</div>
</div>
<a id="a1a6926eacdbf9fb4fc264d6d85d353c2" name="a1a6926eacdbf9fb4fc264d6d85d353c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6926eacdbf9fb4fc264d6d85d353c2">&#9670;&#160;</a></span>no_resizing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1no__resizing.html">cds::intrusive::striped_set::no_resizing</a> <a class="el" href="#a1a6926eacdbf9fb4fc264d6d85d353c2">cds::container::striped_set::no_resizing</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dummy resizing policy    </p>
<p>This policy is dummy and always returns <code class="param">false</code> that means no resizing is needed.</p>
<p>This policy is stateless.    </p>

</div>
</div>
<a id="a6d92ebe8893f51590311f8518509e116" name="a6d92ebe8893f51590311f8518509e116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d92ebe8893f51590311f8518509e116">&#9670;&#160;</a></span>rational_load_factor_resizing</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Numerator, size_t Denominator = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6d92ebe8893f51590311f8518509e116">cds::container::striped_set::rational_load_factor_resizing</a> = <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1rational__load__factor__resizing.html">cds::intrusive::striped_set::rational_load_factor_resizing</a>&lt;Numerator, Denominator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rational load factor resizing policy    </p>
<p>When total item count in a container exceeds <code>container.bucket_count() * Numerator / Denominator</code> then resizing is needed.</p>
<p>This policy is stateless: <code class="param">Numerator</code> and <code class="param">Denominator</code> specifies in compile time as template arguments    </p>

</div>
</div>
<a id="af1022e641c5c9fa7c8ae0de91c468f77" name="af1022e641c5c9fa7c8ae0de91c468f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1022e641c5c9fa7c8ae0de91c468f77">&#9670;&#160;</a></span>refinable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RecursiveLock = std::recursive_mutex, typename BackOff = cds::backoff::yield, class Alloc = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af1022e641c5c9fa7c8ae0de91c468f77">cds::container::striped_set::refinable</a> = <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1refinable.html">cds::intrusive::striped_set::refinable</a>&lt;RecursiveLock, BackOff, Alloc &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refinable concurrent access policy    </p>
<p>This is one of available <a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy">opt::mutex_policy</a> option type for <a class="el" href="classcds_1_1container_1_1_striped_set.html" title="Striped hash set">StripedSet</a></p>
<p>Refining is like a striping technique (see <a class="el" href="#aaf61af57cc14c32b696e0a70593a30e4" title="Lock striping concurrent access policy">striped_set::striping</a>) but it allows growing the size of lock array when resizing the hash table. So, the sizes of hash table and lock array are equal.</p>
<p>Template arguments:</p><ul>
<li><code class="param">RecursiveLock</code> - the type of mutex. Reentrant (recursive) mutex is required. The default is <code class="param">std::recursive_mutex</code>. The mutex type should be default-constructible.</li>
<li><code class="param">BackOff</code> - back-off strategy. Default is <a class="el" href="structcds_1_1backoff_1_1yield.html" title="Switch to another thread (yield). Good for thread preemption architecture.">cds::backoff::yield</a></li>
<li><code class="param">Alloc</code> - allocator type used for lock array memory allocation. Default is <code class="param">CDS_DEFAULT_ALLOCATOR</code>.    </li>
</ul>

</div>
</div>
<a id="a01bcbbda8462f13876de492298df10a4" name="a01bcbbda8462f13876de492298df10a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bcbbda8462f13876de492298df10a4">&#9670;&#160;</a></span>single_bucket_size_threshold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Threshold&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a01bcbbda8462f13876de492298df10a4">cds::container::striped_set::single_bucket_size_threshold</a> = <a class="el" href="structcds_1_1intrusive_1_1striped__set_1_1single__bucket__size__threshold.html">cds::intrusive::striped_set::single_bucket_size_threshold</a>&lt;Threshold&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Single bucket threshold resizing policy    </p>
<p>If any single bucket size exceeds the global <code class="param">Threshold</code> then resizing is needed.</p>
<p>This policy is stateless.    </p>

</div>
</div>
<a id="aaf61af57cc14c32b696e0a70593a30e4" name="aaf61af57cc14c32b696e0a70593a30e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf61af57cc14c32b696e0a70593a30e4">&#9670;&#160;</a></span>striping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Lock = std::mutex, class Alloc = CDS_DEFAULT_ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aaf61af57cc14c32b696e0a70593a30e4">cds::container::striped_set::striping</a> = <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1striping.html">cds::intrusive::striped_set::striping</a>&lt;Lock, Alloc&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock striping concurrent access policy    </p>
<p>This is one of available <a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy">opt::mutex_policy</a> option type for <a class="el" href="classcds_1_1container_1_1_striped_set.html" title="Striped hash set">StripedSet</a></p>
<p>Lock striping is very simple technique. The set consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When set is resized, bucket table capacity will be doubled but lock array will not. The lock <code class="param">i</code> protects each bucket <code class="param">j</code>, where <code> j = i mod L </code>, where <code class="param">L</code> - the size of lock array.</p>
<p>The policy contains an internal array of <code class="param">Lock</code> locks.</p>
<p>Template arguments:</p><ul>
<li><code class="param">Lock</code> - the type of mutex. The default is <code class="param">std::mutex</code>. The mutex type should be default-constructible. Note that a spin-lock is not so good suitable for lock striping for performance reason.</li>
<li><code class="param">Alloc</code> - allocator type used for lock array memory allocation. Default is <code class="param">CDS_DEFAULT_ALLOCATOR</code>.    </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container_1_1striped__set.html">striped_set</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
