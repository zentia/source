<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: cds::intrusive::StripedSet&lt; Container, Options &gt; 模板类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classcds_1_1intrusive_1_1_striped_set.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pro-attribs">Protected 属性</a> &#124;
<a href="#pro-static-attribs">静态 Protected 属性</a> &#124;
<a href="classcds_1_1intrusive_1_1_striped_set-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">cds::intrusive::StripedSet&lt; Container, Options &gt; 模板类 参考<div class="ingroups"><a class="el" href="group__cds__intrusive__containers.html">Intrusive containers</a> &raquo; <a class="el" href="group__cds__intrusive__map.html">Set</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Striped hash set  
 <a href="#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="intrusive_2striped__set_8h_source.html">striped_set.h</a>&gt;</code></p>
<div class="dynheader">
类 cds::intrusive::StripedSet&lt; Container, Options &gt; 继承关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set__inherit__graph.png" border="0" usemap="#acds_1_1intrusive_1_1_striped_set_3_01_container_00_01_options_01_4_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<div class="dynheader">
cds::intrusive::StripedSet&lt; Container, Options &gt; 的协作图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set__coll__graph.png" border="0" usemap="#acds_1_1intrusive_1_1_striped_set_3_01_container_00_01_options_01_4_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:a30062f90ac31fe161c7cd4539fcaaf13" id="r_a30062f90ac31fe161c7cd4539fcaaf13"><td class="memItemLeft" align="right" valign="top">typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30062f90ac31fe161c7cd4539fcaaf13">underlying_container_type</a></td></tr>
<tr class="memdesc:a30062f90ac31fe161c7cd4539fcaaf13"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket  <br /></td></tr>
<tr class="separator:a30062f90ac31fe161c7cd4539fcaaf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64586b7a2b21c90196c2116ef594ec04" id="r_a64586b7a2b21c90196c2116ef594ec04"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1adapt.html">cds::intrusive::striped_set::adapt</a>&lt; <a class="el" href="#a30062f90ac31fe161c7cd4539fcaaf13">underlying_container_type</a>, Options... &gt;<a class="el" href="imgui__impl__opengl3__loader_8h.html#ae8396ff85d63082521e3324820df1009">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64586b7a2b21c90196c2116ef594ec04">bucket_type</a></td></tr>
<tr class="memdesc:a64586b7a2b21c90196c2116ef594ec04"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set  <br /></td></tr>
<tr class="separator:a64586b7a2b21c90196c2116ef594ec04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999c16c7efc7a140c386cf8089d43f7b" id="r_a999c16c7efc7a140c386cf8089d43f7b"><td class="memItemLeft" align="right" valign="top">typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a></td></tr>
<tr class="memdesc:a999c16c7efc7a140c386cf8089d43f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the set  <br /></td></tr>
<tr class="separator:a999c16c7efc7a140c386cf8089d43f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b11af7149d2edcdcf89875dd82f29c3" id="r_a3b11af7149d2edcdcf89875dd82f29c3"><td class="memItemLeft" align="right" valign="top">typedef options::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b11af7149d2edcdcf89875dd82f29c3">hash</a></td></tr>
<tr class="memdesc:a3b11af7149d2edcdcf89875dd82f29c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_hash.html">Hash</a> functor  <br /></td></tr>
<tr class="separator:a3b11af7149d2edcdcf89875dd82f29c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc27916ad8566742257adde4f5b0d36c" id="r_abc27916ad8566742257adde4f5b0d36c"><td class="memItemLeft" align="right" valign="top">typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc27916ad8566742257adde4f5b0d36c">item_counter</a></td></tr>
<tr class="memdesc:abc27916ad8566742257adde4f5b0d36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter  <br /></td></tr>
<tr class="separator:abc27916ad8566742257adde4f5b0d36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8cacda66c49872225f89568559aa29" id="r_a3c8cacda66c49872225f89568559aa29"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcds_1_1opt_1_1select__default.html">cds::opt::select_default</a>&lt; typenameoptions::resizing_policy, typenamebucket_type::default_resizing_policy &gt;<a class="el" href="imgui__impl__opengl3__loader_8h.html#ae8396ff85d63082521e3324820df1009">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c8cacda66c49872225f89568559aa29">resizing_policy</a></td></tr>
<tr class="memdesc:a3c8cacda66c49872225f89568559aa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy  <br /></td></tr>
<tr class="separator:a3c8cacda66c49872225f89568559aa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cdc2d40853a651780c1a2afe7309ed" id="r_a47cdc2d40853a651780c1a2afe7309ed"><td class="memItemLeft" align="right" valign="top">typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a></td></tr>
<tr class="memdesc:a47cdc2d40853a651780c1a2afe7309ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options.  <br /></td></tr>
<tr class="separator:a47cdc2d40853a651780c1a2afe7309ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af672d590a91e09833aa27621f7e35c26" id="r_af672d590a91e09833aa27621f7e35c26"><td class="memItemLeft" align="right" valign="top">typedef options::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af672d590a91e09833aa27621f7e35c26">mutex_policy</a></td></tr>
<tr class="memdesc:af672d590a91e09833aa27621f7e35c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy  <br /></td></tr>
<tr class="separator:af672d590a91e09833aa27621f7e35c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7217f5fc38b03f908957969c227dc28" id="r_ad7217f5fc38b03f908957969c227dc28"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcds_1_1details_1_1_allocator.html">cds::details::Allocator</a>&lt; <a class="el" href="#a64586b7a2b21c90196c2116ef594ec04">bucket_type</a>, <a class="el" href="#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7217f5fc38b03f908957969c227dc28">bucket_allocator</a></td></tr>
<tr class="memdesc:ad7217f5fc38b03f908957969c227dc28"><td class="mdescLeft">&#160;</td><td class="mdescRight">bucket allocator type based on <a class="el" href="#a47cdc2d40853a651780c1a2afe7309ed" title="allocator type specified in options.">allocator_type</a>  <br /></td></tr>
<tr class="separator:ad7217f5fc38b03f908957969c227dc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a8c4b97b427950b0b119e6314337611a6" id="r_a8c4b97b427950b0b119e6314337611a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c4b97b427950b0b119e6314337611a6">StripedSet</a> ()</td></tr>
<tr class="memdesc:a8c4b97b427950b0b119e6314337611a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16.  <br /></td></tr>
<tr class="separator:a8c4b97b427950b0b119e6314337611a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8ca33aa2ce383440759a0cf0a177e1" id="r_a1a8ca33aa2ce383440759a0cf0a177e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a8ca33aa2ce383440759a0cf0a177e1">StripedSet</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a1a8ca33aa2ce383440759a0cf0a177e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified  <br /></td></tr>
<tr class="separator:a1a8ca33aa2ce383440759a0cf0a177e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335e83b344ba93844182d4e1ff1708dc" id="r_a335e83b344ba93844182d4e1ff1708dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a335e83b344ba93844182d4e1ff1708dc">StripedSet</a> (size_t nCapacity, <a class="el" href="#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:a335e83b344ba93844182d4e1ff1708dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <br /></td></tr>
<tr class="separator:a335e83b344ba93844182d4e1ff1708dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1c130844fc77ceda65e8822f20b478" id="r_a3e1c130844fc77ceda65e8822f20b478"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e1c130844fc77ceda65e8822f20b478">StripedSet</a> (size_t nCapacity, <a class="el" href="#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:a3e1c130844fc77ceda65e8822f20b478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <br /></td></tr>
<tr class="separator:a3e1c130844fc77ceda65e8822f20b478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723409ba0e656ba3bbd54d41356ec710" id="r_a723409ba0e656ba3bbd54d41356ec710"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a723409ba0e656ba3bbd54d41356ec710">~StripedSet</a> ()</td></tr>
<tr class="memdesc:a723409ba0e656ba3bbd54d41356ec710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data  <br /></td></tr>
<tr class="separator:a723409ba0e656ba3bbd54d41356ec710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9596e3aea5464a77437d6d8cdfc288f5" id="r_a9596e3aea5464a77437d6d8cdfc288f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9596e3aea5464a77437d6d8cdfc288f5">insert</a> (<a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a9596e3aea5464a77437d6d8cdfc288f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node  <br /></td></tr>
<tr class="separator:a9596e3aea5464a77437d6d8cdfc288f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8e96d52afa3d2c265c269af1a1ba3c" id="r_a4e8e96d52afa3d2c265c269af1a1ba3c"><td class="memTemplParams" colspan="2">template&lt;typename Func&gt; </td></tr>
<tr class="memitem:a4e8e96d52afa3d2c265c269af1a1ba3c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4e8e96d52afa3d2c265c269af1a1ba3c">insert</a> (<a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a4e8e96d52afa3d2c265c269af1a1ba3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node  <br /></td></tr>
<tr class="separator:a4e8e96d52afa3d2c265c269af1a1ba3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bb544e5a5053bf54d1b145e0be2057" id="r_ac4bb544e5a5053bf54d1b145e0be2057"><td class="memTemplParams" colspan="2">template&lt;typename Func&gt; </td></tr>
<tr class="memitem:ac4bb544e5a5053bf54d1b145e0be2057"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4bb544e5a5053bf54d1b145e0be2057">update</a> (<a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val, Func <a class="el" href="structfunc.html">func</a>, <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> bAllowInsert=<a class="el" href="yyjson_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="memdesc:ac4bb544e5a5053bf54d1b145e0be2057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node  <br /></td></tr>
<tr class="separator:ac4bb544e5a5053bf54d1b145e0be2057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc4dd64160d03646b1f7c163f95369e" id="r_adbc4dd64160d03646b1f7c163f95369e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbc4dd64160d03646b1f7c163f95369e">unlink</a> (<a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:adbc4dd64160d03646b1f7c163f95369e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the item <code class="param">val</code> from the set  <br /></td></tr>
<tr class="separator:adbc4dd64160d03646b1f7c163f95369e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd7128735b9282d6f830f81232c77f5" id="r_abfd7128735b9282d6f830f81232c77f5"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&gt; </td></tr>
<tr class="memitem:abfd7128735b9282d6f830f81232c77f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abfd7128735b9282d6f830f81232c77f5">erase</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val)</td></tr>
<tr class="memdesc:abfd7128735b9282d6f830f81232c77f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set  <br /></td></tr>
<tr class="separator:abfd7128735b9282d6f830f81232c77f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc892d90499638ee0cf14ecccfc1723" id="r_a9dc892d90499638ee0cf14ecccfc1723"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less&gt; </td></tr>
<tr class="memitem:a9dc892d90499638ee0cf14ecccfc1723"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9dc892d90499638ee0cf14ecccfc1723">erase_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a9dc892d90499638ee0cf14ecccfc1723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:a9dc892d90499638ee0cf14ecccfc1723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff92590e106996553af1ba9424048f" id="r_a57ff92590e106996553af1ba9424048f"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </td></tr>
<tr class="memitem:a57ff92590e106996553af1ba9424048f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a57ff92590e106996553af1ba9424048f">erase</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a57ff92590e106996553af1ba9424048f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set  <br /></td></tr>
<tr class="separator:a57ff92590e106996553af1ba9424048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1642d21a2abdef18258539bf7e1fdc" id="r_a8b1642d21a2abdef18258539bf7e1fdc"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func&gt; </td></tr>
<tr class="memitem:a8b1642d21a2abdef18258539bf7e1fdc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b1642d21a2abdef18258539bf7e1fdc">erase_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Less pred, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a8b1642d21a2abdef18258539bf7e1fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:a8b1642d21a2abdef18258539bf7e1fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54fb6ea73d499f07611f75973244685" id="r_af54fb6ea73d499f07611f75973244685"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </td></tr>
<tr class="memitem:af54fb6ea73d499f07611f75973244685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af54fb6ea73d499f07611f75973244685">find</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> &amp;val, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:af54fb6ea73d499f07611f75973244685"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code>  <br /></td></tr>
<tr class="separator:af54fb6ea73d499f07611f75973244685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47d38de7746c0701b794c02d7cc79bd" id="r_af47d38de7746c0701b794c02d7cc79bd"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func&gt; </td></tr>
<tr class="memitem:af47d38de7746c0701b794c02d7cc79bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af47d38de7746c0701b794c02d7cc79bd">find_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> &amp;val, Less pred, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:af47d38de7746c0701b794c02d7cc79bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate  <br /></td></tr>
<tr class="separator:af47d38de7746c0701b794c02d7cc79bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1c82507b338a1f5e835117652f48d2" id="r_a1d1c82507b338a1f5e835117652f48d2"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </td></tr>
<tr class="memitem:a1d1c82507b338a1f5e835117652f48d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d1c82507b338a1f5e835117652f48d2">find</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a1d1c82507b338a1f5e835117652f48d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code>  <br /></td></tr>
<tr class="separator:a1d1c82507b338a1f5e835117652f48d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4947957c41d99bd6d75ce5b04a975bf5" id="r_a4947957c41d99bd6d75ce5b04a975bf5"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func&gt; </td></tr>
<tr class="memitem:a4947957c41d99bd6d75ce5b04a975bf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4947957c41d99bd6d75ce5b04a975bf5">find_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Less pred, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a4947957c41d99bd6d75ce5b04a975bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate  <br /></td></tr>
<tr class="separator:a4947957c41d99bd6d75ce5b04a975bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e681eacb6163d341cacf39607e1471c" id="r_a5e681eacb6163d341cacf39607e1471c"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&gt; </td></tr>
<tr class="memitem:a5e681eacb6163d341cacf39607e1471c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5e681eacb6163d341cacf39607e1471c">contains</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>)</td></tr>
<tr class="memdesc:a5e681eacb6163d341cacf39607e1471c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code class="param">key</code>  <br /></td></tr>
<tr class="separator:a5e681eacb6163d341cacf39607e1471c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec51f0495dce5375e33dbdad5129488" id="r_aeec51f0495dce5375e33dbdad5129488"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less&gt; </td></tr>
<tr class="memitem:aeec51f0495dce5375e33dbdad5129488"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeec51f0495dce5375e33dbdad5129488">contains</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Less pred)</td></tr>
<tr class="memdesc:aeec51f0495dce5375e33dbdad5129488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code class="param">key</code> using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:aeec51f0495dce5375e33dbdad5129488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5b7ec995eb6c9ab0de511b4848c356" id="r_a8c5b7ec995eb6c9ab0de511b4848c356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c5b7ec995eb6c9ab0de511b4848c356">clear</a> ()</td></tr>
<tr class="memdesc:a8c5b7ec995eb6c9ab0de511b4848c356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set  <br /></td></tr>
<tr class="separator:a8c5b7ec995eb6c9ab0de511b4848c356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922615dc212b034f6946253747c92567" id="r_a922615dc212b034f6946253747c92567"><td class="memTemplParams" colspan="2">template&lt;typename Disposer&gt; </td></tr>
<tr class="memitem:a922615dc212b034f6946253747c92567"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a922615dc212b034f6946253747c92567">clear_and_dispose</a> (Disposer disposer)</td></tr>
<tr class="memdesc:a922615dc212b034f6946253747c92567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set and calls <code class="param">disposer</code> for each item  <br /></td></tr>
<tr class="separator:a922615dc212b034f6946253747c92567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8b6d36e50fd1acd07479381a33742c" id="r_aed8b6d36e50fd1acd07479381a33742c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed8b6d36e50fd1acd07479381a33742c">empty</a> () const</td></tr>
<tr class="memdesc:aed8b6d36e50fd1acd07479381a33742c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty  <br /></td></tr>
<tr class="separator:aed8b6d36e50fd1acd07479381a33742c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c092c8ee3f7068d59f5f1aed4321a9" id="r_a49c092c8ee3f7068d59f5f1aed4321a9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49c092c8ee3f7068d59f5f1aed4321a9">size</a> () const</td></tr>
<tr class="memdesc:a49c092c8ee3f7068d59f5f1aed4321a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set  <br /></td></tr>
<tr class="separator:a49c092c8ee3f7068d59f5f1aed4321a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98e2fa3c84dc5f9b370970ce16ba3fe" id="r_ab98e2fa3c84dc5f9b370970ce16ba3fe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab98e2fa3c84dc5f9b370970ce16ba3fe">bucket_count</a> () const</td></tr>
<tr class="memdesc:ab98e2fa3c84dc5f9b370970ce16ba3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table  <br /></td></tr>
<tr class="separator:ab98e2fa3c84dc5f9b370970ce16ba3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bc8a0b0ff0c96f164d83dcf2e9bbe0" id="r_a60bc8a0b0ff0c96f164d83dcf2e9bbe0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60bc8a0b0ff0c96f164d83dcf2e9bbe0">lock_count</a> () const</td></tr>
<tr class="memdesc:a60bc8a0b0ff0c96f164d83dcf2e9bbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size  <br /></td></tr>
<tr class="separator:a60bc8a0b0ff0c96f164d83dcf2e9bbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406fe935c8ea68d5af3f7502e9435624" id="r_a406fe935c8ea68d5af3f7502e9435624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a406fe935c8ea68d5af3f7502e9435624">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:a406fe935c8ea68d5af3f7502e9435624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object  <br /></td></tr>
<tr class="separator:a406fe935c8ea68d5af3f7502e9435624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc7f1e8c66478d0fc7972d27ab1bb4b" id="r_a8cc7f1e8c66478d0fc7972d27ab1bb4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cc7f1e8c66478d0fc7972d27ab1bb4b">get_resizing_policy</a> () const</td></tr>
<tr class="memdesc:a8cc7f1e8c66478d0fc7972d27ab1bb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version)  <br /></td></tr>
<tr class="separator:a8cc7f1e8c66478d0fc7972d27ab1bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected 属性</h2></td></tr>
<tr class="memitem:aa37baad9eed29bf24f0ddf890e0d01e8" id="r_aa37baad9eed29bf24f0ddf890e0d01e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a64586b7a2b21c90196c2116ef594ec04">bucket_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa37baad9eed29bf24f0ddf890e0d01e8">m_Buckets</a></td></tr>
<tr class="memdesc:aa37baad9eed29bf24f0ddf890e0d01e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table  <br /></td></tr>
<tr class="separator:aa37baad9eed29bf24f0ddf890e0d01e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dafe2df57e9f2b43293ea825982b473" id="r_a2dafe2df57e9f2b43293ea825982b473"><td class="memItemLeft" align="right" valign="top">atomics::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dafe2df57e9f2b43293ea825982b473">m_nBucketMask</a></td></tr>
<tr class="memdesc:a2dafe2df57e9f2b43293ea825982b473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table size - 1. m_nBucketMask + 1 should be power of two.  <br /></td></tr>
<tr class="separator:a2dafe2df57e9f2b43293ea825982b473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1657b63e8f07fd22c313304f2d3ca0c5" id="r_a1657b63e8f07fd22c313304f2d3ca0c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abc27916ad8566742257adde4f5b0d36c">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1657b63e8f07fd22c313304f2d3ca0c5">m_ItemCounter</a></td></tr>
<tr class="memdesc:a1657b63e8f07fd22c313304f2d3ca0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter  <br /></td></tr>
<tr class="separator:a1657b63e8f07fd22c313304f2d3ca0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b44bfb69b63d39d2a966b416736716" id="r_a13b44bfb69b63d39d2a966b416736716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3b11af7149d2edcdcf89875dd82f29c3">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13b44bfb69b63d39d2a966b416736716">m_Hash</a></td></tr>
<tr class="memdesc:a13b44bfb69b63d39d2a966b416736716"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_hash.html">Hash</a> functor  <br /></td></tr>
<tr class="separator:a13b44bfb69b63d39d2a966b416736716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104ff1225ca65268f90dd235698e6f36" id="r_a104ff1225ca65268f90dd235698e6f36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af672d590a91e09833aa27621f7e35c26">mutex_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a104ff1225ca65268f90dd235698e6f36">m_MutexPolicy</a></td></tr>
<tr class="memdesc:a104ff1225ca65268f90dd235698e6f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy  <br /></td></tr>
<tr class="separator:a104ff1225ca65268f90dd235698e6f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a40adaba75040b3646fab1ad4bc133" id="r_ab6a40adaba75040b3646fab1ad4bc133"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3c8cacda66c49872225f89568559aa29">resizing_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6a40adaba75040b3646fab1ad4bc133">m_ResizingPolicy</a></td></tr>
<tr class="memdesc:ab6a40adaba75040b3646fab1ad4bc133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy  <br /></td></tr>
<tr class="separator:ab6a40adaba75040b3646fab1ad4bc133"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
静态 Protected 属性</h2></td></tr>
<tr class="memitem:acd3aab8a3065331de1f6ad410fa94d7f" id="r_acd3aab8a3065331de1f6ad410fa94d7f"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd3aab8a3065331de1f6ad410fa94d7f">c_nMinimalCapacity</a> = 16</td></tr>
<tr class="memdesc:acd3aab8a3065331de1f6ad410fa94d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_minimal.html" title="Wrapper around T where all members are private.">Minimal</a> capacity  <br /></td></tr>
<tr class="separator:acd3aab8a3065331de1f6ad410fa94d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Container, typename... Options&gt;<br />
class cds::intrusive::StripedSet&lt; Container, Options &gt;</div><p>Striped hash set </p>
<p>Source</p><ul>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>Lock striping is very simple technique. The set consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When set is resized, bucket table capacity will be doubled but lock array will not. The lock <code class="param">i</code> protects each bucket <code class="param">j</code>, where <code> j = i mod L </code>, where <code class="param">L</code> - the size of lock array.</p>
<p>Template arguments:</p><ul>
<li><code class="param">Container</code> - the container class that is used as bucket table entry. The <code class="param">Container</code> class should support an uniform interface described below.</li>
<li><code class="param">Options</code> - options</li>
</ul>
<p>The <code class="param">StripedSet</code> class does not exactly dictate the type of container that should be used as a <code class="param">Container</code> bucket. Instead, the class supports different intrusive container type for the bucket, for exampe, <code class="param">boost::intrusive::list</code>, <code class="param">boost::intrusive::set</code> and others.</p>
<p>Remember that <code class="param">StripedSet</code> class algorithm ensures sequential blocking access to its bucket through the mutex type you specify among <code class="param">Options</code> template arguments.</p>
<p>The <code class="param">Options</code> are:</p><ul>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy">opt::mutex_policy</a></code> - concurrent access policy. Available policies: <code class="param"><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1striping.html" title="Lock striping concurrent access policy">striped_set::striping</a></code>, <code class="param"><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1refinable.html" title="Refinable concurrent access policy">striped_set::refinable</a></code>. Default is <code class="param">striped_set::striping</code>.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function">cds::opt::hash</a></code> - hash functor. Default option value see <code>opt::v::hash_selector &lt;<a class="el" href="structcds_1_1opt_1_1none.html" title="Type indicates that an option is not specified and the default one should be used">opt::none</a>&gt;</code> which selects default hash functor for your compiler.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">cds::opt::compare</a></code> - key comparison functor. No default functor is provided. If the option is not specified, the <code class="param"><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a></code> is used.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">cds::opt::less</a></code> - specifies binary predicate used for key comparison. Default is <code class="param">std::less&lt;T&gt;</code>.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">cds::opt::item_counter</a></code> - item counter type. Default is <code class="param"><a class="el" href="classcds_1_1atomicity_1_1item__counter.html" title="Atomic item counter">atomicity::item_counter</a></code> since some operation on the counter is performed without locks. Note that item counting is an essential part of the set algorithm, so dummy counter like <code class="param"><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter">atomicity::empty_item_counter</a></code> is not suitable.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">cds::opt::allocator</a></code> - the allocator type using for memory allocation of bucket table and lock array. Default is <a class="el" href="external_2libcds_2cds_2user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1resizing__policy.html" title="Resizing policy option">cds::opt::resizing_policy</a></code> - the resizing policy - a functor that decides when to resize the hash set. Default option value depends on bucket container type: for sequential containers like <code class="param">boost::intrusive::list</code> the resizing policy is <code><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a2934a868ebde410fca08353b1da5973e" title="Load factor based resizing policy">cds::container::striped_set::load_factor_resizing&lt;4&gt;</a> </code>; for other type of containers like <code class="param">boost::intrusive::set</code> the resizing policy is <a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1a6926eacdbf9fb4fc264d6d85d353c2" title="Dummy resizing policy">cds::container::striped_set::no_resizing</a>. See <a class="el" href="group__cds__striped__resizing__policy.html">available resizing policy</a>. Note that the choose of resizing policy depends of <code class="param">Container</code> type: for sequential containers like <code class="param">boost::intrusive::list</code> the right policy can significantly improve performance. For other, non-sequential types of <code class="param">Container</code> (like a <code class="param">boost::intrusive::set</code>) the resizing policy is not so important.</li>
<li><p class="startli"><code class="param"><a class="el" href="structcds_1_1opt_1_1buffer.html" title="[type-option] Option setter for user-provided plain buffer">cds::opt::buffer</a></code> - an initialized buffer type used only for <code class="param">boost::intrusive::unordered_set</code>. Default is <code><a class="el" href="classcds_1_1opt_1_1v_1_1initialized__static__buffer.html" title="Static initialized buffer">cds::opt::v::initialized_static_buffer&lt; cds::any_type, 256 &gt;</a> </code>.</p>
<p class="startli"><code class="param"><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a></code> or <code class="param"><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a></code> options are used in some <code class="param">Container</code> class for ordering. <code class="param">opt::compare</code> option has the highest priority: if <code class="param">opt::compare</code> is specified, <code class="param">opt::less</code> is not used.</p>
<p class="startli">You can pass other option that would be passed to <code class="param">adapt</code> metafunction, see below.</p>
</li>
</ul>
<p><b>Internal details</b> </p><pre class="fragment">The \p %StripedSet class cannot utilize the \p Container specified directly, but only its adapted variant which
supports an unified interface. Internally, the adaptation is made via \p intrusive::striped_set::adapt metafunction that wraps bucket container
and provides the unified bucket interface suitable for \p %StripedSet. Such adaptation is completely transparent for you -
you don't need to call \p adapt metafunction directly, \p %StripedSet class's internal machinery itself invokes appropriate
\p adapt metafunction specialization to adjust your \p Container container class to \p %StripedSet bucket's internal interface.
All you need is to include a right header before &lt;tt&gt;striped_set.h&lt;/tt&gt;.

By default, &lt;tt&gt;intrusive::striped_set::adapt&lt;AnyContainer, OptionPack&gt; &lt;/tt&gt; metafunction does not make any wrapping to \p AnyContainer,
so, the result &lt;tt&gt;intrusive::striped_set::adapt&lt;AnyContainer, OptionPack&gt;::type &lt;/tt&gt; is the same as \p AnyContainer.
However, there are a lot of specializations of \p %intrusive::striped_set::adapt for \p boost::intrusive containers, see table below.
Any of this specialization wraps corresponding container making it suitable for the set's bucket.
Remember, you should include the proper header file for \p adapt &lt;b&gt;before&lt;/b&gt; including &lt;tt&gt;striped_set.h&lt;/tt&gt;.

\note It is important to specify &lt;tt&gt;boost::intrusive::constant_time_size&lt;true&gt;&lt;/tt&gt; option
for all \p boost::intrusive container that supports this option. Fast item counting feature is essential part of
\p %StripedSet resizing algorithm.

&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Container&lt;/th&gt;
        &lt;th&gt;.h-file for \p adapt&lt;/th&gt;
        &lt;th&gt;Example&lt;/th&gt;
        &lt;th&gt;Notes&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::intrusive::list&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/intrusive/striped_set/boost_list.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/intrusive/striped_set/boost_list.h&gt;
            #include &lt;cds/intrusive/striped_set.h&gt;
            typedef cds::intrusive::StripedSet&lt;
            boost::intrusive::list&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;,
                cds::opt::less&lt; std::less&lt;T&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            The list is ordered.
            Template argument pack \p Options &lt;b&gt;must&lt;/b&gt; contain cds::opt::less or cds::opt::compare for type \p T stored in the list
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::intrusive::slist&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/intrusive/striped_set/boost_slist.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/intrusive/striped_set/boost_slist.h&gt;
            #include &lt;cds/intrusive/striped_set.h&gt;
            typedef cds::intrusive::StripedSet&lt;
                boost::intrusive::slist&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;,
                cds::opt::less&lt; std::less&lt;T&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            The list is ordered.
            Template argument pack \p Options &lt;b&gt;must&lt;/b&gt; contain \p cds::opt::less or \p cds::opt::compare for type \p T stored in the list
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::intrusive::set&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/intrusive/striped_set/boost_set.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/intrusive/striped_set/boost_set.h&gt;
            #include &lt;cds/intrusive/striped_set.h&gt;
            typedef cds::intrusive::StripedSet&lt;
                boost::intrusive::set&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            Note that \p boost::intrusive::compare option using in \p boost::intrusive::set
            should support \p T type stored in the set and any type \p Q that you can use
            in \p erase() and \p find() member functions.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::intrusive::unordered_set&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/intrusive/striped_set/boost_unordered_set.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/intrusive/striped_set/boost_unordered_set.h&gt;
            #include &lt;cds/intrusive/striped_set.h&gt;
            typedef cds::intrusive::StripedSet&lt;
                boost::intrusive::unordered_set&lt;T
                    ,boost::intrusive::constant_time_size&lt;true&gt;
                    ,boost::intrusive::hash&lt; user_provided_hash_functor &gt;
                &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            You should provide two different hash function \p h1 and \p h2 - one for \p boost::intrusive::unordered_set
            and other for \p %StripedSet. For the best result, \p h1 and \p h2 must be orthogonal i.e. &lt;tt&gt;h1(X) != h2(X)&lt;/tt&gt; for any value \p X

            The option \p opt::buffer is used for \p boost::intrusive::bucket_traits.
            Default is &lt;tt&gt; cds::opt::v::initialized_static_buffer&lt; cds::any_type, 256 &gt; &lt;/tt&gt;.
            The resizing policy should correlate with the buffer capacity.
            The default resizing policy is &lt;tt&gt;cds::container::striped_set::load_factor_resizing&lt;256&gt; &lt;/tt&gt; what gives load factor 1 for
            default bucket buffer that is the best for \p boost::intrusive::unordered_set.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::intrusive::avl_set&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/intrusive/striped_set/boost_avl_set.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/intrusive/striped_set/boost_avl_set.h&gt;
            #include &lt;cds/intrusive/striped_set.h&gt;
            typedef cds::intrusive::StripedSet&lt;
                boost::intrusive::avl_set&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            Note that \p boost::intrusive::compare option using in \p boost::intrusive::avl_set
            should support \p T type stored in the set and any type \p Q that you can use
            in \p erase() and \p find() member functions.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::intrusive::sg_set&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/intrusive/striped_set/boost_sg_set.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/intrusive/striped_set/boost_sg_set.h&gt;
            #include &lt;cds/intrusive/striped_set.h&gt;
            typedef cds::intrusive::StripedSet&lt;
                boost::intrusive::sg_set&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            Note that \p boost::intrusive::compare option using in \p boost::intrusive::sg_set
            should support \p T type stored in the set and any type \p Q that you can use
            in \p erase() and \p find() member functions.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::intrusive::splay_set&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/intrusive/striped_set/boost_splay_set.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/intrusive/striped_set/boost_splay_set.h&gt;
            #include &lt;cds/intrusive/striped_set.h&gt;
            typedef cds::intrusive::StripedSet&lt;
                boost::intrusive::splay_set&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            Note that \p boost::intrusive::compare option using in \p boost::intrusive::splay_set
            should support \p T type stored in the set and any type \p Q that you can use
            in \p erase() and \p find() member functions.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::intrusive::treap_set&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/intrusive/striped_set/boost_treap_set.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/intrusive/striped_set/boost_treap_set.h&gt;
            #include &lt;cds/intrusive/striped_set.h&gt;
            typedef cds::intrusive::StripedSet&lt;
                boost::intrusive::treap_set&lt;T, boost::intrusive::constant_time_size&lt;true&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            Note that \p boost::intrusive::compare option using in \p boost::intrusive::treap_set
            should support \p T type stored in the set and any type \p Q that you can use
            in \p erase() and \p find() member functions.
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

You can use another intrusive container type as striped set's bucket.
Suppose, you have a container class \p MyBestContainer and you want to integrate it with \p StripedSet as bucket type.
There are two possibility:
- either your \p MyBestContainer class has native support of bucket's interface;
    in this case, you can use default \p intrusive::striped_set::adapt metafunction;
- or your \p MyBestContainer class does not support bucket's interface, which means, that you should create a specialization of
    &lt;tt&gt;cds::intrusive::striped_set::adapt&lt;MyBestContainer&gt; &lt;/tt&gt; metafunction providing necessary interface.

The &lt;tt&gt;intrusive::striped_set::adapt&lt; Container, OptionPack &gt;&lt;/tt&gt; metafunction has two template argument:
- \p Container is the class that should be used as the bucket, for example, &lt;tt&gt;boost::intrusive::list&lt; T &gt;&lt;/tt&gt;.
- \p OptionPack is the packed options from \p %StripedSet declaration. The \p adapt metafunction can use
    any option from \p OptionPack for its internal use. For example, a \p compare option can be passed to \p adapt
    metafunction via \p OptionPack argument of \p %StripedSet declaration.

See \p intrusive::striped_set::adapt metafunction for the description of interface that the bucket container must provide
to be \p %StripedSet compatible.
</pre> </div><h2 class="groupheader">成员类型定义说明</h2>
<a id="a47cdc2d40853a651780c1a2afe7309ed" name="a47cdc2d40853a651780c1a2afe7309ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cdc2d40853a651780c1a2afe7309ed">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef options::allocator <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocator type specified in options. </p>

</div>
</div>
<a id="ad7217f5fc38b03f908957969c227dc28" name="ad7217f5fc38b03f908957969c227dc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7217f5fc38b03f908957969c227dc28">&#9670;&#160;</a></span>bucket_allocator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcds_1_1details_1_1_allocator.html">cds::details::Allocator</a>&lt; <a class="el" href="#a64586b7a2b21c90196c2116ef594ec04">bucket_type</a>, <a class="el" href="#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a> &gt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::bucket_allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bucket allocator type based on <a class="el" href="#a47cdc2d40853a651780c1a2afe7309ed" title="allocator type specified in options.">allocator_type</a> </p>

</div>
</div>
<a id="a64586b7a2b21c90196c2116ef594ec04" name="a64586b7a2b21c90196c2116ef594ec04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64586b7a2b21c90196c2116ef594ec04">&#9670;&#160;</a></span>bucket_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1adapt.html">cds::intrusive::striped_set::adapt</a>&lt;<a class="el" href="#a30062f90ac31fe161c7cd4539fcaaf13">underlying_container_type</a>,Options...&gt;<a class="el" href="imgui__impl__opengl3__loader_8h.html#ae8396ff85d63082521e3324820df1009">::type</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::bucket_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>container type adapted for hash set </p>

</div>
</div>
<a id="a3b11af7149d2edcdcf89875dd82f29c3" name="a3b11af7149d2edcdcf89875dd82f29c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b11af7149d2edcdcf89875dd82f29c3">&#9670;&#160;</a></span>hash</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef options::hash <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;<a class="el" href="structhash.html">::hash</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_hash.html">Hash</a> functor </p>

</div>
</div>
<a id="abc27916ad8566742257adde4f5b0d36c" name="abc27916ad8566742257adde4f5b0d36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc27916ad8566742257adde4f5b0d36c">&#9670;&#160;</a></span>item_counter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef options::item_counter <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::item_counter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Item counter </p>

</div>
</div>
<a id="af672d590a91e09833aa27621f7e35c26" name="af672d590a91e09833aa27621f7e35c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af672d590a91e09833aa27621f7e35c26">&#9670;&#160;</a></span>mutex_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef options::mutex_policy <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::mutex_policy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutex policy </p>

</div>
</div>
<a id="a3c8cacda66c49872225f89568559aa29" name="a3c8cacda66c49872225f89568559aa29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8cacda66c49872225f89568559aa29">&#9670;&#160;</a></span>resizing_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcds_1_1opt_1_1select__default.html">cds::opt::select_default</a>&lt;typenameoptions::resizing_policy,typenamebucket_type::default_resizing_policy&gt;<a class="el" href="imgui__impl__opengl3__loader_8h.html#ae8396ff85d63082521e3324820df1009">::type</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::resizing_policy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizing policy </p>

</div>
</div>
<a id="a30062f90ac31fe161c7cd4539fcaaf13" name="a30062f90ac31fe161c7cd4539fcaaf13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30062f90ac31fe161c7cd4539fcaaf13">&#9670;&#160;</a></span>underlying_container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Container <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::underlying_container_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>original intrusive container type for the bucket </p>

</div>
</div>
<a id="a999c16c7efc7a140c386cf8089d43f7b" name="a999c16c7efc7a140c386cf8089d43f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999c16c7efc7a140c386cf8089d43f7b">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bucket_type::value_type <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>value type stored in the set </p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a id="a8c4b97b427950b0b119e6314337611a6" name="a8c4b97b427950b0b119e6314337611a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4b97b427950b0b119e6314337611a6">&#9670;&#160;</a></span>StripedSet() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::StripedSet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default ctor. The initial capacity is 16. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a8c4b97b427950b0b119e6314337611a6_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a8c4b97b427950b0b119e6314337611a6_cgraph" alt=""/></div>
<!-- MAP 2 -->
</div>

</div>
</div>
<a id="a1a8ca33aa2ce383440759a0cf0a177e1" name="a1a8ca33aa2ce383440759a0cf0a177e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8ca33aa2ce383440759a0cf0a177e1">&#9670;&#160;</a></span>StripedSet() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::StripedSet </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nCapacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with initial capacity specified </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a1a8ca33aa2ce383440759a0cf0a177e1_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a1a8ca33aa2ce383440759a0cf0a177e1_cgraph" alt=""/></div>
<!-- MAP 3 -->
</div>

</div>
</div>
<a id="a335e83b344ba93844182d4e1ff1708dc" name="a335e83b344ba93844182d4e1ff1708dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335e83b344ba93844182d4e1ff1708dc">&#9670;&#160;</a></span>StripedSet() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::StripedSet </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nCapacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>resizingPolicy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (copy semantics) </p>
<p>This constructor initializes m_ResizingPolicy member with copy of <code class="param">resizingPolicy</code> parameter </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16.  </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a335e83b344ba93844182d4e1ff1708dc_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a335e83b344ba93844182d4e1ff1708dc_cgraph" alt=""/></div>
<!-- MAP 4 -->
</div>

</div>
</div>
<a id="a3e1c130844fc77ceda65e8822f20b478" name="a3e1c130844fc77ceda65e8822f20b478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1c130844fc77ceda65e8822f20b478">&#9670;&#160;</a></span>StripedSet() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::StripedSet </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nCapacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>resizingPolicy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (move semantics) </p>
<p>This constructor initializes m_ResizingPolicy member moving <code class="param">resizingPolicy</code> parameter Move semantics is used. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16.  </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a3e1c130844fc77ceda65e8822f20b478_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a3e1c130844fc77ceda65e8822f20b478_cgraph" alt=""/></div>
<!-- MAP 5 -->
</div>

</div>
</div>
<a id="a723409ba0e656ba3bbd54d41356ec710" name="a723409ba0e656ba3bbd54d41356ec710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723409ba0e656ba3bbd54d41356ec710">&#9670;&#160;</a></span>~StripedSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::~<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">StripedSet</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor destroys internal data </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a723409ba0e656ba3bbd54d41356ec710_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a723409ba0e656ba3bbd54d41356ec710_cgraph" alt=""/></div>
<!-- MAP 6 -->
</div>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="ab98e2fa3c84dc5f9b370970ce16ba3fe" name="ab98e2fa3c84dc5f9b370970ce16ba3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98e2fa3c84dc5f9b370970ce16ba3fe">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a id="a8c5b7ec995eb6c9ab0de511b4848c356" name="a8c5b7ec995eb6c9ab0de511b4848c356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5b7ec995eb6c9ab0de511b4848c356">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set </p>
<p>The function unlinks all items from the set. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a8c5b7ec995eb6c9ab0de511b4848c356_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a8c5b7ec995eb6c9ab0de511b4848c356_cgraph" alt=""/></div>
<!-- MAP 7 -->
</div>

</div>
</div>
<a id="a922615dc212b034f6946253747c92567" name="a922615dc212b034f6946253747c92567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922615dc212b034f6946253747c92567">&#9670;&#160;</a></span>clear_and_dispose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Disposer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::clear_and_dispose </td>
          <td>(</td>
          <td class="paramtype">Disposer</td>          <td class="paramname"><span class="paramname"><em>disposer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set and calls <code class="param">disposer</code> for each item </p>
<p>The function unlinks all items from the set calling <code class="param">disposer</code> for each item. <code class="param">Disposer</code> functor interface is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Disposer{</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code hl_typedef" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> * <a class="code hl_variable" href="main-override_8cpp.html#a117104b82864d3b23ec174af6d392709">p</a> );</div>
<div class="line">};</div>
<div class="ttc" id="aclasscds_1_1intrusive_1_1_striped_set_html_a999c16c7efc7a140c386cf8089d43f7b"><div class="ttname"><a href="#a999c16c7efc7a140c386cf8089d43f7b">cds::intrusive::StripedSet::value_type</a></div><div class="ttdeci">bucket_type::value_type value_type</div><div class="ttdoc">value type stored in the set</div><div class="ttdef"><b>定义</b> striped_set.h:290</div></div>
<div class="ttc" id="amain-override_8cpp_html_a117104b82864d3b23ec174af6d392709"><div class="ttname"><a href="main-override_8cpp.html#a117104b82864d3b23ec174af6d392709">p</a></div><div class="ttdeci">static void * p</div><div class="ttdef"><b>定义</b> main-override.cpp:75</div></div>
</div><!-- fragment --> <div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a922615dc212b034f6946253747c92567_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a922615dc212b034f6946253747c92567_cgraph" alt=""/></div>
<!-- MAP 8 -->
</div>

</div>
</div>
<a id="a5e681eacb6163d341cacf39607e1471c" name="a5e681eacb6163d341cacf39607e1471c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e681eacb6163d341cacf39607e1471c">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code class="param">key</code> </p>
<p>The function searches the item with key equal to <code class="param">key</code> and returns <code class="param">true</code> if it is found, and <code class="param">false</code> otherwise.</p>
<p>Note the hash functor specified for class <code class="param">Traits</code> template parameter should accept a parameter of type <code class="param">Q</code> that can be not the same as <code class="param"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b" title="value type stored in the set">value_type</a></code>. Otherwise, you may use <code class="param"><a class="el" href="#aeec51f0495dce5375e33dbdad5129488" title="Checks whether the set contains key using pred predicate for searching">contains( Q const&amp;, Less pred )</a></code> functions with explicit predicate for key comparing. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a5e681eacb6163d341cacf39607e1471c_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a5e681eacb6163d341cacf39607e1471c_cgraph" alt=""/></div>
<!-- MAP 9 -->
</div>

</div>
</div>
<a id="aeec51f0495dce5375e33dbdad5129488" name="aeec51f0495dce5375e33dbdad5129488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec51f0495dce5375e33dbdad5129488">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code class="param">key</code> using <code class="param">pred</code> predicate for searching </p>
<p>The function is an analog of <code>contains( key )</code> but <code class="param">pred</code> is used for key comparing. <code class="param">Less</code> functor has the interface like <code class="param">std::less</code>. <code class="param">Less</code> must imply the same element order as the comparator used for building the set. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_aeec51f0495dce5375e33dbdad5129488_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_aeec51f0495dce5375e33dbdad5129488_cgraph" alt=""/></div>
<!-- MAP 10 -->
</div>

</div>
</div>
<a id="aed8b6d36e50fd1acd07479381a33742c" name="aed8b6d36e50fd1acd07479381a33742c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8b6d36e50fd1acd07479381a33742c">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty </p>
<p>Emptiness is checked by item counting: if item count is zero then the set is empty. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_aed8b6d36e50fd1acd07479381a33742c_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_aed8b6d36e50fd1acd07479381a33742c_cgraph" alt=""/></div>
<!-- MAP 11 -->
</div>

</div>
</div>
<a id="abfd7128735b9282d6f830f81232c77f5" name="abfd7128735b9282d6f830f81232c77f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd7128735b9282d6f830f81232c77f5">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> * <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set </p>
<p><a class="anchor" id="cds_intrusive_StripedSet_erase"></a>The function searches an item with key equal to <code class="param">val</code> in the set, unlinks it from the set, and returns a pointer to unlinked item.</p>
<p>If the item with key equal to <code class="param">val</code> is not found the function return <code class="param">nullptr</code>.</p>
<p>Note the hash functor should accept a parameter of type <code class="param">Q</code> that can be not the same as <code class="param"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b" title="value type stored in the set">value_type</a></code>. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_abfd7128735b9282d6f830f81232c77f5_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_abfd7128735b9282d6f830f81232c77f5_cgraph" alt=""/></div>
<!-- MAP 12 -->
</div>

</div>
</div>
<a id="a57ff92590e106996553af1ba9424048f" name="a57ff92590e106996553af1ba9424048f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ff92590e106996553af1ba9424048f">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> * <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set </p>
<p><a class="anchor" id="cds_intrusive_StripedSet_erase_func"></a> The function searches an item with key equal to <code class="param">val</code> in the set, call <code class="param">f</code> functor with item found, unlinks it from the set, and returns a pointer to unlinked item.</p>
<p>The <code class="param">Func</code> interface is </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code hl_typedef" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> <span class="keyword">const</span>&amp; item );</div>
<div class="line">};</div>
</div><!-- fragment --><p>If the item with key equal to <code class="param">val</code> is not found the function return <code class="param">false</code>.</p>
<p>Note the hash functor should accept a parameter of type <code class="param">Q</code> that can be not the same as <code class="param"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b" title="value type stored in the set">value_type</a></code>. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a57ff92590e106996553af1ba9424048f_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a57ff92590e106996553af1ba9424048f_cgraph" alt=""/></div>
<!-- MAP 13 -->
</div>

</div>
</div>
<a id="a9dc892d90499638ee0cf14ecccfc1723" name="a9dc892d90499638ee0cf14ecccfc1723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc892d90499638ee0cf14ecccfc1723">&#9670;&#160;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> * <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code class="param">pred</code> predicate for searching </p>
<p>The function is an analog of <a class="el" href="#cds_intrusive_StripedSet_erase">erase(Q const&amp;)</a> but <code class="param">pred</code> is used for key comparing <code class="param">Less</code> has the interface like <code class="param">std::less</code>. <code class="param">pred</code> must imply the same element order as the comparator used for building the set. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a9dc892d90499638ee0cf14ecccfc1723_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a9dc892d90499638ee0cf14ecccfc1723_cgraph" alt=""/></div>
<!-- MAP 14 -->
</div>

</div>
</div>
<a id="a8b1642d21a2abdef18258539bf7e1fdc" name="a8b1642d21a2abdef18258539bf7e1fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1642d21a2abdef18258539bf7e1fdc">&#9670;&#160;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> * <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code class="param">pred</code> predicate for searching </p>
<p>The function is an analog of <a class="el" href="#cds_intrusive_StripedSet_erase_func">erase(Q const&amp;, Func)</a> but <code class="param">pred</code> is used for key comparing <code class="param">Less</code> has the interface like <code class="param">std::less</code>. <code class="param">pred</code> must imply the same element order as the comparator used for building the set. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a8b1642d21a2abdef18258539bf7e1fdc_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a8b1642d21a2abdef18258539bf7e1fdc_cgraph" alt=""/></div>
<!-- MAP 15 -->
</div>

</div>
</div>
<a id="af54fb6ea73d499f07611f75973244685" name="af54fb6ea73d499f07611f75973244685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54fb6ea73d499f07611f75973244685">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> </p>
<p><a class="anchor" id="cds_intrusive_StripedSet_find_func"></a>The function searches the item with key equal to <code class="param">val</code> and calls the functor <code class="param">f</code> for item found. The interface of <code class="param">Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code hl_typedef" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>&amp; item, <a class="code hl_variable" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&amp; val );</div>
<div class="line">};</div>
<div class="ttc" id="a_householder_q_r__householder_q_8cpp_html_a7e56035a736d269ad670f312496a0846"><div class="ttname"><a href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a></div><div class="ttdeci">MatrixXf Q</div><div class="ttdef"><b>定义</b> HouseholderQR_householderQ.cpp:1</div></div>
</div><!-- fragment --><p> where <code class="param">item</code> is the item found, <code class="param">val</code> is the <code>find</code> function argument.</p>
<p>The functor may change non-key fields of <code class="param">item</code>.</p>
<p>The <code class="param">val</code> argument is non-const since it can be used as <code class="param">f</code> functor destination i.e., the functor may modify both arguments.</p>
<p>Note the hash functor specified for class <code class="param">Traits</code> template parameter should accept a parameter of type <code class="param">Q</code> that can be not the same as <code class="param"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b" title="value type stored in the set">value_type</a></code>.</p>
<p>The function returns <code class="param">true</code> if <code class="param">val</code> is found, <code class="param">false</code> otherwise. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_af54fb6ea73d499f07611f75973244685_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_af54fb6ea73d499f07611f75973244685_cgraph" alt=""/></div>
<!-- MAP 16 -->
</div>

</div>
</div>
<a id="a1d1c82507b338a1f5e835117652f48d2" name="a1d1c82507b338a1f5e835117652f48d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1c82507b338a1f5e835117652f48d2">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> </p>
<p><a class="anchor" id="cds_intrusive_StripedSet_find_cfunc"></a>The function searches the item with key equal to <code class="param">val</code> and calls the functor <code class="param">f</code> for item found. The interface of <code class="param">Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code hl_typedef" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>&amp; item, <a class="code hl_variable" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> <span class="keyword">const</span>&amp; val );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code class="param">item</code> is the item found, <code class="param">val</code> is the <code>find</code> function argument.</p>
<p>The functor may change non-key fields of <code class="param">item</code>.</p>
<p>The <code class="param">val</code> argument is non-const since it can be used as <code class="param">f</code> functor destination i.e., the functor may modify both arguments.</p>
<p>The function returns <code class="param">true</code> if <code class="param">val</code> is found, <code class="param">false</code> otherwise. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a1d1c82507b338a1f5e835117652f48d2_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a1d1c82507b338a1f5e835117652f48d2_cgraph" alt=""/></div>
<!-- MAP 17 -->
</div>

</div>
</div>
<a id="af47d38de7746c0701b794c02d7cc79bd" name="af47d38de7746c0701b794c02d7cc79bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47d38de7746c0701b794c02d7cc79bd">&#9670;&#160;</a></span>find_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate </p>
<p>The function is an analog of <a class="el" href="#cds_intrusive_StripedSet_find_func">find(Q&amp;, Func)</a> but <code class="param">pred</code> is used for key comparing <code class="param">Less</code> has the interface like <code class="param">std::less</code>. <code class="param">pred</code> must imply the same element order as the comparator used for building the set. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_af47d38de7746c0701b794c02d7cc79bd_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_af47d38de7746c0701b794c02d7cc79bd_cgraph" alt=""/></div>
<!-- MAP 18 -->
</div>

</div>
</div>
<a id="a4947957c41d99bd6d75ce5b04a975bf5" name="a4947957c41d99bd6d75ce5b04a975bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4947957c41d99bd6d75ce5b04a975bf5">&#9670;&#160;</a></span>find_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate </p>
<p>The function is an analog of <a class="el" href="#cds_intrusive_StripedSet_find_cfunc">find(Q const&amp;, Func)</a> but <code class="param">pred</code> is used for key comparing <code class="param">Less</code> has the interface like <code class="param">std::less</code>. <code class="param">pred</code> must imply the same element order as the comparator used for building the set. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a4947957c41d99bd6d75ce5b04a975bf5_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a4947957c41d99bd6d75ce5b04a975bf5_cgraph" alt=""/></div>
<!-- MAP 19 -->
</div>

</div>
</div>
<a id="a406fe935c8ea68d5af3f7502e9435624" name="a406fe935c8ea68d5af3f7502e9435624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406fe935c8ea68d5af3f7502e9435624">&#9670;&#160;</a></span>get_resizing_policy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> &amp; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::get_resizing_policy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns resizing policy object </p>

</div>
</div>
<a id="a8cc7f1e8c66478d0fc7972d27ab1bb4b" name="a8cc7f1e8c66478d0fc7972d27ab1bb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc7f1e8c66478d0fc7972d27ab1bb4b">&#9670;&#160;</a></span>get_resizing_policy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> const  &amp; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::get_resizing_policy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns resizing policy (const version) </p>

</div>
</div>
<a id="a9596e3aea5464a77437d6d8cdfc288f5" name="a9596e3aea5464a77437d6d8cdfc288f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9596e3aea5464a77437d6d8cdfc288f5">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node </p>
<p>The function inserts <code class="param">val</code> in the set if it does not contain an item with key equal to <code class="param">val</code>.</p>
<p>Returns <code class="param">true</code> if <code class="param">val</code> is placed into the set, <code class="param">false</code> otherwise. </p>

</div>
</div>
<a id="a4e8e96d52afa3d2c265c269af1a1ba3c" name="a4e8e96d52afa3d2c265c269af1a1ba3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8e96d52afa3d2c265c269af1a1ba3c">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node </p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code class="param">f</code> functor to initialize value-field of <code class="param">val</code>.</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="benchmarks_2async__task_2async__task_8hpp.html#abce53bb5cc1ee70cdc013fd9b93547eb">func</a>( <a class="code hl_typedef" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>&amp; val );</div>
<div class="ttc" id="abenchmarks_2async__task_2async__task_8hpp_html_abce53bb5cc1ee70cdc013fd9b93547eb"><div class="ttname"><a href="benchmarks_2async__task_2async__task_8hpp.html#abce53bb5cc1ee70cdc013fd9b93547eb">func</a></div><div class="ttdeci">void func(std::atomic&lt; size_t &gt; &amp;counter)</div><div class="ttdef"><b>定义</b> async_task.hpp:13</div></div>
</div><!-- fragment --><p> where <code class="param">val</code> is the item inserted. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_a4e8e96d52afa3d2c265c269af1a1ba3c_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_a4e8e96d52afa3d2c265c269af1a1ba3c_cgraph" alt=""/></div>
<!-- MAP 20 -->
</div>

</div>
</div>
<a id="a60bc8a0b0ff0c96f164d83dcf2e9bbe0" name="a60bc8a0b0ff0c96f164d83dcf2e9bbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bc8a0b0ff0c96f164d83dcf2e9bbe0">&#9670;&#160;</a></span>lock_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::lock_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns lock array size </p>

</div>
</div>
<a id="a49c092c8ee3f7068d59f5f1aed4321a9" name="a49c092c8ee3f7068d59f5f1aed4321a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c092c8ee3f7068d59f5f1aed4321a9">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;<a class="el" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">::size</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the set </p>

</div>
</div>
<a id="adbc4dd64160d03646b1f7c163f95369e" name="adbc4dd64160d03646b1f7c163f95369e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc4dd64160d03646b1f7c163f95369e">&#9670;&#160;</a></span>unlink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::unlink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlink the item <code class="param">val</code> from the set </p>
<p>The function searches the item <code class="param">val</code> in the set and unlink it if it is found and is equal to <code class="param">val</code> (here, the equality means that <code class="param">val</code> belongs to the set: if <code class="param">item</code> is an item found then unlink is successful iif <code>&amp;val == &amp;item</code>)</p>
<p>The function returns <code class="param">true</code> if success and <code class="param">false</code> otherwise. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_adbc4dd64160d03646b1f7c163f95369e_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_adbc4dd64160d03646b1f7c163f95369e_cgraph" alt=""/></div>
<!-- MAP 21 -->
</div>

</div>
</div>
<a id="ac4bb544e5a5053bf54d1b145e0be2057" name="ac4bb544e5a5053bf54d1b145e0be2057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bb544e5a5053bf54d1b145e0be2057">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>bAllowInsert</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="yyjson_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the node </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If the item <code class="param">val</code> is not found in the set, then <code class="param">val</code> is inserted iff <code class="param">bAllowInsert</code> is <code class="param">true</code>. Otherwise, the functor <code class="param">func</code> is called with item found. The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="benchmarks_2async__task_2async__task_8hpp.html#abce53bb5cc1ee70cdc013fd9b93547eb">func</a>( <span class="keywordtype">bool</span> bNew, <a class="code hl_typedef" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>&amp; item, <a class="code hl_typedef" href="#a999c16c7efc7a140c386cf8089d43f7b">value_type</a>&amp; val );</div>
</div><!-- fragment --><p> with arguments:</p><ul>
<li><code class="param">bNew</code> - <code class="param">true</code> if the item has been inserted, <code class="param">false</code> otherwise</li>
<li><code class="param">item</code> - item of the set</li>
<li><code class="param">val</code> - argument <code class="param">val</code> passed into the <code class="param"><a class="el" href="#ac4bb544e5a5053bf54d1b145e0be2057" title="Updates the node">update()</a></code> function If new item has been inserted (i.e. <code class="param">bNew</code> is <code class="param">true</code>) then <code class="param">item</code> and <code class="param">val</code> arguments refers to the same thing.</li>
</ul>
<p>The functor may change non-key fields of the <code class="param">item</code>.</p>
<p>Returns std::pair&lt;bool, bool&gt; where <code class="param">first</code> is <code class="param">true</code> if operation is successful, <code class="param">second</code> is <code class="param">true</code> if new item has been added or <code class="param">false</code> if the item with <code class="param">val</code> already is in the set. </p>
<div class="dynheader">
函数调用图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1intrusive_1_1_striped_set_ac4bb544e5a5053bf54d1b145e0be2057_cgraph.png" border="0" usemap="#aclasscds_1_1intrusive_1_1_striped_set_ac4bb544e5a5053bf54d1b145e0be2057_cgraph" alt=""/></div>
<!-- MAP 22 -->
</div>

</div>
</div>
<h2 class="groupheader">类成员变量说明</h2>
<a id="acd3aab8a3065331de1f6ad410fa94d7f" name="acd3aab8a3065331de1f6ad410fa94d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3aab8a3065331de1f6ad410fa94d7f">&#9670;&#160;</a></span>c_nMinimalCapacity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::c_nMinimalCapacity = 16</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_minimal.html" title="Wrapper around T where all members are private.">Minimal</a> capacity </p>

</div>
</div>
<a id="aa37baad9eed29bf24f0ddf890e0d01e8" name="aa37baad9eed29bf24f0ddf890e0d01e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37baad9eed29bf24f0ddf890e0d01e8">&#9670;&#160;</a></span>m_Buckets</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a64586b7a2b21c90196c2116ef594ec04">bucket_type</a>* <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::m_Buckets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bucket table </p>

</div>
</div>
<a id="a13b44bfb69b63d39d2a966b416736716" name="a13b44bfb69b63d39d2a966b416736716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b44bfb69b63d39d2a966b416736716">&#9670;&#160;</a></span>m_Hash</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3b11af7149d2edcdcf89875dd82f29c3">hash</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::m_Hash</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_hash.html">Hash</a> functor </p>

</div>
</div>
<a id="a1657b63e8f07fd22c313304f2d3ca0c5" name="a1657b63e8f07fd22c313304f2d3ca0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1657b63e8f07fd22c313304f2d3ca0c5">&#9670;&#160;</a></span>m_ItemCounter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abc27916ad8566742257adde4f5b0d36c">item_counter</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::m_ItemCounter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Item counter </p>

</div>
</div>
<a id="a104ff1225ca65268f90dd235698e6f36" name="a104ff1225ca65268f90dd235698e6f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104ff1225ca65268f90dd235698e6f36">&#9670;&#160;</a></span>m_MutexPolicy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af672d590a91e09833aa27621f7e35c26">mutex_policy</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::m_MutexPolicy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex policy </p>

</div>
</div>
<a id="a2dafe2df57e9f2b43293ea825982b473" name="a2dafe2df57e9f2b43293ea825982b473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dafe2df57e9f2b43293ea825982b473">&#9670;&#160;</a></span>m_nBucketMask</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">atomics::atomic&lt;size_t&gt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::m_nBucketMask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bucket table size - 1. m_nBucketMask + 1 should be power of two. </p>

</div>
</div>
<a id="ab6a40adaba75040b3646fab1ad4bc133" name="ab6a40adaba75040b3646fab1ad4bc133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a40adaba75040b3646fab1ad4bc133">&#9670;&#160;</a></span>m_ResizingPolicy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet</a>&lt; Container, Options &gt;::m_ResizingPolicy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizing policy </p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>external/libcds/cds/intrusive/<a class="el" href="intrusive_2striped__set_8h_source.html">striped_set.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1intrusive.html">intrusive</a></li><li class="navelem"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">StripedSet</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
