<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: What happens inside Eigen, on a simple example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_topic_inside_eigen_example.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">What happens inside Eigen, on a simple example</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>\eigenAutoToc</p>
<hr  />
<p>Consider the following example program:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;Eigen/Core&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="main-override-static_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a> = 50;</div>
<div class="line">  <span class="comment">// VectorXf is a vector of floats, with dynamic size.</span></div>
<div class="line">  Eigen::VectorXf <a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a>(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>), <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>), <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a>(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>);</div>
<div class="line">  <a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a> = <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a> + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a>;</div>
<div class="line">}</div>
<div class="ttc" id="a_cwise__arg_8cpp_html_a49bb5a0db288a22a099643d44c5abbd6"><div class="ttname"><a href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a></div><div class="ttdeci">ArrayXcf v</div><div class="ttdef"><b>定义</b> Cwise_arg.cpp:1</div></div>
<div class="ttc" id="a_matrix__resize__int_8cpp_html_aab236ce080522c9832217fd5f157541b"><div class="ttname"><a href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a></div><div class="ttdeci">RowVector3d w</div><div class="ttdef"><b>定义</b> Matrix_resize_int.cpp:3</div></div>
<div class="ttc" id="aexternal_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp_html_a2a671aca47b8db55cef1dd7174adad6f"><div class="ttname"><a href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a></div><div class="ttdeci">Universe u</div><div class="ttdef"><b>定义</b> main.cpp:28</div></div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_ac42c05b5701aef6bab82675cf3b55fee"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a></div><div class="ttdeci">GLsizeiptr size</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:272</div></div>
<div class="ttc" id="amain-override-static_8c_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="main-override-static_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>定义</b> main-override-static.c:32</div></div>
</div><!-- fragment --><p>The goal of this page is to understand how <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> compiles it, assuming that SSE2 vectorization is enabled (GCC option -msse2).</p>
<h1><a class="anchor" id="WhyInteresting"></a>
Why it's interesting</h1>
<p>Maybe you think, that the above example program is so simple, that compiling it shouldn't involve anything interesting. So before starting, let us explain what is nontrivial in compiling it correctly &ndash; that is, producing optimized code &ndash; so that the complexity of <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>, that we'll explain here, is really useful.</p>
<p>Look at the line of code </p><div class="fragment"><div class="line"><a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a> = <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a> + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a>;   <span class="comment">//   (*)</span></div>
</div><!-- fragment --><p>The first important thing about compiling it, is that the arrays should be traversed only once, like </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = 0; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++) <a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a>[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a>[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>];</div>
<div class="ttc" id="a_bi_c_g_s_t_a_b__step__by__step_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>定义</b> BiCGSTAB_step_by_step.cpp:9</div></div>
</div><!-- fragment --><p> The problem is that if we make a naive C++ library where the VectorXf class has an operator+ returning a VectorXf, then the line of code (*) will amount to: </p><div class="fragment"><div class="line">VectorXf tmp = <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a> + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a>;</div>
<div class="line">VectorXf <a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a> = tmp;</div>
</div><!-- fragment --><p> Obviously, the introduction of the temporary <em class="arg">tmp</em> here is useless. It has a very bad effect on performance, first because the creation of <em class="arg">tmp</em> requires a dynamic memory allocation in this context, and second as there are now two for loops: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = 0; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++) tmp[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a>[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>];</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = 0; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++) <a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a>[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = tmp[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>];</div>
</div><!-- fragment --><p> Traversing the arrays twice instead of once is terrible for performance, as it means that we do many redundant memory accesses.</p>
<p>The second important thing about compiling the above program, is to make correct use of SSE2 instructions. Notice that <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> also supports AltiVec and that all the discussion that we make here applies also to AltiVec.</p>
<p>SSE2, like AltiVec, is a set of instructions allowing to perform computations on packets of 128 bits at once. Since a float is 32 bits, this means that SSE2 instructions can handle 4 floats at once. This means that, if correctly used, they can make our computation go up to 4x faster.</p>
<p>However, in the above program, we have chosen size=50, so our vectors consist of 50 float's, and 50 is not a multiple of 4. This means that we cannot hope to do all of that computation using SSE2 instructions. The second best thing, to which we should aim, is to handle the 48 first coefficients with SSE2 instructions, since 48 is the biggest multiple of 4 below 50, and then handle separately, without SSE2, the 49th and 50th coefficients. Something like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = 0; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; 4*(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>/4); <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>+=4) <a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a>.packet(<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>)  = <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>.packet(<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>) + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a>.packet(<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> = 4*(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>/4); <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++) <a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a>[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a>[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>];</div>
</div><!-- fragment --><p>So let us look line by line at our example program, and let's follow <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> as it compiles it.</p>
<h1><a class="anchor" id="ConstructingVectors"></a>
Constructing vectors</h1>
<p>Let's analyze the first line:</p>
<div class="fragment"><div class="line">Eigen::VectorXf <a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a>(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>), <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a>(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>), <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a>(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>);</div>
</div><!-- fragment --><p>First of all, VectorXf is the following typedef: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code hl_struct" href="class_matrix.html">Matrix&lt;float, Dynamic, 1&gt;</a> VectorXf;</div>
<div class="ttc" id="aclass_matrix_html"><div class="ttname"><a href="class_matrix.html">Matrix</a></div><div class="ttdef"><b>定义</b> Matrix.h:17</div></div>
</div><!-- fragment --><p>The class template <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a> is declared in <a class="el" href="_forward_declarations_8h.html">src/Core/util/ForwardDeclarations.h</a> with 6 template parameters, but the last 3 are automatically determined by the first 3. So you don't need to worry about them for now. Here, <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a>&lt;float, Dynamic, 1&gt; means a matrix of floats, with a dynamic number of rows and 1 column.</p>
<p>The <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a> class inherits a base class, <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a>. Don't worry about it, for now it suffices to say that <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a> is what unifies matrices/vectors and all the expressions types &ndash; more on that below.</p>
<p>When we do </p><div class="fragment"><div class="line">Eigen::VectorXf <a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a>(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>);</div>
</div><!-- fragment --><p> the constructor that is called is Matrix::Matrix(int), in <a class="el" href="eigen-3_83_87_2_eigen_2src_2_core_2_matrix_8h.html">src/Core/Matrix.h</a>. Besides some assertions, all it does is to construct the <em class="arg">m_storage</em> member, which is of type <a class="el" href="class_eigen_1_1_dense_storage.html">DenseStorage</a>&lt;float, Dynamic, Dynamic, 1&gt;.</p>
<p>You may wonder, isn't it overengineering to have the storage in a separate class? The reason is that the <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a> class template covers all kinds of matrices and vector: both fixed-size and dynamic-size. The storage method is not the same in these two cases. For fixed-size, the matrix coefficients are stored as a plain member array. For dynamic-size, the coefficients will be stored as a pointer to a dynamically-allocated array. Because of this, we need to abstract storage away from the <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a> class. That's <a class="el" href="class_eigen_1_1_dense_storage.html">DenseStorage</a>.</p>
<p>Let's look at this constructor, in <a class="el" href="_dense_storage_8h.html">src/Core/DenseStorage.h</a>. You can see that there are many partial template specializations of DenseStorages here, treating separately the cases where dimensions are Dynamic or fixed at compile-time. The partial specialization that we are looking at is: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keywordtype">int</span> _Cols&gt; <span class="keyword">class </span>DenseStorage&lt;<a class="code hl_define" href="test__overwrite__node_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>, <a class="code hl_variable" href="namespace_eigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, <a class="code hl_variable" href="namespace_eigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, _Cols&gt;</div>
<div class="ttc" id="anamespace_eigen_html_ad81fa7195215a0ce30017dfac309f0b2"><div class="ttname"><a href="namespace_eigen.html#ad81fa7195215a0ce30017dfac309f0b2">Eigen::Dynamic</a></div><div class="ttdeci">const int Dynamic</div><div class="ttdef"><b>定义</b> Constants.h:21</div></div>
<div class="ttc" id="atest__overwrite__node_8cpp_html_a0acb682b8260ab1c60b918599864e2e5"><div class="ttname"><a href="test__overwrite__node_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a></div><div class="ttdeci">#define T</div><div class="ttdef"><b>定义</b> test_overwrite_node.cpp:29</div></div>
</div><!-- fragment --><p>Here, the constructor called is DenseStorage::DenseStorage(int size, int rows, int columns) with size=50, rows=50, columns=1.</p>
<p>Here is this constructor: </p><div class="fragment"><div class="line"><span class="keyword">inline</span> DenseStorage(<span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>, <span class="keywordtype">int</span> <a class="code hl_variable" href="_tutorial__commainit__02_8cpp.html#a061459acc9e078fa4699e0e349887215">rows</a>, <span class="keywordtype">int</span>) : m_data(<a class="code hl_namespace" href="namespaceinternal.html">internal</a>::aligned_new&lt;<a class="code hl_define" href="test__overwrite__node_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>&gt;(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>)), m_rows(<a class="code hl_variable" href="_tutorial__commainit__02_8cpp.html#a061459acc9e078fa4699e0e349887215">rows</a>) {}</div>
<div class="ttc" id="a_tutorial__commainit__02_8cpp_html_a061459acc9e078fa4699e0e349887215"><div class="ttname"><a href="_tutorial__commainit__02_8cpp.html#a061459acc9e078fa4699e0e349887215">rows</a></div><div class="ttdeci">int rows</div><div class="ttdef"><b>定义</b> Tutorial_commainit_02.cpp:1</div></div>
<div class="ttc" id="anamespaceinternal_html"><div class="ttname"><a href="namespaceinternal.html">internal</a></div><div class="ttdef"><b>定义</b> BandTriangularSolver.h:13</div></div>
</div><!-- fragment --><p>Here, the <em class="arg">m_data</em> member is the actual array of coefficients of the matrix. As you see, it is dynamically allocated. Rather than calling new[] or <a class="el" href="mimalloc-override_8h.html#a99aa8fd9f4831e1b0fa9e1cdcde3e249">malloc()</a>, as you can see, we have our own <a class="el" href="namespace_eigen_1_1internal.html#a67fee538128f7d7ccd1dac4cc84dc089">internal::aligned_new</a> defined in <a class="el" href="external_2taskflow_23rd-party_2eigen-3_83_87_2_eigen_2src_2_core_2util_2memory_8h.html">src/Core/util/Memory.h</a>. What it does is that if vectorization is enabled, then it uses a platform-specific call to allocate a 128-bit-aligned array, as that is very useful for vectorization with both SSE2 and AltiVec. If vectorization is disabled, it amounts to the standard new[].</p>
<p>As you can see, the constructor also sets the <em class="arg">m_rows</em> member to <em class="arg">size</em>. Notice that there is no <em class="arg">m_columns</em> member: indeed, in this partial specialization of <a class="el" href="class_eigen_1_1_dense_storage.html">DenseStorage</a>, we know the number of columns at compile-time, since the _Cols template parameter is different from Dynamic. Namely, in our case, _Cols is 1, which is to say that our vector is just a matrix with 1 column. Hence, there is no need to store the number of columns as a runtime variable.</p>
<p>When you call VectorXf::data() to get the pointer to the array of coefficients, it returns <a class="el" href="class_eigen_1_1_dense_storage.html#a7eb6a63c88788a2e3bfe08ca302cb6da">DenseStorage::data()</a> which returns the <em class="arg">m_data</em> member.</p>
<p>When you call VectorXf::size() to get the size of the vector, this is actually a method in the base class <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a>. It determines that the vector is a column-vector, since ColsAtCompileTime==1 (this comes from the template parameters in the typedef VectorXf). It deduces that the size is the number of rows, so it returns VectorXf::rows(), which returns <a class="el" href="class_eigen_1_1_dense_storage.html#a14b68f709f5fb46eeebb203266cc29b2">DenseStorage::rows()</a>, which returns the <em class="arg">m_rows</em> member, which was set to <em class="arg">size</em> by the constructor.</p>
<h1><a class="anchor" id="ConstructionOfSumXpr"></a>
Construction of the sum expression</h1>
<p>Now that our vectors are constructed, let's move on to the next line:</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a> = <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a> + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a>;</div>
</div><!-- fragment --><p>The executive summary is that operator+ returns a "sum of vectors" expression, but doesn't actually perform the computation. It is the operator=, whose call occurs thereafter, that does the computation.</p>
<p>Let us now see what <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> does when it sees this:</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a> + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a></div>
</div><!-- fragment --><p>Here, v and w are of type VectorXf, which is a typedef for a specialization of <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a> (as we explained above), which is a subclass of <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a>. So what is being called is</p>
<div class="fragment"><div class="line">MatrixBase::operator+(<span class="keyword">const</span> MatrixBase&amp;)</div>
</div><!-- fragment --><p>The return type of this operator is </p><div class="fragment"><div class="line">CwiseBinaryOp&lt;internal::scalar_sum_op&lt;float&gt;, VectorXf, VectorXf&gt;</div>
</div><!-- fragment --><p> The <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> class is our first encounter with an expression template. As we said, the operator+ doesn't by itself perform any computation, it just returns an abstract "sum of vectors" expression. Since there are also "difference of vectors" and "coefficient-wise product of vectors" expressions, we unify them all as "coefficient-wise binary operations", which we abbreviate as "CwiseBinaryOp". "Coefficient-wise" means that the operations is performed coefficient by coefficient. "binary" means that there are two operands &ndash; we are adding two vectors with one another.</p>
<p>Now you might ask, what if we did something like</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a> + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a> + <a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a>;</div>
</div><!-- fragment --><p>The first v + w would return a <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> as above, so in order for this to compile, we'd need to define an operator+ also in the class <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a>... at this point it starts looking like a nightmare: are we going to have to define all operators in each of the expression classes (as you guessed, <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> is only one of many) ? This looks like a dead end!</p>
<p>The solution is that <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> itself, as well as <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a> and all the other expression types, is a subclass of <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a>. So it is enough to define once and for all the operators in class <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a>.</p>
<p>Since <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a> is the common base class of different subclasses, the aspects that depend on the subclass must be abstracted from <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a>. This is called polymorphism.</p>
<p>The classical approach to polymorphism in C++ is by means of virtual functions. This is dynamic polymorphism. Here we don't want dynamic polymorphism because the whole design of <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> is based around the assumption that all the complexity, all the abstraction, gets resolved at compile-time. This is crucial: if the abstraction can't get resolved at compile-time, <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>'s compile-time optimization mechanisms become useless, not to mention that if that abstraction has to be resolved at runtime it'll incur an overhead by itself.</p>
<p>Here, what we want is to have a single class <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a> as the base of many subclasses, in such a way that each <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a> object (be it a matrix, or vector, or any kind of expression) knows at compile-time (as opposed to run-time) of which particular subclass it is an object (i.e. whether it is a matrix, or an expression, and what kind of expression).</p>
<p>The solution is the <a href="http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern">Curiously Recurring Template Pattern</a>. Let's do the break now. Hopefully you can read this wikipedia page during the break if needed, but it won't be allowed during the exam.</p>
<p>In short, <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a> takes a template parameter <em class="arg">Derived</em>. Whenever we define a subclass Subclass, we actually make Subclass inherit <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a>&lt;Subclass&gt;. The point is that different subclasses inherit different <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a> types. Thanks to this, whenever we have an object of a subclass, and we call on it some <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a> method, we still remember even from inside the <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a> method which particular subclass we're talking about.</p>
<p>This means that we can put almost all the methods and operators in the base class <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a>, and have only the bare minimum in the subclasses. If you look at the subclasses in <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>, like for instance the <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> class, they have very few methods. There are coeff() and sometimes coeffRef() methods for access to the coefficients, there are <a class="el" href="_tutorial__commainit__02_8cpp.html#a061459acc9e078fa4699e0e349887215">rows()</a> and <a class="el" href="_tutorial__commainit__02_8cpp.html#a4407a60bc4387adae24cee658711f2d9">cols()</a> methods returning the number of rows and columns, but there isn't much more than that. All the meat is in <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a>, so it only needs to be coded once for all kinds of expressions, matrices, and vectors.</p>
<p>So let's end this digression and come back to the piece of code from our example program that we were currently analyzing,</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a> + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a></div>
</div><!-- fragment --><p>Now that <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a> is a good friend, let's write fully the prototype of the operator+ that gets called here (this code is from <a class="el" href="_matrix_base_8h.html">src/Core/MatrixBase.h</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">class </span>MatrixBase</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OtherDerived&gt;</div>
<div class="line">  <span class="keyword">const</span> CwiseBinaryOp&lt;internal::scalar_sum_op&lt;typename internal::traits&lt;Derived&gt;::Scalar&gt;, Derived, OtherDerived&gt;</div>
<div class="line">  <a class="code hl_function" href="namespace_eigen.html#a054138fa4cd47163a7d8d5972044ae09">operator+</a>(<span class="keyword">const</span> <a class="code hl_function" href="class_eigen_1_1_matrix_base.html#a18b1d6bb45230c35c2f5dfa7c76c43d4">MatrixBase&lt;OtherDerived&gt;</a> &amp;other) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="ttc" id="aclass_eigen_1_1_matrix_base_html_a18b1d6bb45230c35c2f5dfa7c76c43d4"><div class="ttname"><a href="class_eigen_1_1_matrix_base.html#a18b1d6bb45230c35c2f5dfa7c76c43d4">Eigen::MatrixBase::MatrixBase</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC MatrixBase()</div><div class="ttdef"><b>定义</b> MatrixBase.h:467</div></div>
<div class="ttc" id="anamespace_eigen_html_a054138fa4cd47163a7d8d5972044ae09"><div class="ttname"><a href="namespace_eigen.html#a054138fa4cd47163a7d8d5972044ae09">Eigen::operator+</a></div><div class="ttdeci">EIGEN_STRONG_INLINE const CwiseBinaryOp&lt; internal::scalar_sum_op&lt; typename DenseDerived::Scalar, typename SparseDerived::Scalar &gt;, const DenseDerived, const SparseDerived &gt; operator+(const MatrixBase&lt; DenseDerived &gt; &amp;a, const SparseMatrixBase&lt; SparseDerived &gt; &amp;b)</div><div class="ttdef"><b>定义</b> SparseCwiseBinaryOp.h:698</div></div>
</div><!-- fragment --><p>Here of course, <em class="arg">Derived</em> and <em class="arg">OtherDerived</em> are VectorXf.</p>
<p>As we said, <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> is also used for other operations such as substration, so it takes another template parameter determining the operation that will be applied to coefficients. This template parameter is a functor, that is, a class in which we have an operator() so it behaves like a function. Here, the functor used is <a class="el" href="struct_eigen_1_1internal_1_1scalar__sum__op.html">internal::scalar_sum_op</a>. It is defined in src/Core/Functors.h.</p>
<p>Let us now explain the <a class="el" href="struct_eigen_1_1internal_1_1traits.html">internal::traits</a> here. The <a class="el" href="struct_eigen_1_1internal_1_1scalar__sum__op.html">internal::scalar_sum_op</a> class takes one template parameter: the type of the numbers to handle. Here of course we want to pass the scalar type (a.k.a. numeric type) of VectorXf, which is <code>float</code>. How do we determine which is the scalar type of <em class="arg">Derived</em> ? Throughout <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>, all matrix and expression types define a typedef <em class="arg"><a class="el" href="class_eigen_1_1_product.html">Scalar</a></em> which gives its scalar type. For example, VectorXf::Scalar is a typedef for <code>float</code>. So here, if life was easy, we could find the numeric type of <em class="arg">Derived</em> as just </p><div class="fragment"><div class="line"><span class="keyword">typename</span> Derived::Scalar</div>
</div><!-- fragment --><p> Unfortunately, we can't do that here, as the compiler would complain that the type Derived hasn't yet been defined. So we use a workaround: in <a class="el" href="_forward_declarations_8h.html">src/Core/util/ForwardDeclarations.h</a>, we declared (not defined!) all our subclasses, like <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a>, and we also declared the following class template: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>internal::traits;</div>
</div><!-- fragment --><p> In <a class="el" href="eigen-3_83_87_2_eigen_2src_2_core_2_matrix_8h.html">src/Core/Matrix.h</a>, right <em>before</em> the definition of class <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a>, we define a partial specialization of <a class="el" href="struct_eigen_1_1internal_1_1traits.html">internal::traits</a> for T=<a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a>&lt;any template parameters&gt;. In this specialization of <a class="el" href="struct_eigen_1_1internal_1_1traits.html">internal::traits</a>, we define the <a class="el" href="class_eigen_1_1_product.html">Scalar</a> typedef. So when we actually define <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a>, it is legal to refer to "typename internal::traits\&lt;Matrix\&gt;::Scalar".</p>
<p>Anyway, we have declared our operator+. In our case, where <em class="arg">Derived</em> and <em class="arg">OtherDerived</em> are VectorXf, the above declaration amounts to: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MatrixBase&lt;VectorXf&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> CwiseBinaryOp&lt;internal::scalar_sum_op&lt;float&gt;, VectorXf, VectorXf&gt;</div>
<div class="line">  <a class="code hl_function" href="namespace_eigen.html#a054138fa4cd47163a7d8d5972044ae09">operator+</a>(<span class="keyword">const</span> <a class="code hl_function" href="class_eigen_1_1_matrix_base.html#a18b1d6bb45230c35c2f5dfa7c76c43d4">MatrixBase&lt;VectorXf&gt;</a> &amp;other) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Let's now jump to <a class="el" href="_cwise_binary_op_8h.html">src/Core/CwiseBinaryOp.h</a> to see how it is defined. As you can see there, all it does is to return a <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> object, and this object is just storing references to the left-hand-side and right-hand-side expressions &ndash; here, these are the vectors <em class="arg">v</em> and <em class="arg">w</em>. Well, the <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> object is also storing an instance of the (empty) functor class, but you shouldn't worry about it as that is a minor implementation detail.</p>
<p>Thus, the operator+ hasn't performed any actual computation. To summarize, the operation <em class="arg">v</em> + <em class="arg">w</em> just returned an object of type <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> which did nothing else than just storing references to <em class="arg">v</em> and <em class="arg">w</em>.</p>
<h1><a class="anchor" id="Assignment"></a>
The assignment</h1>
<p>At this point, the expression <em class="arg">v</em> + <em class="arg">w</em> has finished evaluating, so, in the process of compiling the line of code </p><div class="fragment"><div class="line"><a class="code hl_variable" href="external_2taskflow_23rd-party_2tbb_2examples_2parallel__for_2seismic_2main_8cpp.html#a2a671aca47b8db55cef1dd7174adad6f">u</a> = <a class="code hl_variable" href="_cwise__arg_8cpp.html#a49bb5a0db288a22a099643d44c5abbd6">v</a> + <a class="code hl_variable" href="_matrix__resize__int_8cpp.html#aab236ce080522c9832217fd5f157541b">w</a>;</div>
</div><!-- fragment --><p> we now enter the operator=.</p>
<p>What operator= is being called here? The vector u is an object of class VectorXf, i.e. <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a>. In <a class="el" href="eigen-3_83_87_2_eigen_2src_2_core_2_matrix_8h.html">src/Core/Matrix.h</a>, inside the definition of class <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a>, we see this: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OtherDerived&gt;</div>
<div class="line"><span class="keyword">inline</span> <a class="code hl_struct" href="class_matrix.html">Matrix</a>&amp; operator=(<span class="keyword">const</span> MatrixBase&lt;OtherDerived&gt;&amp; other)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="eigen-3_83_87_2_eigen_2src_2_core_2util_2_macros_8h.html#acaa7ba89800cfe18d5fd6eed620aea9c">eigen_assert</a>(m_storage.data()!=0 &amp;&amp; <span class="stringliteral">&quot;you cannot use operator= with a non initialized matrix (instead use set()&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_function" href="class_base.html#ad6a2e374145155a6a5f597ed603172ce">Base::operator=</a>(other.derived());</div>
<div class="line">}</div>
<div class="ttc" id="aclass_base_html_ad6a2e374145155a6a5f597ed603172ce"><div class="ttname"><a href="class_base.html#ad6a2e374145155a6a5f597ed603172ce">Base::operator=</a></div><div class="ttdeci">void operator=(const Base &amp;)</div></div>
<div class="ttc" id="aeigen-3_83_87_2_eigen_2src_2_core_2util_2_macros_8h_html_acaa7ba89800cfe18d5fd6eed620aea9c"><div class="ttname"><a href="eigen-3_83_87_2_eigen_2src_2_core_2util_2_macros_8h.html#acaa7ba89800cfe18d5fd6eed620aea9c">eigen_assert</a></div><div class="ttdeci">#define eigen_assert(x)</div><div class="ttdef"><b>定义</b> Macros.h:579</div></div>
</div><!-- fragment --><p> Here, <a class="el" href="class_base.html">Base</a> is a typedef for <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a>&lt;<a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors">Matrix</a>&gt;. So, what is being called is the operator= of <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a>. Let's see its prototype in <a class="el" href="_matrix_base_8h.html">src/Core/MatrixBase.h</a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OtherDerived&gt;</div>
<div class="line">Derived&amp; operator=(<span class="keyword">const</span> MatrixBase&lt;OtherDerived&gt;&amp; other);</div>
</div><!-- fragment --><p> Here, <em class="arg">Derived</em> is VectorXf (since u is a VectorXf) and <em class="arg">OtherDerived</em> is <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a>. More specifically, as explained in the previous section, <em class="arg">OtherDerived</em> is: </p><div class="fragment"><div class="line">CwiseBinaryOp&lt;internal::scalar_sum_op&lt;float&gt;, VectorXf, VectorXf&gt;</div>
</div><!-- fragment --><p> So the full prototype of the operator= being called is: </p><div class="fragment"><div class="line">VectorXf&amp; <a class="code hl_function" href="class_eigen_1_1_matrix_base.html#a706a4dd1ee54786e9210de1a4bf02600">MatrixBase&lt;VectorXf&gt;::operator=</a>(<span class="keyword">const</span> MatrixBase&lt;CwiseBinaryOp&lt;internal::scalar_sum_op&lt;float&gt;, VectorXf, VectorXf&gt; &gt; &amp; other);</div>
<div class="ttc" id="aclass_eigen_1_1_matrix_base_html_a706a4dd1ee54786e9210de1a4bf02600"><div class="ttname"><a href="class_eigen_1_1_matrix_base.html#a706a4dd1ee54786e9210de1a4bf02600">Eigen::MatrixBase::operator=</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &amp; operator=(const MatrixBase &amp;other)</div><div class="ttdef"><b>定义</b> Assign.h:55</div></div>
</div><!-- fragment --><p> This operator= literally reads "copying a sum of two VectorXf's into another VectorXf".</p>
<p>Let's now look at the implementation of this operator=. It resides in the file <a class="el" href="_assign_8h.html">src/Core/Assign.h</a>.</p>
<p>What we can see there is: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OtherDerived&gt;</div>
<div class="line"><span class="keyword">inline</span> Derived&amp; MatrixBase&lt;Derived&gt;</div>
<div class="line">  ::operator=(<span class="keyword">const</span> MatrixBase&lt;OtherDerived&gt;&amp; other)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> internal::assign_selector&lt;Derived,OtherDerived&gt;::run(derived(), other.derived());</div>
<div class="line">}</div>
</div><!-- fragment --><p>OK so our next task is to understand internal::assign_selector :)</p>
<p>Here is its declaration (all that is still in the same file <a class="el" href="_assign_8h.html">src/Core/Assign.h</a>) </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> OtherDerived,</div>
<div class="line">         <span class="keywordtype">bool</span> EvalBeforeAssigning = <a class="code hl_define" href="sugar_8h.html#ae4f82344f573c70aa1066a2394bba345">int</a>(OtherDerived::Flags) &amp; <a class="code hl_variable" href="group__flags.html#ga0972b20dc004d13984e642b3bd12532e">EvalBeforeAssigningBit</a>,</div>
<div class="line">         <span class="keywordtype">bool</span> NeedToTranspose = Derived::IsVectorAtCompileTime</div>
<div class="line">                &amp;&amp; OtherDerived::IsVectorAtCompileTime</div>
<div class="line">                &amp;&amp; <a class="code hl_define" href="sugar_8h.html#ae4f82344f573c70aa1066a2394bba345">int</a>(Derived::RowsAtCompileTime) == <a class="code hl_define" href="sugar_8h.html#ae4f82344f573c70aa1066a2394bba345">int</a>(OtherDerived::ColsAtCompileTime)</div>
<div class="line">                &amp;&amp; <a class="code hl_define" href="sugar_8h.html#ae4f82344f573c70aa1066a2394bba345">int</a>(Derived::ColsAtCompileTime) == <a class="code hl_define" href="sugar_8h.html#ae4f82344f573c70aa1066a2394bba345">int</a>(OtherDerived::RowsAtCompileTime)</div>
<div class="line">                &amp;&amp; <a class="code hl_define" href="sugar_8h.html#ae4f82344f573c70aa1066a2394bba345">int</a>(Derived::SizeAtCompileTime) != 1&gt;</div>
<div class="line"><span class="keyword">struct </span>internal::assign_selector;</div>
<div class="ttc" id="agroup__flags_html_ga0972b20dc004d13984e642b3bd12532e"><div class="ttname"><a href="group__flags.html#ga0972b20dc004d13984e642b3bd12532e">Eigen::EvalBeforeAssigningBit</a></div><div class="ttdeci">EIGEN_DEPRECATED const unsigned int EvalBeforeAssigningBit</div><div class="ttdef"><b>定义</b> Constants.h:71</div></div>
<div class="ttc" id="asugar_8h_html_ae4f82344f573c70aa1066a2394bba345"><div class="ttname"><a href="sugar_8h.html#ae4f82344f573c70aa1066a2394bba345">int</a></div><div class="ttdeci">#define int</div><div class="ttdef"><b>定义</b> sugar.h:37</div></div>
</div><!-- fragment --><p>So internal::assign_selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.</p>
<p>EvalBeforeAssigning is here to enforce the EvalBeforeAssigningBit. As explained <a href="TopicLazyEvaluation.html">here</a>, certain expressions have this flag which makes them automatically evaluate into temporaries before assigning them to another expression. This is the case of the <a class="el" href="class_eigen_1_1_product.html" title="Expression of the product of two arbitrary matrices or vectors">Product</a> expression, in order to avoid strange aliasing effects when doing "m = m * m;" However, of course here our <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> expression doesn't have the EvalBeforeAssigningBit: we said since the beginning that we didn't want a temporary to be introduced here. So if you go to <a class="el" href="_cwise_binary_op_8h.html">src/Core/CwiseBinaryOp.h</a>, you'll see that the Flags in <a class="el" href="struct_eigen_1_1internal_1_1traits.html">internal::traits</a>&lt;<a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a>&gt; don't include the EvalBeforeAssigningBit. The Flags member of <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> is then imported from the <a class="el" href="struct_eigen_1_1internal_1_1traits.html">internal::traits</a> by the EIGEN_GENERIC_PUBLIC_INTERFACE macro. Anyway, here the template parameter EvalBeforeAssigning has the value <code>false</code>.</p>
<p>NeedToTranspose is here for the case where the user wants to copy a row-vector into a column-vector. We allow this as a special exception to the general rule that in assignments we require the dimesions to match. Anyway, here both the left-hand and right-hand sides are column vectors, in the sense that ColsAtCompileTime is equal to 1. So NeedToTranspose is <code>false</code> too.</p>
<p>So, here we are in the partial specialization: </p><div class="fragment"><div class="line">internal::assign_selector&lt;Derived, OtherDerived, false, false&gt;</div>
</div><!-- fragment --><p>Here's how it is defined: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> OtherDerived&gt;</div>
<div class="line"><span class="keyword">struct </span>internal::assign_selector&lt;Derived,OtherDerived,<a class="code hl_define" href="yyjson_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>,<a class="code hl_define" href="yyjson_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>&gt; {</div>
<div class="line">  <span class="keyword">static</span> Derived&amp; <a class="code hl_function" href="poisson_8cpp.html#ae12af222b820baf64e953be588c5bbbe">run</a>(Derived&amp; <a class="code hl_variable" href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a>, <span class="keyword">const</span> OtherDerived&amp; other) { <span class="keywordflow">return</span> <a class="code hl_variable" href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a>.lazyAssign(other.derived()); }</div>
<div class="line">};</div>
<div class="ttc" id="apoisson_8cpp_html_ae12af222b820baf64e953be588c5bbbe"><div class="ttname"><a href="poisson_8cpp.html#ae12af222b820baf64e953be588c5bbbe">run</a></div><div class="ttdeci">double run(struct user_parameters *params, unsigned num_threads, std::string model)</div><div class="ttdef"><b>定义</b> poisson.cpp:63</div></div>
<div class="ttc" id="ashortpath_8cpp_html_a720827d53e80d32b23f708768099d331"><div class="ttname"><a href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a></div><div class="ttdeci">size_t dst</div><div class="ttdef"><b>定义</b> shortpath.cpp:82</div></div>
<div class="ttc" id="ayyjson_8h_html_a65e9886d74aaee76545e83dd09011727"><div class="ttname"><a href="yyjson_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></div><div class="ttdeci">#define false</div><div class="ttdef"><b>定义</b> yyjson.h:463</div></div>
</div><!-- fragment --><p>OK so now our next job is to understand how lazyAssign works :)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OtherDerived&gt;</div>
<div class="line"><span class="keyword">inline</span> Derived&amp; MatrixBase&lt;Derived&gt;</div>
<div class="line">  ::lazyAssign(<span class="keyword">const</span> MatrixBase&lt;OtherDerived&gt;&amp; other)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="external_2taskflow_23rd-party_2eigen-3_83_87_2_eigen_2src_2_core_2util_2_static_assert_8h.html#ab247f0d0f9226fe72bb02adefde6361d">EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE</a>(Derived,OtherDerived)</div>
<div class="line">  <a class="code hl_define" href="eigen-3_83_87_2_eigen_2src_2_core_2util_2_macros_8h.html#acaa7ba89800cfe18d5fd6eed620aea9c">eigen_assert</a>(<a class="code hl_variable" href="_tutorial__commainit__02_8cpp.html#a061459acc9e078fa4699e0e349887215">rows</a>() == other.rows() &amp;&amp; <a class="code hl_variable" href="_tutorial__commainit__02_8cpp.html#a4407a60bc4387adae24cee658711f2d9">cols</a>() == other.cols());</div>
<div class="line">  internal::assign_impl&lt;Derived, OtherDerived&gt;::run(derived(),other.derived());</div>
<div class="line">  <span class="keywordflow">return</span> derived();</div>
<div class="line">}</div>
<div class="ttc" id="a_tutorial__commainit__02_8cpp_html_a4407a60bc4387adae24cee658711f2d9"><div class="ttname"><a href="_tutorial__commainit__02_8cpp.html#a4407a60bc4387adae24cee658711f2d9">cols</a></div><div class="ttdeci">int cols</div><div class="ttdef"><b>定义</b> Tutorial_commainit_02.cpp:1</div></div>
<div class="ttc" id="aexternal_2taskflow_23rd-party_2eigen-3_83_87_2_eigen_2src_2_core_2util_2_static_assert_8h_html_ab247f0d0f9226fe72bb02adefde6361d"><div class="ttname"><a href="external_2taskflow_23rd-party_2eigen-3_83_87_2_eigen_2src_2_core_2util_2_static_assert_8h.html#ab247f0d0f9226fe72bb02adefde6361d">EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE</a></div><div class="ttdeci">#define EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(TYPE0, TYPE1)</div><div class="ttdef"><b>定义</b> StaticAssert.h:189</div></div>
</div><!-- fragment --><p>What do we see here? Some assertions, and then the only interesting line is: </p><div class="fragment"><div class="line">internal::assign_impl&lt;Derived, OtherDerived&gt;::run(derived(),other.derived());</div>
</div><!-- fragment --><p>OK so now we want to know what is inside internal::assign_impl.</p>
<p>Here is its declaration: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived1, <span class="keyword">typename</span> Derived2,</div>
<div class="line">         <span class="keywordtype">int</span> Vectorization = internal::assign_traits&lt;Derived1, Derived2&gt;::Vectorization,</div>
<div class="line">         <span class="keywordtype">int</span> Unrolling = internal::assign_traits&lt;Derived1, Derived2&gt;::Unrolling&gt;</div>
<div class="line"><span class="keyword">struct </span>internal::assign_impl;</div>
</div><!-- fragment --><p> Again, internal::assign_selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.</p>
<p>These two parameters <em class="arg">Vectorization</em> and <em class="arg">Unrolling</em> are determined by a helper class internal::assign_traits. Its job is to determine which vectorization strategy to use (that is <em class="arg">Vectorization</em>) and which unrolling strategy to use (that is <em class="arg">Unrolling</em>).</p>
<p>We'll not enter into the details of how these strategies are chosen (this is in the implementation of internal::assign_traits at the top of the same file). Let's just say that here <em class="arg">Vectorization</em> has the value <em class="arg">LinearVectorization</em>, and <em class="arg">Unrolling</em> has the value <em class="arg">NoUnrolling</em> (the latter is obvious since our vectors have dynamic size so there's no way to unroll the loop at compile-time).</p>
<p>So the partial specialization of internal::assign_impl that we're looking at is: </p><div class="fragment"><div class="line">internal::assign_impl&lt;Derived1, Derived2, LinearVectorization, NoUnrolling&gt;</div>
</div><!-- fragment --><p>Here is how it's defined: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived1, <span class="keyword">typename</span> Derived2&gt;</div>
<div class="line"><span class="keyword">struct </span>internal::assign_impl&lt;Derived1, Derived2, LinearVectorization, <a class="code hl_enumvalue" href="namespace_eigen.html#ab8c7299b77156ae8c7827ba61787669daffa0319c4814dc2e37edb1432c2eafbc">NoUnrolling</a>&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code hl_function" href="poisson_8cpp.html#ae12af222b820baf64e953be588c5bbbe">run</a>(Derived1 &amp;<a class="code hl_variable" href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a>, <span class="keyword">const</span> Derived2 &amp;<a class="code hl_variable" href="shortpath_8cpp.html#a8648ffe7342bea77e2698690589da3c1">src</a>)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a> = <a class="code hl_variable" href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a>.size();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> packetSize = internal::packet_traits&lt;typename Derived1::Scalar&gt;::size;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> alignedStart = internal::assign_traits&lt;Derived1,Derived2&gt;::DstIsAligned ? 0</div>
<div class="line">                           : internal::first_aligned(&amp;<a class="code hl_variable" href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a>.coeffRef(0), <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> alignedEnd = alignedStart + ((<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>-alignedStart)/packetSize)*packetSize;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> = 0; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> &lt; alignedStart; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>++)</div>
<div class="line">      <a class="code hl_variable" href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a>.copyCoeff(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>, <a class="code hl_variable" href="shortpath_8cpp.html#a8648ffe7342bea77e2698690589da3c1">src</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> = alignedStart; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> &lt; alignedEnd; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> += packetSize)</div>
<div class="line">    {</div>
<div class="line">      <a class="code hl_variable" href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a>.template copyPacket&lt;Derived2, Aligned, internal::assign_traits&lt;Derived1,Derived2&gt;::SrcAlignment&gt;(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>, <a class="code hl_variable" href="shortpath_8cpp.html#a8648ffe7342bea77e2698690589da3c1">src</a>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> = alignedEnd; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> &lt; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>++)</div>
<div class="line">      <a class="code hl_variable" href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a>.copyCoeff(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>, <a class="code hl_variable" href="shortpath_8cpp.html#a8648ffe7342bea77e2698690589da3c1">src</a>);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_ab47dd9958bcadea08866b42bf358e95e"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a></div><div class="ttdeci">GLuint index</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:366</div></div>
<div class="ttc" id="anamespace_eigen_html_ab8c7299b77156ae8c7827ba61787669daffa0319c4814dc2e37edb1432c2eafbc"><div class="ttname"><a href="namespace_eigen.html#ab8c7299b77156ae8c7827ba61787669daffa0319c4814dc2e37edb1432c2eafbc">Eigen::NoUnrolling</a></div><div class="ttdeci">@ NoUnrolling</div><div class="ttdef"><b>定义</b> Constants.h:300</div></div>
<div class="ttc" id="ashortpath_8cpp_html_a8648ffe7342bea77e2698690589da3c1"><div class="ttname"><a href="shortpath_8cpp.html#a8648ffe7342bea77e2698690589da3c1">src</a></div><div class="ttdeci">size_t src</div><div class="ttdef"><b>定义</b> shortpath.cpp:81</div></div>
</div><!-- fragment --><p>Here's how it works. <em class="arg">LinearVectorization</em> means that the left-hand and right-hand side expression can be accessed linearly i.e. you can refer to their coefficients by one integer <em class="arg">index</em>, as opposed to having to refer to its coefficients by two integers <em class="arg">row</em>, <em class="arg">column</em>.</p>
<p>As we said at the beginning, vectorization works with blocks of 4 floats. Here, <em class="arg">PacketSize</em> is 4.</p>
<p>There are two potential problems that we need to deal with: </p><ul>
<li>first, vectorization works much better if the packets are 128-bit-aligned. This is especially important for write access. So when writing to the coefficients of <em class="arg">dst</em>, we want to group these coefficients by packets of 4 such that each of these packets is 128-bit-aligned. In general, this requires to skip a few coefficients at the beginning of <em class="arg">dst</em>. This is the purpose of <em class="arg">alignedStart</em>. We then copy these first few coefficients one by one, not by packets. However, in our case, the <em class="arg">dst</em> expression is a VectorXf and remember that in the construction of the vectors we allocated aligned arrays. Thanks to <em class="arg">DstIsAligned</em>, <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> remembers that without having to do any runtime check, so <em class="arg">alignedStart</em> is zero and this part is avoided altogether. </li>
<li>second, the number of coefficients to copy is not in general a multiple of <em class="arg">packetSize</em>. Here, there are 50 coefficients to copy and <em class="arg">packetSize</em> is 4. So we'll have to copy the last 2 coefficients one by one, not by packets. Here, <em class="arg">alignedEnd</em> is 48.</li>
</ul>
<p>Now come the actual loops.</p>
<p>First, the vectorized part: the 48 first coefficients out of 50 will be copied by packets of 4: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> = alignedStart; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> &lt; alignedEnd; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> += packetSize)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_variable" href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a>.template copyPacket&lt;Derived2, Aligned, internal::assign_traits&lt;Derived1,Derived2&gt;::SrcAlignment&gt;(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>, <a class="code hl_variable" href="shortpath_8cpp.html#a8648ffe7342bea77e2698690589da3c1">src</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>What is copyPacket? It is defined in src/Core/Coeffs.h: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Derived&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OtherDerived, <span class="keywordtype">int</span> StoreMode, <span class="keywordtype">int</span> LoadMode&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> MatrixBase&lt;Derived&gt;::copyPacket(<span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>, <span class="keyword">const</span> MatrixBase&lt;OtherDerived&gt;&amp; other)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_define" href="eigen-3_83_87_2_eigen_2src_2_core_2util_2_macros_8h.html#a4e742b5a08636a61784c0e173b61e710">eigen_internal_assert</a>(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> &gt;= 0 &amp;&amp; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> &lt; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>());</div>
<div class="line">  derived().template writePacket&lt;StoreMode&gt;(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>,</div>
<div class="line">    other.derived().template packet&lt;LoadMode&gt;(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>));</div>
<div class="line">}</div>
<div class="ttc" id="aeigen-3_83_87_2_eigen_2src_2_core_2util_2_macros_8h_html_a4e742b5a08636a61784c0e173b61e710"><div class="ttname"><a href="eigen-3_83_87_2_eigen_2src_2_core_2util_2_macros_8h.html#a4e742b5a08636a61784c0e173b61e710">eigen_internal_assert</a></div><div class="ttdeci">#define eigen_internal_assert(x)</div><div class="ttdef"><b>定义</b> Macros.h:585</div></div>
</div><!-- fragment --><p>OK, what are writePacket() and packet() here?</p>
<p>First, writePacket() here is a method on the left-hand side VectorXf. So we go to <a class="el" href="eigen-3_83_87_2_eigen_2src_2_core_2_matrix_8h.html">src/Core/Matrix.h</a> to look at its definition: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> StoreMode&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> writePacket(<span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>, <span class="keyword">const</span> PacketScalar&amp; <a class="code hl_variable" href="offscreen_8c.html#a5fd331c99e778f04762be6d8173eb4d2">x</a>)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_function" href="namespace_eigen_1_1internal.html#a8de0ba2d55374f1277e7266e1788b3db">internal::pstoret&lt;Scalar, PacketScalar, StoreMode&gt;</a>(m_storage.data() + <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>, <a class="code hl_variable" href="offscreen_8c.html#a5fd331c99e778f04762be6d8173eb4d2">x</a>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_eigen_1_1internal_html_a8de0ba2d55374f1277e7266e1788b3db"><div class="ttname"><a href="namespace_eigen_1_1internal.html#a8de0ba2d55374f1277e7266e1788b3db">Eigen::internal::pstoret</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void pstoret(Scalar *to, const Packet &amp;from)</div><div class="ttdef"><b>定义</b> GenericPacketMath.h:471</div></div>
<div class="ttc" id="aoffscreen_8c_html_a5fd331c99e778f04762be6d8173eb4d2"><div class="ttname"><a href="offscreen_8c.html#a5fd331c99e778f04762be6d8173eb4d2">x</a></div><div class="ttdeci">float x</div><div class="ttdef"><b>定义</b> offscreen.c:41</div></div>
</div><!-- fragment --><p> Here, <em class="arg">StoreMode</em> is <em class="arg"><a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ae12d0f8f869c40c76128260af2242bc8">Aligned</a></em>, indicating that we are doing a 128-bit-aligned write access, <em class="arg">PacketScalar</em> is a type representing a "SSE packet of 4 floats" and <a class="el" href="namespace_eigen_1_1internal.html#a8de0ba2d55374f1277e7266e1788b3db">internal::pstoret</a> is a function writing such a packet in memory. Their definitions are architecture-specific, we find them in <a class="el" href="_s_s_e_2_packet_math_8h.html">src/Core/arch/SSE/PacketMath.h</a>:</p>
<p>The line in <a class="el" href="_s_s_e_2_packet_math_8h.html">src/Core/arch/SSE/PacketMath.h</a> that determines the PacketScalar type (via a typedef in Matrix.h) is: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>internal::packet_traits&lt;<a class="code hl_define" href="sugar_8h.html#a0d954e435550ebcb2035013bfea2db85">float</a>&gt;  { <span class="keyword">typedef</span> __m128  <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ae8396ff85d63082521e3324820df1009">type</a>; <span class="keyword">enum</span> {<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>=4}; };</div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_ae8396ff85d63082521e3324820df1009"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#ae8396ff85d63082521e3324820df1009">type</a></div><div class="ttdeci">GLint GLint GLsizei GLsizei GLint GLenum GLenum type</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:190</div></div>
<div class="ttc" id="asugar_8h_html_a0d954e435550ebcb2035013bfea2db85"><div class="ttname"><a href="sugar_8h.html#a0d954e435550ebcb2035013bfea2db85">float</a></div><div class="ttdeci">#define float</div><div class="ttdef"><b>定义</b> sugar.h:39</div></div>
</div><!-- fragment --><p> Here, __m128 is a SSE-specific type. Notice that the enum <em class="arg">size</em> here is what was used to define <em class="arg">packetSize</em> above.</p>
<p>And here is the implementation of <a class="el" href="namespace_eigen_1_1internal.html#a8de0ba2d55374f1277e7266e1788b3db">internal::pstoret</a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="namespace_eigen_1_1internal.html#aaab57ef8d873301545ff0afbf2e28458">internal::pstore</a>(<span class="keywordtype">float</span>*  to, <span class="keyword">const</span> __m128&amp;  from) { _mm_store_ps(to, from); }</div>
<div class="ttc" id="anamespace_eigen_1_1internal_html_aaab57ef8d873301545ff0afbf2e28458"><div class="ttname"><a href="namespace_eigen_1_1internal.html#aaab57ef8d873301545ff0afbf2e28458">Eigen::internal::pstore</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC void pstore(Scalar *to, const Packet &amp;from)</div><div class="ttdef"><b>定义</b> GenericPacketMath.h:285</div></div>
</div><!-- fragment --><p> Here, __mm_store_ps is a SSE-specific intrinsic function, representing a single SSE instruction. The difference between <a class="el" href="namespace_eigen_1_1internal.html#aaab57ef8d873301545ff0afbf2e28458">internal::pstore</a> and <a class="el" href="namespace_eigen_1_1internal.html#a8de0ba2d55374f1277e7266e1788b3db">internal::pstoret</a> is that <a class="el" href="namespace_eigen_1_1internal.html#a8de0ba2d55374f1277e7266e1788b3db">internal::pstoret</a> is a dispatcher handling both the aligned and unaligned cases, you find its definition in <a class="el" href="_generic_packet_math_8h.html">src/Core/GenericPacketMath.h</a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar, <span class="keyword">typename</span> Packet, <span class="keywordtype">int</span> LoadMode&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code hl_function" href="namespace_eigen_1_1internal.html#a8de0ba2d55374f1277e7266e1788b3db">internal::pstoret</a>(<a class="code hl_typedef" href="bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a>* to, <span class="keyword">const</span> <a class="code hl_typedef" href="benchmark-blocking-sizes_8cpp.html#af8736f5639bd4077ed9602ad1a220156">Packet</a>&amp; from)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(LoadMode == <a class="code hl_enumvalue" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ae12d0f8f869c40c76128260af2242bc8">Aligned</a>)</div>
<div class="line">    <a class="code hl_function" href="namespace_eigen_1_1internal.html#aaab57ef8d873301545ff0afbf2e28458">internal::pstore</a>(to, from);</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <a class="code hl_function" href="namespace_eigen_1_1internal.html#abcb1c5d429335ed8c976a6b238287a2e">internal::pstoreu</a>(to, from);</div>
<div class="line">}</div>
<div class="ttc" id="abench__gemm_8cpp_html_a052eb942d12b6404aade6fae4b075fb9"><div class="ttname"><a href="bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a></div><div class="ttdeci">SCALAR Scalar</div><div class="ttdef"><b>定义</b> bench_gemm.cpp:33</div></div>
<div class="ttc" id="abenchmark-blocking-sizes_8cpp_html_af8736f5639bd4077ed9602ad1a220156"><div class="ttname"><a href="benchmark-blocking-sizes_8cpp.html#af8736f5639bd4077ed9602ad1a220156">Packet</a></div><div class="ttdeci">internal::packet_traits&lt; Scalar &gt;::type Packet</div><div class="ttdef"><b>定义</b> benchmark-blocking-sizes.cpp:54</div></div>
<div class="ttc" id="agroup__enums_html_gga45fe06e29902b7a2773de05ba27b47a1ae12d0f8f869c40c76128260af2242bc8"><div class="ttname"><a href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ae12d0f8f869c40c76128260af2242bc8">Eigen::Aligned</a></div><div class="ttdeci">@ Aligned</div><div class="ttdef"><b>定义</b> Constants.h:235</div></div>
<div class="ttc" id="anamespace_eigen_1_1internal_html_abcb1c5d429335ed8c976a6b238287a2e"><div class="ttname"><a href="namespace_eigen_1_1internal.html#abcb1c5d429335ed8c976a6b238287a2e">Eigen::internal::pstoreu</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC void pstoreu(Scalar *to, const Packet &amp;from)</div><div class="ttdef"><b>定义</b> GenericPacketMath.h:289</div></div>
</div><!-- fragment --><p>OK, that explains how writePacket() works. Now let's look into the packet() call. Remember that we are analyzing this line of code inside copyPacket(): </p><div class="fragment"><div class="line">derived().template writePacket&lt;StoreMode&gt;(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>,</div>
<div class="line">    other.derived().template packet&lt;LoadMode&gt;(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>));</div>
</div><!-- fragment --><p>Here, <em class="arg">other</em> is our sum expression <em class="arg">v</em> + <em class="arg">w</em>. The .derived() is just casting from <a class="el" href="class_eigen_1_1_matrix_base.html" title="Base class for all dense matrices, vectors, and expressions">MatrixBase</a> to the subclass which here is <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a>. So let's go to <a class="el" href="_cwise_binary_op_8h.html">src/Core/CwiseBinaryOp.h</a>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>CwiseBinaryOp</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> LoadMode&gt;</div>
<div class="line">    <span class="keyword">inline</span> PacketScalar packet(<span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code hl_variable" href="class_eigen_1_1_cwise_binary_op.html#a1bd1d4ffcfa797bb07b09b55e63bc9ab">m_functor</a>.packetOp(<a class="code hl_variable" href="class_eigen_1_1_cwise_binary_op.html#a29b57054a3644d62c101ee15815ebe1c">m_lhs</a>.template packet&lt;LoadMode&gt;(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>), <a class="code hl_variable" href="class_eigen_1_1_cwise_binary_op.html#a42af8f795a8f4062d9e57c0136277be3">m_rhs</a>.template packet&lt;LoadMode&gt;(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclass_eigen_1_1_cwise_binary_op_html_a1bd1d4ffcfa797bb07b09b55e63bc9ab"><div class="ttname"><a href="class_eigen_1_1_cwise_binary_op.html#a1bd1d4ffcfa797bb07b09b55e63bc9ab">Eigen::CwiseBinaryOp::m_functor</a></div><div class="ttdeci">const BinaryOp m_functor</div><div class="ttdef"><b>定义</b> CwiseBinaryOp.h:143</div></div>
<div class="ttc" id="aclass_eigen_1_1_cwise_binary_op_html_a29b57054a3644d62c101ee15815ebe1c"><div class="ttname"><a href="class_eigen_1_1_cwise_binary_op.html#a29b57054a3644d62c101ee15815ebe1c">Eigen::CwiseBinaryOp::m_lhs</a></div><div class="ttdeci">LhsNested m_lhs</div><div class="ttdef"><b>定义</b> CwiseBinaryOp.h:141</div></div>
<div class="ttc" id="aclass_eigen_1_1_cwise_binary_op_html_a42af8f795a8f4062d9e57c0136277be3"><div class="ttname"><a href="class_eigen_1_1_cwise_binary_op.html#a42af8f795a8f4062d9e57c0136277be3">Eigen::CwiseBinaryOp::m_rhs</a></div><div class="ttdeci">RhsNested m_rhs</div><div class="ttdef"><b>定义</b> CwiseBinaryOp.h:142</div></div>
</div><!-- fragment --><p> Here, <em class="arg">m_lhs</em> is the vector <em class="arg">v</em>, and <em class="arg">m_rhs</em> is the vector <em class="arg">w</em>. So the packet() function here is <a class="el" href="class_eigen_1_1_plain_object_base.html#a85d505b93c18f4f558e9b80702e8e5af">Matrix::packet()</a>. The template parameter <em class="arg">LoadMode</em> is <em class="arg"><a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ae12d0f8f869c40c76128260af2242bc8">Aligned</a></em>. So we're looking at </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_struct" href="class_matrix.html">Matrix</a></div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> LoadMode&gt;</div>
<div class="line">    <span class="keyword">inline</span> <a class="code hl_typedef" href="class_eigen_1_1_plain_object_base.html#a2ebcc910069dac4c4562e28db3893250">PacketScalar</a> <a class="code hl_function" href="class_eigen_1_1_plain_object_base.html#a85d505b93c18f4f558e9b80702e8e5af">packet</a>(<span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">      <span class="keywordflow">return</span> <a class="code hl_function" href="namespace_eigen_1_1internal.html#ac12becb16e24b41520ac853b2b5bf2cb">internal::ploadt&lt;Scalar, LoadMode&gt;</a>(<a class="code hl_variable" href="class_eigen_1_1_matrix.html#a316629f8d52b858d0c06f5b0f563fc05">m_storage</a>.<a class="code hl_function" href="class_eigen_1_1_dense_storage.html#abdbbeb487a245756ac498d2590e3560a">data</a>() + <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclass_eigen_1_1_dense_storage_html_abdbbeb487a245756ac498d2590e3560a"><div class="ttname"><a href="class_eigen_1_1_dense_storage.html#abdbbeb487a245756ac498d2590e3560a">Eigen::DenseStorage::data</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC const T * data() const</div><div class="ttdef"><b>定义</b> DenseStorage.h:215</div></div>
<div class="ttc" id="aclass_eigen_1_1_matrix_html_a316629f8d52b858d0c06f5b0f563fc05"><div class="ttname"><a href="class_eigen_1_1_matrix.html#a316629f8d52b858d0c06f5b0f563fc05">Eigen::Matrix::m_storage</a></div><div class="ttdeci">DenseStorage&lt; Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options &gt; m_storage</div><div class="ttdef"><b>定义</b> PlainObjectBase.h:139</div></div>
<div class="ttc" id="aclass_eigen_1_1_plain_object_base_html_a2ebcc910069dac4c4562e28db3893250"><div class="ttname"><a href="class_eigen_1_1_plain_object_base.html#a2ebcc910069dac4c4562e28db3893250">Eigen::PlainObjectBase&lt; Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt;::PacketScalar</a></div><div class="ttdeci">internal::packet_traits&lt; Scalar &gt;::type PacketScalar</div><div class="ttdef"><b>定义</b> PlainObjectBase.h:108</div></div>
<div class="ttc" id="aclass_eigen_1_1_plain_object_base_html_a85d505b93c18f4f558e9b80702e8e5af"><div class="ttname"><a href="class_eigen_1_1_plain_object_base.html#a85d505b93c18f4f558e9b80702e8e5af">Eigen::PlainObjectBase&lt; Matrix&lt; _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols &gt; &gt;::packet</a></div><div class="ttdeci">EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const</div><div class="ttdef"><b>定义</b> PlainObjectBase.h:222</div></div>
<div class="ttc" id="anamespace_eigen_1_1internal_html_ac12becb16e24b41520ac853b2b5bf2cb"><div class="ttname"><a href="namespace_eigen_1_1internal.html#ac12becb16e24b41520ac853b2b5bf2cb">Eigen::internal::ploadt</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet ploadt(const typename unpacket_traits&lt; Packet &gt;::type *from)</div><div class="ttdef"><b>定义</b> GenericPacketMath.h:460</div></div>
</div><!-- fragment --><p> We let you look up the definition of <a class="el" href="namespace_eigen_1_1internal.html#ac12becb16e24b41520ac853b2b5bf2cb">internal::ploadt</a> in <a class="el" href="_generic_packet_math_8h.html">GenericPacketMath.h</a> and the <a class="el" href="namespace_eigen_1_1internal.html#ae25c18feab0271a245176a7a3f2dcd3d">internal::pload</a> in <a class="el" href="_s_s_e_2_packet_math_8h.html">src/Core/arch/SSE/PacketMath.h</a>. It is very similar to the above for <a class="el" href="namespace_eigen_1_1internal.html#aaab57ef8d873301545ff0afbf2e28458">internal::pstore</a>.</p>
<p>Let's go back to CwiseBinaryOp::packet(). Once the packets from the vectors <em class="arg">v</em> and <em class="arg">w</em> have been returned, what does this function do? It calls m_functor.packetOp() on them. What is m_functor? Here we must remember what particular template specialization of <a class="el" href="class_eigen_1_1_cwise_binary_op.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions">CwiseBinaryOp</a> we're dealing with: </p><div class="fragment"><div class="line">CwiseBinaryOp&lt;internal::scalar_sum_op&lt;float&gt;, VectorXf, VectorXf&gt;</div>
</div><!-- fragment --><p> So m_functor is an object of the empty class <a class="el" href="struct_eigen_1_1internal_1_1scalar__sum__op.html">internal::scalar_sum_op&lt;float&gt;</a>. As we mentioned above, don't worry about why we constructed an object of this empty class at all &ndash; it's an implementation detail, the point is that some other functors need to store member data.</p>
<p>Anyway, <a class="el" href="struct_eigen_1_1internal_1_1scalar__sum__op.html">internal::scalar_sum_op</a> is defined in src/Core/Functors.h: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Scalar&gt; <span class="keyword">struct </span>internal::scalar_sum_op EIGEN_EMPTY_STRUCT {</div>
<div class="line">  <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code hl_typedef" href="bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a> <a class="code hl_function" href="struct_eigen_1_1internal_1_1scalar__sum__op.html#a0692f46a25ed4792cba03d241604001f">operator() </a>(<span class="keyword">const</span> <a class="code hl_typedef" href="bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a>&amp; <a class="code hl_variable" href="_cwise__product_8cpp.html#ad2cbe4616e813eb9af81732dca777b24">a</a>, <span class="keyword">const</span> <a class="code hl_typedef" href="bench__gemm_8cpp.html#a052eb942d12b6404aade6fae4b075fb9">Scalar</a>&amp; <a class="code hl_variable" href="offscreen_8c.html#a846c9667e34d56c560bb7f0ac6e173f6">b</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="_cwise__product_8cpp.html#ad2cbe4616e813eb9af81732dca777b24">a</a> + <a class="code hl_variable" href="offscreen_8c.html#a846c9667e34d56c560bb7f0ac6e173f6">b</a>; }</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> PacketScalar&gt;</div>
<div class="line">  <span class="keyword">inline</span> <span class="keyword">const</span> PacketScalar <a class="code hl_function" href="struct_eigen_1_1internal_1_1scalar__sum__op.html#ad1ce5f84741cd8f019b05ab556f87488">packetOp</a>(<span class="keyword">const</span> PacketScalar&amp; <a class="code hl_variable" href="_cwise__product_8cpp.html#ad2cbe4616e813eb9af81732dca777b24">a</a>, <span class="keyword">const</span> PacketScalar&amp; <a class="code hl_variable" href="offscreen_8c.html#a846c9667e34d56c560bb7f0ac6e173f6">b</a>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code hl_function" href="namespace_eigen_1_1internal.html#a0f50f3baa0dcc73cd1c0baa06e5c8c13">internal::padd</a>(<a class="code hl_variable" href="_cwise__product_8cpp.html#ad2cbe4616e813eb9af81732dca777b24">a</a>,<a class="code hl_variable" href="offscreen_8c.html#a846c9667e34d56c560bb7f0ac6e173f6">b</a>); }</div>
<div class="line">};</div>
<div class="ttc" id="a_cwise__product_8cpp_html_ad2cbe4616e813eb9af81732dca777b24"><div class="ttname"><a href="_cwise__product_8cpp.html#ad2cbe4616e813eb9af81732dca777b24">a</a></div><div class="ttdeci">Array33i a</div><div class="ttdef"><b>定义</b> Cwise_product.cpp:1</div></div>
<div class="ttc" id="anamespace_eigen_1_1internal_html_a0f50f3baa0dcc73cd1c0baa06e5c8c13"><div class="ttname"><a href="namespace_eigen_1_1internal.html#a0f50f3baa0dcc73cd1c0baa06e5c8c13">Eigen::internal::padd</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC Packet padd(const Packet &amp;a, const Packet &amp;b)</div><div class="ttdef"><b>定义</b> GenericPacketMath.h:151</div></div>
<div class="ttc" id="aoffscreen_8c_html_a846c9667e34d56c560bb7f0ac6e173f6"><div class="ttname"><a href="offscreen_8c.html#a846c9667e34d56c560bb7f0ac6e173f6">b</a></div><div class="ttdeci">float b</div><div class="ttdef"><b>定义</b> offscreen.c:42</div></div>
<div class="ttc" id="astruct_eigen_1_1internal_1_1scalar__sum__op_html_a0692f46a25ed4792cba03d241604001f"><div class="ttname"><a href="struct_eigen_1_1internal_1_1scalar__sum__op.html#a0692f46a25ed4792cba03d241604001f">Eigen::internal::scalar_sum_op::operator()</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator()(const LhsScalar &amp;a, const RhsScalar &amp;b) const</div><div class="ttdef"><b>定义</b> BinaryFunctors.h:42</div></div>
<div class="ttc" id="astruct_eigen_1_1internal_1_1scalar__sum__op_html_ad1ce5f84741cd8f019b05ab556f87488"><div class="ttname"><a href="struct_eigen_1_1internal_1_1scalar__sum__op.html#ad1ce5f84741cd8f019b05ab556f87488">Eigen::internal::scalar_sum_op::packetOp</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet &amp;a, const Packet &amp;b) const</div><div class="ttdef"><b>定义</b> BinaryFunctors.h:44</div></div>
</div><!-- fragment --><p> As you can see, all what packetOp() does is to call <a class="el" href="namespace_eigen_1_1internal.html#a0f50f3baa0dcc73cd1c0baa06e5c8c13">internal::padd</a> on the two packets. Here is the definition of <a class="el" href="namespace_eigen_1_1internal.html#a0f50f3baa0dcc73cd1c0baa06e5c8c13">internal::padd</a> from <a class="el" href="_s_s_e_2_packet_math_8h.html">src/Core/arch/SSE/PacketMath.h</a>: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> __m128  <a class="code hl_function" href="namespace_eigen_1_1internal.html#a0f50f3baa0dcc73cd1c0baa06e5c8c13">internal::padd</a>(<span class="keyword">const</span> __m128&amp;  <a class="code hl_variable" href="_cwise__product_8cpp.html#ad2cbe4616e813eb9af81732dca777b24">a</a>, <span class="keyword">const</span> __m128&amp;  <a class="code hl_variable" href="offscreen_8c.html#a846c9667e34d56c560bb7f0ac6e173f6">b</a>) { <span class="keywordflow">return</span> _mm_add_ps(<a class="code hl_variable" href="_cwise__product_8cpp.html#ad2cbe4616e813eb9af81732dca777b24">a</a>,<a class="code hl_variable" href="offscreen_8c.html#a846c9667e34d56c560bb7f0ac6e173f6">b</a>); }</div>
</div><!-- fragment --><p> Here, _mm_add_ps is a SSE-specific intrinsic function, representing a single SSE instruction.</p>
<p>To summarize, the loop </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> = alignedStart; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> &lt; alignedEnd; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> += packetSize)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_variable" href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a>.template copyPacket&lt;Derived2, Aligned, internal::assign_traits&lt;Derived1,Derived2&gt;::SrcAlignment&gt;(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>, <a class="code hl_variable" href="shortpath_8cpp.html#a8648ffe7342bea77e2698690589da3c1">src</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p> has been compiled to the following code: for <em class="arg">index</em> going from 0 to the 11 ( = 48/4 - 1), read the i-th packet (of 4 floats) from the vector v and the i-th packet from the vector w using two __mm_load_ps SSE instructions, then add them together using a __mm_add_ps instruction, then store the result using a __mm_store_ps instruction.</p>
<p>There remains the second loop handling the last few (here, the last 2) coefficients: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> = alignedEnd; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a> &lt; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size</a>; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>++)</div>
<div class="line">  <a class="code hl_variable" href="shortpath_8cpp.html#a720827d53e80d32b23f708768099d331">dst</a>.copyCoeff(<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#ab47dd9958bcadea08866b42bf358e95e">index</a>, <a class="code hl_variable" href="shortpath_8cpp.html#a8648ffe7342bea77e2698690589da3c1">src</a>);</div>
</div><!-- fragment --><p> However, it works just like the one we just explained, it is just simpler because there is no SSE vectorization involved here. copyPacket() becomes copyCoeff(), packet() becomes coeff(), writePacket() becomes coeffRef(). If you followed us this far, you can probably understand this part by yourself.</p>
<p>We see that all the C++ abstraction of <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> goes away during compilation and that we indeed are precisely controlling which assembly instructions we emit. Such is the beauty of C++! Since we have such precise control over the emitted assembly instructions, but such complex logic to choose the right instructions, we can say that <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> really behaves like an optimizing compiler. If you prefer, you could say that <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> behaves like a script for the compiler. In a sense, C++ template metaprogramming is scripting the compiler &ndash; and it's been shown that this scripting language is Turing-complete. See <a href="http://en.wikipedia.org/wiki/Template_metaprogramming">Wikipedia</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
