<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: &lt;tt&gt;rfl::NamedTuple&lt;/tt&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_external_2reflect-cpp_2docs_2named__tuple.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">&lt;tt&gt;rfl::NamedTuple&lt;/tt&gt;</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md606"></a></p>
<p><code><a class="el" href="classrfl_1_1_named_tuple.html">rfl::NamedTuple</a></code> is very similar to <code>std::tuple</code> or <code><a class="el" href="classrfl_1_1_tuple.html">rfl::Tuple</a></code>, but unlike these two structures, the fields have names.</p>
<p>In other words, consider the following struct:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::string first_name;</div>
<div class="line">    std::string last_name;</div>
<div class="line">    <a class="code hl_class" href="classrfl_1_1_timestamp.html">rfl::Timestamp</a>&lt;<span class="stringliteral">&quot;%Y-%m-%d&quot;</span>&gt; birthday;</div>
<div class="line">};</div>
<div class="ttc" id="aclassrfl_1_1_timestamp_html"><div class="ttname"><a href="classrfl_1_1_timestamp.html">rfl::Timestamp</a></div><div class="ttdoc">For serializing and deserializing time stamps.</div><div class="ttdef"><b>定义</b> Timestamp.hpp:17</div></div>
</div><!-- fragment --><p>You might as well define the following <code><a class="el" href="classrfl_1_1_named_tuple.html">rfl::NamedTuple</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>Person = <a class="code hl_class" href="classrfl_1_1_named_tuple.html">rfl::NamedTuple</a>&lt;</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;first_name&quot;</span>, std::string&gt;,</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;last_name&quot;</span>, std::string&gt;,</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;birthday&quot;</span>, <a class="code hl_class" href="classrfl_1_1_timestamp.html">rfl::Timestamp</a>&lt;<span class="stringliteral">&quot;%Y-%m-%d&quot;</span>&gt;&gt;&gt;;</div>
<div class="ttc" id="aclassrfl_1_1_named_tuple_html"><div class="ttname"><a href="classrfl_1_1_named_tuple.html">rfl::NamedTuple</a></div><div class="ttdef"><b>定义</b> NamedTuple.hpp:33</div></div>
<div class="ttc" id="astructrfl_1_1_field_html"><div class="ttname"><a href="structrfl_1_1_field.html">rfl::Field</a></div><div class="ttdoc">Used to define a field in the NamedTuple.</div><div class="ttdef"><b>定义</b> Field.hpp:21</div></div>
</div><!-- fragment --><p>From the point-of-view of serialization/deserialization, the two definitions are equivalent. The resulting JSON strings (or any other format) will be the same.</p>
<h1><a class="anchor" id="autotoc_md607"></a>
Structural typing</h1>
<p>From the point-of-view of programming, there is an important difference: Structs are <em>nominally typed</em> and named tuples are <em>structurally typed</em> (confusingly, structs are not structurally typed).</p>
<p>In plain language, that means that the compiler will regard this as absolutely equivalent to <code>Person</code>, the named tuple:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>Person2 = <a class="code hl_class" href="classrfl_1_1_named_tuple.html">rfl::NamedTuple</a>&lt;</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;first_name&quot;</span>, std::string&gt;,</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;last_name&quot;</span>, std::string&gt;,</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;birthday&quot;</span>, <a class="code hl_class" href="classrfl_1_1_timestamp.html">rfl::Timestamp</a>&lt;<span class="stringliteral">&quot;%Y-%m-%d&quot;</span>&gt;&gt;&gt;;</div>
</div><!-- fragment --><p>However, this will be seen as a type that is different from <code>Person</code>, the struct:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person2 {</div>
<div class="line">    std::string first_name;</div>
<div class="line">    std::string last_name;</div>
<div class="line">    <a class="code hl_class" href="classrfl_1_1_timestamp.html">rfl::Timestamp</a>&lt;<span class="stringliteral">&quot;%Y-%m-%d&quot;</span>&gt; birthday;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Structural typing also means that you can declare new types on-the-fly. For instance, in order to create a <code>Person</code> named tuple, you don't actually have to declare it at all. The following will do:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> person = <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;first_name&quot;</span>, std::string&gt;(<span class="stringliteral">&quot;Homer&quot;</span>) *</div>
<div class="line">                    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field&lt;&quot;last_name&quot;, std::string&gt;</a>(<span class="stringliteral">&quot;Simpson&quot;</span>) *</div>
<div class="line">                    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;birthday&quot;</span>, <a class="code hl_class" href="classrfl_1_1_timestamp.html">rfl::Timestamp</a>&lt;<span class="stringliteral">&quot;%Y-%m-%d&quot;</span>&gt;&gt;(<span class="stringliteral">&quot;1987-04-19&quot;</span>);</div>
</div><!-- fragment --><p>The type of <code>person</code> will now be equivalent to the definition of <code>Person</code>, the named tuple, regardless of whether you have actually declared it anywhere.</p>
<p>On the other hand, structural typing also means that recursive definitions are impossible. For instance, consider something like this:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Person {</div>
<div class="line">    std::string first_name;</div>
<div class="line">    std::string last_name;</div>
<div class="line">    std::vector&lt;Person&gt; children;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In this example, <code>Person</code> is recursively defined (because of the field <code>children</code>). This is impossible to accomplish using structural typing and <code><a class="el" href="classrfl_1_1_named_tuple.html">rfl::NamedTuple</a></code>, just like it is impossible to have a recursively defined lambda function.</p>
<h1><a class="anchor" id="autotoc_md608"></a>
Accessing fields</h1>
<p>Fields inside the named tuple can be accessed using <code><a class="el" href="namespacerfl.html#ac379420409251e5a3c0bea4a701daf0a" title="Gets a field by index.">rfl::get</a></code> or the <code>.get</code> method:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> person = <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;first_name&quot;</span>, std::string&gt;(<span class="stringliteral">&quot;Homer&quot;</span>) *</div>
<div class="line">                    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field&lt;&quot;last_name&quot;, std::string&gt;</a>(<span class="stringliteral">&quot;Simpson&quot;</span>) *</div>
<div class="line">                    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;birthday&quot;</span>, <a class="code hl_class" href="classrfl_1_1_timestamp.html">rfl::Timestamp</a>&lt;<span class="stringliteral">&quot;%Y-%m-%d&quot;</span>&gt;&gt;(<span class="stringliteral">&quot;1987-04-19&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// OK in most circumstances (there are restrictions</span></div>
<div class="line"><span class="comment">// due to the way C++ templates work).</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> first_name = person.get&lt;<span class="stringliteral">&quot;firstName&quot;</span>&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Always OK</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> first_name = person.template <a class="code hl_function" href="stdlist__overload_8cpp.html#a120a90058439faee14791b33f94c0693">get</a>&lt;<span class="stringliteral">&quot;firstName&quot;</span>&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Always OK</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> first_name = <a class="code hl_function" href="namespacerfl.html#ac379420409251e5a3c0bea4a701daf0a">rfl::get</a>&lt;<span class="stringliteral">&quot;firstName&quot;</span>&gt;(person);</div>
<div class="ttc" id="anamespacerfl_html_ac379420409251e5a3c0bea4a701daf0a"><div class="ttname"><a href="namespacerfl.html#ac379420409251e5a3c0bea4a701daf0a">rfl::get</a></div><div class="ttdeci">auto &amp; get(NamedTupleType &amp;_tup)</div><div class="ttdoc">Gets a field by index.</div><div class="ttdef"><b>定义</b> get.hpp:11</div></div>
<div class="ttc" id="astdlist__overload_8cpp_html_a120a90058439faee14791b33f94c0693"><div class="ttname"><a href="stdlist__overload_8cpp.html#a120a90058439faee14791b33f94c0693">get</a></div><div class="ttdeci">Container::iterator get(Container &amp;c, Position position)</div><div class="ttdef"><b>定义</b> stdlist_overload.cpp:29</div></div>
</div><!-- fragment --><p>Fields can also be iterated over at compile-time using the <code>apply()</code> method:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> person = <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;first_name&quot;</span>, std::string&gt;(<span class="stringliteral">&quot;Bart&quot;</span>) *</div>
<div class="line">              <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field&lt;&quot;last_name&quot;, std::string&gt;</a>(<span class="stringliteral">&quot;Simpson&quot;</span>);</div>
<div class="line"> </div>
<div class="line">person.apply([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_function" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>) {</div>
<div class="line">  <span class="keyword">auto</span> field_name = <a class="code hl_function" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>.name();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value</a> = *<a class="code hl_function" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>.value();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">person.apply([]&lt;<span class="keyword">typename</span> Field&gt;(Field&amp; <a class="code hl_function" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>) {</div>
<div class="line">  <span class="comment">// The field name can also be obtained as a compile-time constant.</span></div>
<div class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> field_name = Field::name();</div>
<div class="line">  <span class="keyword">using </span>field_pointer_type = <span class="keyword">typename</span> Field::Type;</div>
<div class="line">  field_pointer_type* <a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value</a> = <a class="code hl_function" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>.value();</div>
<div class="line">});</div>
<div class="ttc" id="acxx11__tensor__map_8cpp_html_a7f507fea02198f6cb81c86640c7b1a4e"><div class="ttname"><a href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a></div><div class="ttdeci">static int f(const TensorMap&lt; Tensor&lt; int, 3 &gt; &gt; &amp;tensor)</div><div class="ttdef"><b>定义</b> cxx11_tensor_map.cpp:238</div></div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_abe8e049f756b5ba547bda825af81b645"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#abe8e049f756b5ba547bda825af81b645">value</a></div><div class="ttdeci">GLsizei GLboolean const GLfloat * value</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:325</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md609"></a>
Monadic operations: <code>.transform</code> and <code>.and_then</code></h2>
<p>Named tuples also contain compile-time monadic operations.</p>
<p><code>.transform(f)</code> expects a function <code>f</code> of type <code>Field -&gt; Field</code>. <code>transform</code> then applies that function to each field of the named tuple. It can be used to change either the values or the names of the fields, but not their overall number.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> lisa =</div>
<div class="line">    Person{.first_name = <span class="stringliteral">&quot;Lisa&quot;</span>, .last_name = <span class="stringliteral">&quot;Simpson&quot;</span>, .age = 8};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> to_bart = [](<span class="keyword">auto</span> field) {</div>
<div class="line"><span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<span class="keyword">decltype</span>(field)<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#aab18cfce5ee7c6881ae04f18be70d94a">::name</a>() == <span class="stringliteral">&quot;first_name&quot;</span>) {</div>
<div class="line">    field = <span class="stringliteral">&quot;Bart&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> field;</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<span class="keyword">decltype</span>(field)<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#aab18cfce5ee7c6881ae04f18be70d94a">::name</a>() == <span class="stringliteral">&quot;age&quot;</span>) {</div>
<div class="line">    field = 10;</div>
<div class="line">    <span class="keywordflow">return</span> field;</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">return</span> field;</div>
<div class="line">}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// bart will now be a named tuple with first_name=&quot;Bart&quot;,</span></div>
<div class="line"><span class="comment">// last_name=&quot;Simpson&quot;, age=10</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> bart = <a class="code hl_function" href="namespacerfl.html#a7d112596ec25825815ee5b2cae093110">rfl::to_named_tuple</a>(lisa).transform(to_bart);</div>
<div class="ttc" id="aimgui__impl__opengl3__loader_8h_html_aab18cfce5ee7c6881ae04f18be70d94a"><div class="ttname"><a href="imgui__impl__opengl3__loader_8h.html#aab18cfce5ee7c6881ae04f18be70d94a">name</a></div><div class="ttdeci">const GLchar * name</div><div class="ttdef"><b>定义</b> imgui_impl_opengl3_loader.h:312</div></div>
<div class="ttc" id="anamespacerfl_html_a7d112596ec25825815ee5b2cae093110"><div class="ttname"><a href="namespacerfl.html#a7d112596ec25825815ee5b2cae093110">rfl::to_named_tuple</a></div><div class="ttdeci">auto to_named_tuple(auto &amp;&amp;_t)</div><div class="ttdef"><b>定义</b> to_named_tuple.hpp:22</div></div>
</div><!-- fragment --><p><code>.and_then(f)</code> expects a function <code>f</code> of type <code>Field -&gt; NamedTuple</code>. <code>and_then</code> then applies that function to each field of the named tuple and finally concatenates the resulting named tuple to form a new named tuple. Note that the named tuple returned by <code>f</code> may be empty. <code>.and_then(f)</code> can be used to change either the values or the names of the fields, and can also affect their overall number.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> lisa =</div>
<div class="line">    Person{.first_name = <span class="stringliteral">&quot;Lisa&quot;</span>, .last_name = <span class="stringliteral">&quot;Simpson&quot;</span>, .age = 8};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> to_bart = [](<span class="keyword">auto</span> field) {</div>
<div class="line"><span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<span class="keyword">decltype</span>(field)<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#aab18cfce5ee7c6881ae04f18be70d94a">::name</a>() == <span class="stringliteral">&quot;first_name&quot;</span>) {</div>
<div class="line">    field = <span class="stringliteral">&quot;Bart&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacerfl.html#a19523aa875e6c36af474a97f28ed4002">rfl::make_named_tuple</a>(field);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<span class="keyword">decltype</span>(field)<a class="code hl_typedef" href="imgui__impl__opengl3__loader_8h.html#aab18cfce5ee7c6881ae04f18be70d94a">::name</a>() == <span class="stringliteral">&quot;age&quot;</span>) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacerfl.html#a19523aa875e6c36af474a97f28ed4002">rfl::make_named_tuple</a>();</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacerfl.html#a19523aa875e6c36af474a97f28ed4002">rfl::make_named_tuple</a>(field);</div>
<div class="line">}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// bart will now be a named tuple with first_name=&quot;Bart&quot;,</span></div>
<div class="line"><span class="comment">// last_name=&quot;Simpson&quot;. Since we have returned and empty</span></div>
<div class="line"><span class="comment">// named tuple for the field &quot;age&quot;, there will be no such</span></div>
<div class="line"><span class="comment">// field in bart.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> bart = <a class="code hl_function" href="namespacerfl.html#a7d112596ec25825815ee5b2cae093110">rfl::to_named_tuple</a>(lisa).and_then(to_bart);</div>
<div class="ttc" id="anamespacerfl_html_a19523aa875e6c36af474a97f28ed4002"><div class="ttname"><a href="namespacerfl.html#a19523aa875e6c36af474a97f28ed4002">rfl::make_named_tuple</a></div><div class="ttdeci">auto make_named_tuple()</div><div class="ttdoc">Explicit overload for creating empty named tuples.</div><div class="ttdef"><b>定义</b> make_named_tuple.hpp:26</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md610"></a>
<code>rfl::replace</code></h2>
<p><code><a class="el" href="namespacerfl.html#ac4bd3c990469707252d797a9d81a3680">rfl::replace</a></code> works for <code><a class="el" href="classrfl_1_1_named_tuple.html">rfl::NamedTuple</a></code> as well:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> lisa = <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;firstName&quot;</span>, std::string&gt;(<span class="stringliteral">&quot;Lisa&quot;</span>) *</div>
<div class="line">                  <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field&lt;&quot;lastName&quot;, std::string&gt;</a>(<span class="stringliteral">&quot;Simpson&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns a deep copy of the original object,</span></div>
<div class="line"><span class="comment">// replacing first_name.</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> maggie =</div>
<div class="line">    <a class="code hl_function" href="namespacerfl.html#ac4bd3c990469707252d797a9d81a3680">rfl::replace</a>(lisa, <a class="code hl_function" href="namespacerfl.html#afb5f68a22d5b6a42a5b4477c35559ce9">rfl::make_field&lt;&quot;firstName&quot;&gt;</a>(std::string(<span class="stringliteral">&quot;Maggie&quot;</span>)));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Also OK</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> bart = lisa.replace(<a class="code hl_function" href="namespacerfl.html#afb5f68a22d5b6a42a5b4477c35559ce9">rfl::make_field&lt;&quot;firstName&quot;&gt;</a>(std::string(<span class="stringliteral">&quot;Bart&quot;</span>)));</div>
<div class="ttc" id="anamespacerfl_html_ac4bd3c990469707252d797a9d81a3680"><div class="ttname"><a href="namespacerfl.html#ac4bd3c990469707252d797a9d81a3680">rfl::replace</a></div><div class="ttdeci">auto replace(T &amp;&amp;_t, RField &amp;&amp;_field, OtherRFields &amp;&amp;... _other_fields)</div><div class="ttdef"><b>定义</b> replace.hpp:13</div></div>
<div class="ttc" id="anamespacerfl_html_afb5f68a22d5b6a42a5b4477c35559ce9"><div class="ttname"><a href="namespacerfl.html#afb5f68a22d5b6a42a5b4477c35559ce9">rfl::make_field</a></div><div class="ttdeci">auto make_field(T &amp;&amp;_value)</div><div class="ttdef"><b>定义</b> Field.hpp:143</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md611"></a>
<code>rfl::as</code></h2>
<p>So does <code><a class="el" href="namespacerfl.html#a6ed469a6082d8180235db125c13fc410" title="Generates a type T from the input values.">rfl::as</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_define" href="test__buffer__node_8cpp.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a> = <a class="code hl_class" href="classrfl_1_1_named_tuple.html">rfl::NamedTuple</a>&lt;</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;f1&quot;</span>, std::string&gt;,</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;f2&quot;</span>, std::string&gt;,</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;f4&quot;</span>, std::string&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_variable" href="_cwise__product_8cpp.html#ad2cbe4616e813eb9af81732dca777b24">a</a> = <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;f1&quot;</span>, std::string&gt;(<span class="stringliteral">&quot;Hello&quot;</span>) *  </div>
<div class="line">               <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field&lt;&quot;f2&quot;, std::string&gt;</a>(<span class="stringliteral">&quot;World&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_variable" href="offscreen_8c.html#a846c9667e34d56c560bb7f0ac6e173f6">b</a> = <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;f3&quot;</span>, std::string&gt;(<span class="stringliteral">&quot;Hello&quot;</span>) *  </div>
<div class="line">               <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field&lt;&quot;f4&quot;, std::string&gt;</a>(<span class="stringliteral">&quot;World&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_variable" href="bench_vec_add_8cpp.html#a41689956983587b085f9da3e48f31d99">c</a> = <a class="code hl_function" href="namespacerfl.html#a6ed469a6082d8180235db125c13fc410">rfl::as&lt;C&gt;</a>(<a class="code hl_variable" href="_cwise__product_8cpp.html#ad2cbe4616e813eb9af81732dca777b24">a</a>, <a class="code hl_variable" href="offscreen_8c.html#a846c9667e34d56c560bb7f0ac6e173f6">b</a>);</div>
<div class="ttc" id="a_cwise__product_8cpp_html_ad2cbe4616e813eb9af81732dca777b24"><div class="ttname"><a href="_cwise__product_8cpp.html#ad2cbe4616e813eb9af81732dca777b24">a</a></div><div class="ttdeci">Array33i a</div><div class="ttdef"><b>定义</b> Cwise_product.cpp:1</div></div>
<div class="ttc" id="abench_vec_add_8cpp_html_a41689956983587b085f9da3e48f31d99"><div class="ttname"><a href="bench_vec_add_8cpp.html#a41689956983587b085f9da3e48f31d99">c</a></div><div class="ttdeci">Scalar Scalar * c</div><div class="ttdef"><b>定义</b> benchVecAdd.cpp:17</div></div>
<div class="ttc" id="anamespacerfl_html_a6ed469a6082d8180235db125c13fc410"><div class="ttname"><a href="namespacerfl.html#a6ed469a6082d8180235db125c13fc410">rfl::as</a></div><div class="ttdeci">T as(Head &amp;&amp;_head, Tail &amp;&amp;... _tail)</div><div class="ttdoc">Generates a type T from the input values.</div><div class="ttdef"><b>定义</b> as.hpp:12</div></div>
<div class="ttc" id="aoffscreen_8c_html_a846c9667e34d56c560bb7f0ac6e173f6"><div class="ttname"><a href="offscreen_8c.html#a846c9667e34d56c560bb7f0ac6e173f6">b</a></div><div class="ttdeci">float b</div><div class="ttdef"><b>定义</b> offscreen.c:42</div></div>
<div class="ttc" id="atest__buffer__node_8cpp_html_ac4cf4b2ab929bd23951a8676eeac086b"><div class="ttname"><a href="test__buffer__node_8cpp.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a></div><div class="ttdeci">#define C</div><div class="ttdef"><b>定义</b> test_buffer_node.cpp:28</div></div>
</div><!-- fragment --><p>However, you do not really have to use <code><a class="el" href="namespacerfl.html#a6ed469a6082d8180235db125c13fc410" title="Generates a type T from the input values.">rfl::as</a></code> here. This will work as well:</p>
<div class="fragment"><div class="line"><span class="comment">// Same as rfl::as&lt;C&gt;(a, b)</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_variable" href="bench_vec_add_8cpp.html#a41689956983587b085f9da3e48f31d99">c</a> = <a class="code hl_define" href="test__buffer__node_8cpp.html#ac4cf4b2ab929bd23951a8676eeac086b">C</a>(<a class="code hl_variable" href="_cwise__product_8cpp.html#ad2cbe4616e813eb9af81732dca777b24">a</a> * <a class="code hl_variable" href="offscreen_8c.html#a846c9667e34d56c560bb7f0ac6e173f6">b</a>);</div>
</div><!-- fragment --><p>(in fact, this is how <code><a class="el" href="namespacerfl.html#a6ed469a6082d8180235db125c13fc410" title="Generates a type T from the input values.">rfl::as</a></code> is implemented in the first place).</p>
<h1><a class="anchor" id="autotoc_md612"></a>
Defining named tuples using other named tuples</h1>
<p><code><a class="el" href="structrfl_1_1_flatten.html" title="Used to embed another struct into the generated output.">rfl::Flatten</a></code> is not supported inside named tuples. Instead, you can use <code><a class="el" href="namespacerfl.html#ae957285d05ac374da54195649b4dbc00">rfl::define_named_tuple_t</a>&lt;...&gt;</code> to achieve the same goal:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>Person = <a class="code hl_class" href="classrfl_1_1_named_tuple.html">rfl::NamedTuple</a>&lt;</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;firstName&quot;</span>, std::string&gt;,</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;lastName&quot;</span>, std::string&gt;,</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;age&quot;</span>, <span class="keywordtype">int</span>&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Employee = <a class="code hl_typedef" href="namespacerfl.html#ae957285d05ac374da54195649b4dbc00">rfl::define_named_tuple_t</a>&lt;</div>
<div class="line">    Person,</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field</a>&lt;<span class="stringliteral">&quot;salary&quot;</span>, <span class="keywordtype">float</span>&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> employee = Employee(</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field&lt;&quot;firstName&quot;, std::string&gt;</a>(<span class="stringliteral">&quot;Homer&quot;</span>),</div>
<div class="line">    <a class="code hl_struct" href="structrfl_1_1_field.html">rfl::Field&lt;&quot;lastName&quot;, std::string&gt;</a>(<span class="stringliteral">&quot;Simpson&quot;</span>),</div>
<div class="line">    <a class="code hl_function" href="namespacerfl.html#afb5f68a22d5b6a42a5b4477c35559ce9">rfl::make_field&lt;&quot;age&quot;&gt;</a>(45),</div>
<div class="line">    <a class="code hl_function" href="namespacerfl.html#afb5f68a22d5b6a42a5b4477c35559ce9">rfl::make_field&lt;&quot;salary&quot;&gt;</a>(60000.0));</div>
<div class="ttc" id="anamespacerfl_html_ae957285d05ac374da54195649b4dbc00"><div class="ttname"><a href="namespacerfl.html#ae957285d05ac374da54195649b4dbc00">rfl::define_named_tuple_t</a></div><div class="ttdeci">typename internal::define_named_tuple&lt; FieldTypes... &gt;::type define_named_tuple_t</div><div class="ttdef"><b>定义</b> define_named_tuple.hpp:10</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md613"></a>
Transforming structs to named tuples and vice versa</h1>
<p>You can transform structs to named tuples and vice versa (this will only work with the <code><a class="el" href="structrfl_1_1_field.html" title="Used to define a field in the NamedTuple.">rfl::Field</a></code>-syntax:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> bart = Person{.first_name = <span class="stringliteral">&quot;Bart&quot;</span>,</div>
<div class="line">                   .last_name = <span class="stringliteral">&quot;Simpson&quot;</span>,</div>
<div class="line">                   .birthday = <span class="stringliteral">&quot;1987-04-19&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// bart_nt is a named tuple</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> bart_nt = <a class="code hl_function" href="namespacerfl.html#a7d112596ec25825815ee5b2cae093110">rfl::to_named_tuple</a>(bart);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// You can also retrieve the equivalent named tuple</span></div>
<div class="line"><span class="comment">// type to a struct:</span></div>
<div class="line"><span class="keyword">using </span>PersonNamedTuple = <a class="code hl_typedef" href="namespacerfl.html#a8ed271477b7d12d3ed6fbc987e8ad999">rfl::named_tuple_t&lt;Person&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// rfl::to_named_tuple also supports move semantics</span></div>
<div class="line">PersonNamedTuple bart_nt = <a class="code hl_function" href="namespacerfl.html#a7d112596ec25825815ee5b2cae093110">rfl::to_named_tuple</a>(std::move(bart_nt));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// You can also go the other way</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> bart_struct = <a class="code hl_function" href="namespacerfl.html#a5acb20e6bf6611a2a9f26931513b29f7">rfl::from_named_tuple&lt;Person&gt;</a>(bart_nt);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> bart_struct = <a class="code hl_function" href="namespacerfl.html#a5acb20e6bf6611a2a9f26931513b29f7">rfl::from_named_tuple&lt;Person&gt;</a>(std::move(bart_nt));</div>
<div class="ttc" id="anamespacerfl_html_a5acb20e6bf6611a2a9f26931513b29f7"><div class="ttname"><a href="namespacerfl.html#a5acb20e6bf6611a2a9f26931513b29f7">rfl::from_named_tuple</a></div><div class="ttdeci">auto from_named_tuple(NamedTupleType &amp;&amp;_n)</div><div class="ttdoc">Generates the struct T from a named tuple.</div><div class="ttdef"><b>定义</b> from_named_tuple.hpp:17</div></div>
<div class="ttc" id="anamespacerfl_html_a8ed271477b7d12d3ed6fbc987e8ad999"><div class="ttname"><a href="namespacerfl.html#a8ed271477b7d12d3ed6fbc987e8ad999">rfl::named_tuple_t</a></div><div class="ttdeci">typename internal::remove_ptrs_nt&lt; internal::ptr_named_tuple_t&lt; T &gt; &gt;::NamedTupleType named_tuple_t</div><div class="ttdef"><b>定义</b> named_tuple_t.hpp:19</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
