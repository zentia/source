<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: cds::container::StripedSet&lt; Container, Options &gt; 模板类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classcds_1_1container_1_1_striped_set.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="classcds_1_1container_1_1_striped_set-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">cds::container::StripedSet&lt; Container, Options &gt; 模板类 参考<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__set.html">Set</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Striped hash set  
 <a href="#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="container_2striped__set_8h_source.html">striped_set.h</a>&gt;</code></p>
<div class="dynheader">
类 cds::container::StripedSet&lt; Container, Options &gt; 继承关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1container_1_1_striped_set__inherit__graph.png" border="0" usemap="#acds_1_1container_1_1_striped_set_3_01_container_00_01_options_01_4_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<div class="dynheader">
cds::container::StripedSet&lt; Container, Options &gt; 的协作图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1container_1_1_striped_set__coll__graph.png" border="0" usemap="#acds_1_1container_1_1_striped_set_3_01_container_00_01_options_01_4_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:ab78f765a66999a851520edd05688f688" id="r_ab78f765a66999a851520edd05688f688"><td class="memItemLeft" align="right" valign="top">typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab78f765a66999a851520edd05688f688">underlying_container_type</a></td></tr>
<tr class="memdesc:ab78f765a66999a851520edd05688f688"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket  <br /></td></tr>
<tr class="separator:ab78f765a66999a851520edd05688f688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd05847a606289e2125e22c390836e2d" id="r_acd05847a606289e2125e22c390836e2d"><td class="memItemLeft" align="right" valign="top">typedef base_class::bucket_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd05847a606289e2125e22c390836e2d">bucket_type</a></td></tr>
<tr class="memdesc:acd05847a606289e2125e22c390836e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set  <br /></td></tr>
<tr class="separator:acd05847a606289e2125e22c390836e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2497aaa946640a16825e61d14a6d6189" id="r_a2497aaa946640a16825e61d14a6d6189"><td class="memItemLeft" align="right" valign="top">typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2497aaa946640a16825e61d14a6d6189">value_type</a></td></tr>
<tr class="memdesc:a2497aaa946640a16825e61d14a6d6189"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the set  <br /></td></tr>
<tr class="separator:a2497aaa946640a16825e61d14a6d6189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b1488d09e53e4fdadf2581db30b311" id="r_ab3b1488d09e53e4fdadf2581db30b311"><td class="memItemLeft" align="right" valign="top">typedef base_class::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3b1488d09e53e4fdadf2581db30b311">hash</a></td></tr>
<tr class="memdesc:ab3b1488d09e53e4fdadf2581db30b311"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_hash.html">Hash</a> functor  <br /></td></tr>
<tr class="separator:ab3b1488d09e53e4fdadf2581db30b311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8e128e84f4a17ae60a837867556050" id="r_aff8e128e84f4a17ae60a837867556050"><td class="memItemLeft" align="right" valign="top">typedef base_class::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff8e128e84f4a17ae60a837867556050">item_counter</a></td></tr>
<tr class="memdesc:aff8e128e84f4a17ae60a837867556050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter  <br /></td></tr>
<tr class="separator:aff8e128e84f4a17ae60a837867556050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132347759ae9e7929c5dc75a53890687" id="r_a132347759ae9e7929c5dc75a53890687"><td class="memItemLeft" align="right" valign="top">typedef base_class::resizing_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a132347759ae9e7929c5dc75a53890687">resizing_policy</a></td></tr>
<tr class="memdesc:a132347759ae9e7929c5dc75a53890687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy  <br /></td></tr>
<tr class="separator:a132347759ae9e7929c5dc75a53890687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae456575fca3f9634a4cbc25504d01a2a" id="r_ae456575fca3f9634a4cbc25504d01a2a"><td class="memItemLeft" align="right" valign="top">typedef base_class::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae456575fca3f9634a4cbc25504d01a2a">allocator_type</a></td></tr>
<tr class="memdesc:ae456575fca3f9634a4cbc25504d01a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options.  <br /></td></tr>
<tr class="separator:ae456575fca3f9634a4cbc25504d01a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52867de81f8ae19c2bc1d261694470ec" id="r_a52867de81f8ae19c2bc1d261694470ec"><td class="memItemLeft" align="right" valign="top">typedef base_class::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52867de81f8ae19c2bc1d261694470ec">mutex_policy</a></td></tr>
<tr class="memdesc:a52867de81f8ae19c2bc1d261694470ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy  <br /></td></tr>
<tr class="separator:a52867de81f8ae19c2bc1d261694470ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a5b62b8c4af0730a78837e3c8a29994c2" id="r_a5b62b8c4af0730a78837e3c8a29994c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b62b8c4af0730a78837e3c8a29994c2">StripedSet</a> ()</td></tr>
<tr class="memdesc:a5b62b8c4af0730a78837e3c8a29994c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16.  <br /></td></tr>
<tr class="separator:a5b62b8c4af0730a78837e3c8a29994c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319c779ca7127d5fc03ade9a521a0338" id="r_a319c779ca7127d5fc03ade9a521a0338"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a319c779ca7127d5fc03ade9a521a0338">StripedSet</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a319c779ca7127d5fc03ade9a521a0338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified  <br /></td></tr>
<tr class="separator:a319c779ca7127d5fc03ade9a521a0338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481f34c5eb75bfb09aa7eca7f91c6e13" id="r_a481f34c5eb75bfb09aa7eca7f91c6e13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a481f34c5eb75bfb09aa7eca7f91c6e13">StripedSet</a> (size_t nCapacity, <a class="el" href="#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:a481f34c5eb75bfb09aa7eca7f91c6e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <br /></td></tr>
<tr class="separator:a481f34c5eb75bfb09aa7eca7f91c6e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2289fff041c278598a6fe5e447ceb7" id="r_a0a2289fff041c278598a6fe5e447ceb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a2289fff041c278598a6fe5e447ceb7">StripedSet</a> (size_t nCapacity, <a class="el" href="#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:a0a2289fff041c278598a6fe5e447ceb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <br /></td></tr>
<tr class="separator:a0a2289fff041c278598a6fe5e447ceb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eee4ba35c6a33a03d12ad436cefc832" id="r_a0eee4ba35c6a33a03d12ad436cefc832"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0eee4ba35c6a33a03d12ad436cefc832">~StripedSet</a> ()</td></tr>
<tr class="memdesc:a0eee4ba35c6a33a03d12ad436cefc832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data  <br /></td></tr>
<tr class="separator:a0eee4ba35c6a33a03d12ad436cefc832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8843b99b6f85ad37e9b4e4d920f523" id="r_aff8843b99b6f85ad37e9b4e4d920f523"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&gt; </td></tr>
<tr class="memitem:aff8843b99b6f85ad37e9b4e4d920f523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aff8843b99b6f85ad37e9b4e4d920f523">insert</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val)</td></tr>
<tr class="memdesc:aff8843b99b6f85ad37e9b4e4d920f523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node  <br /></td></tr>
<tr class="separator:aff8843b99b6f85ad37e9b4e4d920f523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516d09d6a558712c1827bf57bd65b53" id="r_a6516d09d6a558712c1827bf57bd65b53"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </td></tr>
<tr class="memitem:a6516d09d6a558712c1827bf57bd65b53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6516d09d6a558712c1827bf57bd65b53">insert</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a6516d09d6a558712c1827bf57bd65b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node  <br /></td></tr>
<tr class="separator:a6516d09d6a558712c1827bf57bd65b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad9d39e24e0e1104be28f212e22fedc" id="r_a7ad9d39e24e0e1104be28f212e22fedc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7ad9d39e24e0e1104be28f212e22fedc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ad9d39e24e0e1104be28f212e22fedc">emplace</a> (Args &amp;&amp;... <a class="el" href="tbbproxy_8cpp.html#acd08a6295eccfeb30c79985f047e4be5">args</a>)</td></tr>
<tr class="memdesc:a7ad9d39e24e0e1104be28f212e22fedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts data of type <code class="param">value_type</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code>  <br /></td></tr>
<tr class="separator:a7ad9d39e24e0e1104be28f212e22fedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7015cd2952dd86da2b035b34be624fd" id="r_ae7015cd2952dd86da2b035b34be624fd"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </td></tr>
<tr class="memitem:ae7015cd2952dd86da2b035b34be624fd"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae7015cd2952dd86da2b035b34be624fd">update</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Func <a class="el" href="structfunc.html">func</a>, <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> bAllowInsert=<a class="el" href="yyjson_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="memdesc:ae7015cd2952dd86da2b035b34be624fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node  <br /></td></tr>
<tr class="separator:ae7015cd2952dd86da2b035b34be624fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89f2115ab187e2105c91dd933cb82d7" id="r_ad89f2115ab187e2105c91dd933cb82d7"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&gt; </td></tr>
<tr class="memitem:ad89f2115ab187e2105c91dd933cb82d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad89f2115ab187e2105c91dd933cb82d7">erase</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>)</td></tr>
<tr class="memdesc:ad89f2115ab187e2105c91dd933cb82d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code class="param">key</code> from the set  <br /></td></tr>
<tr class="separator:ad89f2115ab187e2105c91dd933cb82d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bbd4712424855500108292e10935f7" id="r_a93bbd4712424855500108292e10935f7"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </td></tr>
<tr class="memitem:a93bbd4712424855500108292e10935f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a93bbd4712424855500108292e10935f7">erase_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Less pred)</td></tr>
<tr class="memdesc:a93bbd4712424855500108292e10935f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:a93bbd4712424855500108292e10935f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3e75924c53c72d92082b484975af7a" id="r_a0c3e75924c53c72d92082b484975af7a"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </td></tr>
<tr class="memitem:a0c3e75924c53c72d92082b484975af7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c3e75924c53c72d92082b484975af7a">erase</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a0c3e75924c53c72d92082b484975af7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete <code class="param">key</code> from the set  <br /></td></tr>
<tr class="separator:a0c3e75924c53c72d92082b484975af7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af161c84a97d8357664c37720bdf77879" id="r_af161c84a97d8357664c37720bdf77879"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </td></tr>
<tr class="memitem:af161c84a97d8357664c37720bdf77879"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af161c84a97d8357664c37720bdf77879">erase_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Less pred, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:af161c84a97d8357664c37720bdf77879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:af161c84a97d8357664c37720bdf77879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203525441d38698012f814d8408f6d36" id="r_a203525441d38698012f814d8408f6d36"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </td></tr>
<tr class="memitem:a203525441d38698012f814d8408f6d36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a203525441d38698012f814d8408f6d36">find</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> &amp;val, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a203525441d38698012f814d8408f6d36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code>  <br /></td></tr>
<tr class="separator:a203525441d38698012f814d8408f6d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aaecb8e05cd335c57507c1a69ea3078" id="r_a7aaecb8e05cd335c57507c1a69ea3078"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:a7aaecb8e05cd335c57507c1a69ea3078"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7aaecb8e05cd335c57507c1a69ea3078">find_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> &amp;val, Less pred, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a7aaecb8e05cd335c57507c1a69ea3078"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate  <br /></td></tr>
<tr class="separator:a7aaecb8e05cd335c57507c1a69ea3078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9099506c1034b3a5f437db5e73c1d0" id="r_acb9099506c1034b3a5f437db5e73c1d0"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </td></tr>
<tr class="memitem:acb9099506c1034b3a5f437db5e73c1d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb9099506c1034b3a5f437db5e73c1d0">find</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:acb9099506c1034b3a5f437db5e73c1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code>  <br /></td></tr>
<tr class="separator:acb9099506c1034b3a5f437db5e73c1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a062a1d56946e140c120856be09b04a" id="r_a6a062a1d56946e140c120856be09b04a"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:a6a062a1d56946e140c120856be09b04a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a062a1d56946e140c120856be09b04a">find_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Less pred, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a6a062a1d56946e140c120856be09b04a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate  <br /></td></tr>
<tr class="separator:a6a062a1d56946e140c120856be09b04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0dfbf9bd83bc92c1d7611532811c523" id="r_aa0dfbf9bd83bc92c1d7611532811c523"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&gt; </td></tr>
<tr class="memitem:aa0dfbf9bd83bc92c1d7611532811c523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa0dfbf9bd83bc92c1d7611532811c523">contains</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>)</td></tr>
<tr class="memdesc:aa0dfbf9bd83bc92c1d7611532811c523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code class="param">key</code>  <br /></td></tr>
<tr class="separator:aa0dfbf9bd83bc92c1d7611532811c523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4581ada4d40d30156be2138d96209008" id="r_a4581ada4d40d30156be2138d96209008"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </td></tr>
<tr class="memitem:a4581ada4d40d30156be2138d96209008"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4581ada4d40d30156be2138d96209008">contains</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Less pred)</td></tr>
<tr class="memdesc:a4581ada4d40d30156be2138d96209008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the map contains <code class="param">key</code> using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:a4581ada4d40d30156be2138d96209008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdfcbca5e48b3d517b9e450a06e9be1" id="r_a4bdfcbca5e48b3d517b9e450a06e9be1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bdfcbca5e48b3d517b9e450a06e9be1">clear</a> ()</td></tr>
<tr class="memdesc:a4bdfcbca5e48b3d517b9e450a06e9be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set  <br /></td></tr>
<tr class="separator:a4bdfcbca5e48b3d517b9e450a06e9be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e30b916dabbf37f56dd07915e5102f2" id="r_a1e30b916dabbf37f56dd07915e5102f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e30b916dabbf37f56dd07915e5102f2">empty</a> () const</td></tr>
<tr class="memdesc:a1e30b916dabbf37f56dd07915e5102f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty  <br /></td></tr>
<tr class="separator:a1e30b916dabbf37f56dd07915e5102f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57316947488c56167c0a0b39907e90ec" id="r_a57316947488c56167c0a0b39907e90ec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57316947488c56167c0a0b39907e90ec">size</a> () const</td></tr>
<tr class="memdesc:a57316947488c56167c0a0b39907e90ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set  <br /></td></tr>
<tr class="separator:a57316947488c56167c0a0b39907e90ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e88c75874196bc4a034da5a5ac2806c" id="r_a4e88c75874196bc4a034da5a5ac2806c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e88c75874196bc4a034da5a5ac2806c">bucket_count</a> () const</td></tr>
<tr class="memdesc:a4e88c75874196bc4a034da5a5ac2806c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table  <br /></td></tr>
<tr class="separator:a4e88c75874196bc4a034da5a5ac2806c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40ae86014cc00810a3999531bd90f82" id="r_ac40ae86014cc00810a3999531bd90f82"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac40ae86014cc00810a3999531bd90f82">lock_count</a> () const</td></tr>
<tr class="memdesc:ac40ae86014cc00810a3999531bd90f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size  <br /></td></tr>
<tr class="separator:ac40ae86014cc00810a3999531bd90f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd67e51632fa6661b0c242f6963b85d" id="r_a9dd67e51632fa6661b0c242f6963b85d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dd67e51632fa6661b0c242f6963b85d">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:a9dd67e51632fa6661b0c242f6963b85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object  <br /></td></tr>
<tr class="separator:a9dd67e51632fa6661b0c242f6963b85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5a5482b98e8971be6bbbe242904ec5" id="r_a0e5a5482b98e8971be6bbbe242904ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e5a5482b98e8971be6bbbe242904ec5">get_resizing_policy</a> () const</td></tr>
<tr class="memdesc:a0e5a5482b98e8971be6bbbe242904ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version)  <br /></td></tr>
<tr class="separator:a0e5a5482b98e8971be6bbbe242904ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
额外继承的成员函数</h2></td></tr>
<tr class="inherit_header pro_types_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_types_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected 类型 继承自 <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:a30062f90ac31fe161c7cd4539fcaaf13 inherit pro_types_classcds_1_1intrusive_1_1_striped_set" id="r_a30062f90ac31fe161c7cd4539fcaaf13"><td class="memItemLeft" align="right" valign="top">typedef Container&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a30062f90ac31fe161c7cd4539fcaaf13">underlying_container_type</a></td></tr>
<tr class="memdesc:a30062f90ac31fe161c7cd4539fcaaf13 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">original intrusive container type for the bucket  <br /></td></tr>
<tr class="separator:a30062f90ac31fe161c7cd4539fcaaf13 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64586b7a2b21c90196c2116ef594ec04 inherit pro_types_classcds_1_1intrusive_1_1_striped_set" id="r_a64586b7a2b21c90196c2116ef594ec04"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1adapt.html">cds::intrusive::striped_set::adapt</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a30062f90ac31fe161c7cd4539fcaaf13">underlying_container_type</a>, Options... &gt;<a class="el" href="imgui__impl__opengl3__loader_8h.html#ae8396ff85d63082521e3324820df1009">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a64586b7a2b21c90196c2116ef594ec04">bucket_type</a></td></tr>
<tr class="memdesc:a64586b7a2b21c90196c2116ef594ec04 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">container type adapted for hash set  <br /></td></tr>
<tr class="separator:a64586b7a2b21c90196c2116ef594ec04 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999c16c7efc7a140c386cf8089d43f7b inherit pro_types_classcds_1_1intrusive_1_1_striped_set" id="r_a999c16c7efc7a140c386cf8089d43f7b"><td class="memItemLeft" align="right" valign="top">typedef bucket_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a></td></tr>
<tr class="memdesc:a999c16c7efc7a140c386cf8089d43f7b inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">value type stored in the set  <br /></td></tr>
<tr class="separator:a999c16c7efc7a140c386cf8089d43f7b inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b11af7149d2edcdcf89875dd82f29c3 inherit pro_types_classcds_1_1intrusive_1_1_striped_set" id="r_a3b11af7149d2edcdcf89875dd82f29c3"><td class="memItemLeft" align="right" valign="top">typedef options::hash&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3b11af7149d2edcdcf89875dd82f29c3">hash</a></td></tr>
<tr class="memdesc:a3b11af7149d2edcdcf89875dd82f29c3 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_hash.html">Hash</a> functor  <br /></td></tr>
<tr class="separator:a3b11af7149d2edcdcf89875dd82f29c3 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc27916ad8566742257adde4f5b0d36c inherit pro_types_classcds_1_1intrusive_1_1_striped_set" id="r_abc27916ad8566742257adde4f5b0d36c"><td class="memItemLeft" align="right" valign="top">typedef options::item_counter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#abc27916ad8566742257adde4f5b0d36c">item_counter</a></td></tr>
<tr class="memdesc:abc27916ad8566742257adde4f5b0d36c inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter  <br /></td></tr>
<tr class="separator:abc27916ad8566742257adde4f5b0d36c inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8cacda66c49872225f89568559aa29 inherit pro_types_classcds_1_1intrusive_1_1_striped_set" id="r_a3c8cacda66c49872225f89568559aa29"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcds_1_1opt_1_1select__default.html">cds::opt::select_default</a>&lt; typenameoptions::resizing_policy, typenamebucket_type::default_resizing_policy &gt;<a class="el" href="imgui__impl__opengl3__loader_8h.html#ae8396ff85d63082521e3324820df1009">::type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3c8cacda66c49872225f89568559aa29">resizing_policy</a></td></tr>
<tr class="memdesc:a3c8cacda66c49872225f89568559aa29 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy  <br /></td></tr>
<tr class="separator:a3c8cacda66c49872225f89568559aa29 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cdc2d40853a651780c1a2afe7309ed inherit pro_types_classcds_1_1intrusive_1_1_striped_set" id="r_a47cdc2d40853a651780c1a2afe7309ed"><td class="memItemLeft" align="right" valign="top">typedef options::allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a></td></tr>
<tr class="memdesc:a47cdc2d40853a651780c1a2afe7309ed inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocator type specified in options.  <br /></td></tr>
<tr class="separator:a47cdc2d40853a651780c1a2afe7309ed inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af672d590a91e09833aa27621f7e35c26 inherit pro_types_classcds_1_1intrusive_1_1_striped_set" id="r_af672d590a91e09833aa27621f7e35c26"><td class="memItemLeft" align="right" valign="top">typedef options::mutex_policy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af672d590a91e09833aa27621f7e35c26">mutex_policy</a></td></tr>
<tr class="memdesc:af672d590a91e09833aa27621f7e35c26 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy  <br /></td></tr>
<tr class="separator:af672d590a91e09833aa27621f7e35c26 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7217f5fc38b03f908957969c227dc28 inherit pro_types_classcds_1_1intrusive_1_1_striped_set" id="r_ad7217f5fc38b03f908957969c227dc28"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classcds_1_1details_1_1_allocator.html">cds::details::Allocator</a>&lt; <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a64586b7a2b21c90196c2116ef594ec04">bucket_type</a>, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ad7217f5fc38b03f908957969c227dc28">bucket_allocator</a></td></tr>
<tr class="memdesc:ad7217f5fc38b03f908957969c227dc28 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">bucket allocator type based on <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a47cdc2d40853a651780c1a2afe7309ed">allocator_type</a>  <br /></td></tr>
<tr class="separator:ad7217f5fc38b03f908957969c227dc28 inherit pro_types_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected 成员函数 继承自 <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:a8c4b97b427950b0b119e6314337611a6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a8c4b97b427950b0b119e6314337611a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a8c4b97b427950b0b119e6314337611a6">StripedSet</a> ()</td></tr>
<tr class="memdesc:a8c4b97b427950b0b119e6314337611a6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ctor. The initial capacity is 16.  <br /></td></tr>
<tr class="separator:a8c4b97b427950b0b119e6314337611a6 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8ca33aa2ce383440759a0cf0a177e1 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a1a8ca33aa2ce383440759a0cf0a177e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1a8ca33aa2ce383440759a0cf0a177e1">StripedSet</a> (size_t nCapacity)</td></tr>
<tr class="memdesc:a1a8ca33aa2ce383440759a0cf0a177e1 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with initial capacity specified  <br /></td></tr>
<tr class="separator:a1a8ca33aa2ce383440759a0cf0a177e1 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335e83b344ba93844182d4e1ff1708dc inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a335e83b344ba93844182d4e1ff1708dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a335e83b344ba93844182d4e1ff1708dc">StripedSet</a> (size_t nCapacity, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> const &amp;resizingPolicy)</td></tr>
<tr class="memdesc:a335e83b344ba93844182d4e1ff1708dc inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (copy semantics)  <br /></td></tr>
<tr class="separator:a335e83b344ba93844182d4e1ff1708dc inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1c130844fc77ceda65e8822f20b478 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a3e1c130844fc77ceda65e8822f20b478"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3e1c130844fc77ceda65e8822f20b478">StripedSet</a> (size_t nCapacity, <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> &amp;&amp;resizingPolicy)</td></tr>
<tr class="memdesc:a3e1c130844fc77ceda65e8822f20b478 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ctor with resizing policy (move semantics)  <br /></td></tr>
<tr class="separator:a3e1c130844fc77ceda65e8822f20b478 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723409ba0e656ba3bbd54d41356ec710 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a723409ba0e656ba3bbd54d41356ec710"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a723409ba0e656ba3bbd54d41356ec710">~StripedSet</a> ()</td></tr>
<tr class="memdesc:a723409ba0e656ba3bbd54d41356ec710 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor destroys internal data  <br /></td></tr>
<tr class="separator:a723409ba0e656ba3bbd54d41356ec710 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9596e3aea5464a77437d6d8cdfc288f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a9596e3aea5464a77437d6d8cdfc288f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a9596e3aea5464a77437d6d8cdfc288f5">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:a9596e3aea5464a77437d6d8cdfc288f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node  <br /></td></tr>
<tr class="separator:a9596e3aea5464a77437d6d8cdfc288f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8e96d52afa3d2c265c269af1a1ba3c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a4e8e96d52afa3d2c265c269af1a1ba3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a4e8e96d52afa3d2c265c269af1a1ba3c">insert</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a4e8e96d52afa3d2c265c269af1a1ba3c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new node  <br /></td></tr>
<tr class="separator:a4e8e96d52afa3d2c265c269af1a1ba3c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bb544e5a5053bf54d1b145e0be2057 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_ac4bb544e5a5053bf54d1b145e0be2057"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ac4bb544e5a5053bf54d1b145e0be2057">update</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val, Func <a class="el" href="structfunc.html">func</a>, <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> bAllowInsert=<a class="el" href="yyjson_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="memdesc:ac4bb544e5a5053bf54d1b145e0be2057 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the node  <br /></td></tr>
<tr class="separator:ac4bb544e5a5053bf54d1b145e0be2057 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc4dd64160d03646b1f7c163f95369e inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_adbc4dd64160d03646b1f7c163f95369e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#adbc4dd64160d03646b1f7c163f95369e">unlink</a> (<a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> &amp;val)</td></tr>
<tr class="memdesc:adbc4dd64160d03646b1f7c163f95369e inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlink the item <code class="param">val</code> from the set  <br /></td></tr>
<tr class="separator:adbc4dd64160d03646b1f7c163f95369e inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd7128735b9282d6f830f81232c77f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_abfd7128735b9282d6f830f81232c77f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#abfd7128735b9282d6f830f81232c77f5">erase</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val)</td></tr>
<tr class="memdesc:abfd7128735b9282d6f830f81232c77f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set  <br /></td></tr>
<tr class="separator:abfd7128735b9282d6f830f81232c77f5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff92590e106996553af1ba9424048f inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a57ff92590e106996553af1ba9424048f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a57ff92590e106996553af1ba9424048f">erase</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a57ff92590e106996553af1ba9424048f inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set  <br /></td></tr>
<tr class="separator:a57ff92590e106996553af1ba9424048f inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc892d90499638ee0cf14ecccfc1723 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a9dc892d90499638ee0cf14ecccfc1723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a9dc892d90499638ee0cf14ecccfc1723">erase_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Less pred)</td></tr>
<tr class="memdesc:a9dc892d90499638ee0cf14ecccfc1723 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:a9dc892d90499638ee0cf14ecccfc1723 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1642d21a2abdef18258539bf7e1fdc inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a8b1642d21a2abdef18258539bf7e1fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a999c16c7efc7a140c386cf8089d43f7b">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a8b1642d21a2abdef18258539bf7e1fdc">erase_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Less pred, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a8b1642d21a2abdef18258539bf7e1fdc inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the item from the set using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:a8b1642d21a2abdef18258539bf7e1fdc inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54fb6ea73d499f07611f75973244685 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_af54fb6ea73d499f07611f75973244685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af54fb6ea73d499f07611f75973244685">find</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> &amp;val, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:af54fb6ea73d499f07611f75973244685 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code>  <br /></td></tr>
<tr class="separator:af54fb6ea73d499f07611f75973244685 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1c82507b338a1f5e835117652f48d2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a1d1c82507b338a1f5e835117652f48d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1d1c82507b338a1f5e835117652f48d2">find</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a1d1c82507b338a1f5e835117652f48d2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code>  <br /></td></tr>
<tr class="separator:a1d1c82507b338a1f5e835117652f48d2 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47d38de7746c0701b794c02d7cc79bd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_af47d38de7746c0701b794c02d7cc79bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af47d38de7746c0701b794c02d7cc79bd">find_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> &amp;val, Less pred, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:af47d38de7746c0701b794c02d7cc79bd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate  <br /></td></tr>
<tr class="separator:af47d38de7746c0701b794c02d7cc79bd inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4947957c41d99bd6d75ce5b04a975bf5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a4947957c41d99bd6d75ce5b04a975bf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a4947957c41d99bd6d75ce5b04a975bf5">find_with</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;val, Less pred, Func <a class="el" href="cxx11__tensor__map_8cpp.html#a7f507fea02198f6cb81c86640c7b1a4e">f</a>)</td></tr>
<tr class="memdesc:a4947957c41d99bd6d75ce5b04a975bf5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate  <br /></td></tr>
<tr class="separator:a4947957c41d99bd6d75ce5b04a975bf5 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e681eacb6163d341cacf39607e1471c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a5e681eacb6163d341cacf39607e1471c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a5e681eacb6163d341cacf39607e1471c">contains</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>)</td></tr>
<tr class="memdesc:a5e681eacb6163d341cacf39607e1471c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code class="param">key</code>  <br /></td></tr>
<tr class="separator:a5e681eacb6163d341cacf39607e1471c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec51f0495dce5375e33dbdad5129488 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_aeec51f0495dce5375e33dbdad5129488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aeec51f0495dce5375e33dbdad5129488">contains</a> (<a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;<a class="el" href="ittnotify__static_8h.html#aeeaf6235e69da2907f537f67e598fc9d">key</a>, Less pred)</td></tr>
<tr class="memdesc:aeec51f0495dce5375e33dbdad5129488 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the set contains <code class="param">key</code> using <code class="param">pred</code> predicate for searching  <br /></td></tr>
<tr class="separator:aeec51f0495dce5375e33dbdad5129488 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5b7ec995eb6c9ab0de511b4848c356 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a8c5b7ec995eb6c9ab0de511b4848c356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a8c5b7ec995eb6c9ab0de511b4848c356">clear</a> ()</td></tr>
<tr class="memdesc:a8c5b7ec995eb6c9ab0de511b4848c356 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set  <br /></td></tr>
<tr class="separator:a8c5b7ec995eb6c9ab0de511b4848c356 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922615dc212b034f6946253747c92567 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a922615dc212b034f6946253747c92567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a922615dc212b034f6946253747c92567">clear_and_dispose</a> (Disposer disposer)</td></tr>
<tr class="memdesc:a922615dc212b034f6946253747c92567 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the set and calls <code class="param">disposer</code> for each item  <br /></td></tr>
<tr class="separator:a922615dc212b034f6946253747c92567 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8b6d36e50fd1acd07479381a33742c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_aed8b6d36e50fd1acd07479381a33742c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aed8b6d36e50fd1acd07479381a33742c">empty</a> () const</td></tr>
<tr class="memdesc:aed8b6d36e50fd1acd07479381a33742c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set is empty  <br /></td></tr>
<tr class="separator:aed8b6d36e50fd1acd07479381a33742c inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c092c8ee3f7068d59f5f1aed4321a9 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a49c092c8ee3f7068d59f5f1aed4321a9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a49c092c8ee3f7068d59f5f1aed4321a9">size</a> () const</td></tr>
<tr class="memdesc:a49c092c8ee3f7068d59f5f1aed4321a9 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns item count in the set  <br /></td></tr>
<tr class="separator:a49c092c8ee3f7068d59f5f1aed4321a9 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98e2fa3c84dc5f9b370970ce16ba3fe inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_ab98e2fa3c84dc5f9b370970ce16ba3fe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ab98e2fa3c84dc5f9b370970ce16ba3fe">bucket_count</a> () const</td></tr>
<tr class="memdesc:ab98e2fa3c84dc5f9b370970ce16ba3fe inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of hash table  <br /></td></tr>
<tr class="separator:ab98e2fa3c84dc5f9b370970ce16ba3fe inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bc8a0b0ff0c96f164d83dcf2e9bbe0 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a60bc8a0b0ff0c96f164d83dcf2e9bbe0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a60bc8a0b0ff0c96f164d83dcf2e9bbe0">lock_count</a> () const</td></tr>
<tr class="memdesc:a60bc8a0b0ff0c96f164d83dcf2e9bbe0 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns lock array size  <br /></td></tr>
<tr class="separator:a60bc8a0b0ff0c96f164d83dcf2e9bbe0 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406fe935c8ea68d5af3f7502e9435624 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a406fe935c8ea68d5af3f7502e9435624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a406fe935c8ea68d5af3f7502e9435624">get_resizing_policy</a> ()</td></tr>
<tr class="memdesc:a406fe935c8ea68d5af3f7502e9435624 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy object  <br /></td></tr>
<tr class="separator:a406fe935c8ea68d5af3f7502e9435624 inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc7f1e8c66478d0fc7972d27ab1bb4b inherit pro_methods_classcds_1_1intrusive_1_1_striped_set" id="r_a8cc7f1e8c66478d0fc7972d27ab1bb4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3c8cacda66c49872225f89568559aa29">resizing_policy</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a8cc7f1e8c66478d0fc7972d27ab1bb4b">get_resizing_policy</a> () const</td></tr>
<tr class="memdesc:a8cc7f1e8c66478d0fc7972d27ab1bb4b inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns resizing policy (const version)  <br /></td></tr>
<tr class="separator:a8cc7f1e8c66478d0fc7972d27ab1bb4b inherit pro_methods_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;Protected 属性 继承自 <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:aa37baad9eed29bf24f0ddf890e0d01e8 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set" id="r_aa37baad9eed29bf24f0ddf890e0d01e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a64586b7a2b21c90196c2116ef594ec04">bucket_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#aa37baad9eed29bf24f0ddf890e0d01e8">m_Buckets</a></td></tr>
<tr class="memdesc:aa37baad9eed29bf24f0ddf890e0d01e8 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table  <br /></td></tr>
<tr class="separator:aa37baad9eed29bf24f0ddf890e0d01e8 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dafe2df57e9f2b43293ea825982b473 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set" id="r_a2dafe2df57e9f2b43293ea825982b473"><td class="memItemLeft" align="right" valign="top">atomics::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a2dafe2df57e9f2b43293ea825982b473">m_nBucketMask</a></td></tr>
<tr class="memdesc:a2dafe2df57e9f2b43293ea825982b473 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bucket table size - 1. m_nBucketMask + 1 should be power of two.  <br /></td></tr>
<tr class="separator:a2dafe2df57e9f2b43293ea825982b473 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1657b63e8f07fd22c313304f2d3ca0c5 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set" id="r_a1657b63e8f07fd22c313304f2d3ca0c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#abc27916ad8566742257adde4f5b0d36c">item_counter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a1657b63e8f07fd22c313304f2d3ca0c5">m_ItemCounter</a></td></tr>
<tr class="memdesc:a1657b63e8f07fd22c313304f2d3ca0c5 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Item counter  <br /></td></tr>
<tr class="separator:a1657b63e8f07fd22c313304f2d3ca0c5 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b44bfb69b63d39d2a966b416736716 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set" id="r_a13b44bfb69b63d39d2a966b416736716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3b11af7149d2edcdcf89875dd82f29c3">hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a13b44bfb69b63d39d2a966b416736716">m_Hash</a></td></tr>
<tr class="memdesc:a13b44bfb69b63d39d2a966b416736716 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_hash.html">Hash</a> functor  <br /></td></tr>
<tr class="separator:a13b44bfb69b63d39d2a966b416736716 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104ff1225ca65268f90dd235698e6f36 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set" id="r_a104ff1225ca65268f90dd235698e6f36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#af672d590a91e09833aa27621f7e35c26">mutex_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a104ff1225ca65268f90dd235698e6f36">m_MutexPolicy</a></td></tr>
<tr class="memdesc:a104ff1225ca65268f90dd235698e6f36 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex policy  <br /></td></tr>
<tr class="separator:a104ff1225ca65268f90dd235698e6f36 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a40adaba75040b3646fab1ad4bc133 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set" id="r_ab6a40adaba75040b3646fab1ad4bc133"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#a3c8cacda66c49872225f89568559aa29">resizing_policy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#ab6a40adaba75040b3646fab1ad4bc133">m_ResizingPolicy</a></td></tr>
<tr class="memdesc:ab6a40adaba75040b3646fab1ad4bc133 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizing policy  <br /></td></tr>
<tr class="separator:ab6a40adaba75040b3646fab1ad4bc133 inherit pro_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classcds_1_1intrusive_1_1_striped_set"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_static_attribs_classcds_1_1intrusive_1_1_striped_set')"><img src="closed.png" alt="-"/>&#160;静态 Protected 属性 继承自 <a class="el" href="classcds_1_1intrusive_1_1_striped_set.html">cds::intrusive::StripedSet&lt; Container, Options... &gt;</a></td></tr>
<tr class="memitem:acd3aab8a3065331de1f6ad410fa94d7f inherit pro_static_attribs_classcds_1_1intrusive_1_1_striped_set" id="r_acd3aab8a3065331de1f6ad410fa94d7f"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1intrusive_1_1_striped_set.html#acd3aab8a3065331de1f6ad410fa94d7f">c_nMinimalCapacity</a></td></tr>
<tr class="memdesc:acd3aab8a3065331de1f6ad410fa94d7f inherit pro_static_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_minimal.html" title="Wrapper around T where all members are private.">Minimal</a> capacity  <br /></td></tr>
<tr class="separator:acd3aab8a3065331de1f6ad410fa94d7f inherit pro_static_attribs_classcds_1_1intrusive_1_1_striped_set"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class Container, typename... Options&gt;<br />
class cds::container::StripedSet&lt; Container, Options &gt;</div><p>Striped hash set </p>
<p>Source</p><ul>
<li>[2008] Maurice Herlihy, Nir Shavit "The Art of Multiprocessor Programming"</li>
</ul>
<p>Lock striping is very simple technique. The set consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When set is resized, bucket table capacity will be doubled but lock array will not. The lock <code class="param">i</code> protects each bucket <code class="param">j</code>, where <code> j = i mod L </code>, where <code class="param">L</code> - the size of lock array.</p>
<p>Template arguments:</p><ul>
<li><code class="param">Container</code> - the container class that is used as bucket table entry. The <code class="param">Container</code> class should support an uniform interface described below.</li>
<li><code class="param">Options</code> - options</li>
</ul>
<p>The <code class="param">StripedSet</code> class does not exactly dictate the type of container that should be used as a <code class="param">Container</code> bucket. Instead, the class supports different container type for the bucket, for exampe, <code class="param">std::list</code>, <code class="param">std::set</code> and others.</p>
<p>Remember that <code class="param">StripedSet</code> class algorithm ensures sequential blocking access to its bucket through the mutex type you specify among <code class="param">Options</code> template arguments.</p>
<p>The <code class="param">Options</code> are:</p><ul>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1mutex__policy.html" title="[type-option] Concurrent access policy">opt::mutex_policy</a></code> - concurrent access policy. Available policies: <code class="param"><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1striping.html" title="Lock striping concurrent access policy">intrusive::striped_set::striping</a></code>, <code class="param"><a class="el" href="classcds_1_1intrusive_1_1striped__set_1_1refinable.html" title="Refinable concurrent access policy">intrusive::striped_set::refinable</a></code>. Default is <code class="param">striped_set::striping</code>.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1hash.html" title="[type-option] Option setter for a hash function">opt::hash</a></code> - hash functor. Default option value see <code>opt::v::hash_selector&lt;opt::none&gt; </code> which selects default hash functor for your compiler.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1compare.html" title="[type-option] Option setter for key comparing">opt::compare</a></code> - key comparison functor. No default functor is provided. If the option is not specified, the <code class="param">opt::less</code> is used.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1less.html" title="[type-option] Option setter for less predicate">opt::less</a></code> - specifies binary predicate used for key comparison. Default is <code class="param">std::less&lt;T&gt;</code>.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1item__counter.html" title="[type-option] Option setter for item counting">opt::item_counter</a></code> - item counter type. Default is <code class="param"><a class="el" href="classcds_1_1atomicity_1_1item__counter.html" title="Atomic item counter">atomicity::item_counter</a></code> since some operation on the counter is performed without locks. Note that item counting is an essential part of the set algorithm, so dummy counter like as <code class="param"><a class="el" href="classcds_1_1atomicity_1_1empty__item__counter.html" title="Empty item counter">atomicity::empty_item_counter</a></code> is not suitable.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1allocator.html" title="[type-option] Option setter for an allocator">opt::allocator</a></code> - the allocator type using for memory allocation of bucket table and lock array. Default is <a class="el" href="external_2libcds_2cds_2user__setup_2allocator_8h.html#ad5fb7e3cbe8cf24295f0ea3c165a2d82">CDS_DEFAULT_ALLOCATOR</a>.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1resizing__policy.html" title="Resizing policy option">opt::resizing_policy</a></code> - the resizing policy that is a functor that decides when to resize the hash set. Default option value depends on bucket container type: for sequential containers like <code class="param">std::list</code>, <code class="param">std::vector</code> the resizing policy is <code><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a2934a868ebde410fca08353b1da5973e" title="Load factor based resizing policy">striped_set::load_factor_resizing&lt;4&gt;</a> </code>; for other type of containers like <code class="param">std::set</code>, <code class="param">std::unordered_set</code> the resizing policy is <code class="param"><a class="el" href="namespacecds_1_1container_1_1striped__set.html#a1a6926eacdbf9fb4fc264d6d85d353c2" title="Dummy resizing policy">striped_set::no_resizing</a></code>. See <a class="el" href="group__cds__striped__resizing__policy.html">available resizing policy</a>. Note that the choose of resizing policy depends of <code class="param">Container</code> type: for sequential containers like <code class="param">std::list</code>, <code class="param">std::vector</code> and so on, right choosing of the policy can significantly improve performance. For other, non-sequential types of <code class="param">Container</code> (like a <code class="param">std::set</code>) the resizing policy is not so important.</li>
<li><code class="param"><a class="el" href="structcds_1_1opt_1_1copy__policy.html" title="Copy policy option">opt::copy_policy</a></code> - the copy policy which is used to copy items from the old set to the new one when resizing. The policy can be optionally used in adapted bucket container for performance reasons of resizing. The detail of copy algorithm depends on type of bucket container and explains below.</li>
</ul>
<p><code class="param">opt::compare</code> or <code class="param">opt::less</code> options are used in some <code class="param">Container</code> class for searching an item. <code class="param">opt::compare</code> option has the highest priority: if <code class="param">opt::compare</code> is specified, <code class="param">opt::less</code> is not used.</p>
<p>You can pass other option that would be passed to <code>adapt</code> metafunction, see below.</p>
<p><b>Internal details</b> </p><pre class="fragment">The \p %StripedSet class cannot utilize the \p Container container specified directly, but only its adapted variant which
supports an unified interface. Internally, the adaptation is made via striped_set::adapt metafunction that wraps bucket container
and provides the unified bucket interface suitable for \p %StripedSet. Such adaptation is completely transparent for you -
you don't need to call \p adapt metafunction directly, \p %StripedSet class's internal machinery itself invokes appropriate
\p adapt metafunction to adjust your \p Container container class to \p %StripedSet bucket's internal interface.
All you need is to include a right header before &lt;tt&gt;striped_hash_set.h&lt;/tt&gt;.

By default, &lt;tt&gt;striped_set::adapt&lt;AnyContainer, Options...&gt; &lt;/tt&gt; metafunction does not make any wrapping to \p AnyContainer,
so, the result &lt;tt&gt;striped_set::adapt&lt;AnyContainer, Options...&gt;::type &lt;/tt&gt; is the same as \p AnyContainer.
However, there are a lot of specializations of &lt;tt&gt;striped_set::adapt&lt;/tt&gt; for well-known containers, see table below.
Any of this specialization wraps corresponding container making it suitable for the set's bucket.
Remember, you should include the proper header file for \p adapt &lt;b&gt;before&lt;/b&gt; including &lt;tt&gt;striped_hash_set.h&lt;/tt&gt;.
&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Container&lt;/th&gt;
        &lt;th&gt;.h-file for \p adapt&lt;/th&gt;
        &lt;th&gt;Example&lt;/th&gt;
        &lt;th&gt;Notes&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p std::list&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_set/std_list.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_set/std_list.h&gt;
            #include &lt;cds/container/striped_hash_set.h&gt;
            typedef cds::container::StripedSet&lt;
                std::list&lt;T&gt;,
                cds::opt::less&lt; std::less&lt;T&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            The list is ordered.
            Template argument pack \p Options &lt;b&gt;must&lt;/b&gt; contain cds::opt::less or cds::opt::compare for type \p T stored in the list
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p std::vector&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_set/std_vector.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_set/std_vector.h&gt;
            #include &lt;cds/container/striped_hash_set.h&gt;
            typedef cds::container::StripedSet&lt;
                std::vector&lt;T&gt;,
                cds::opt::less&lt; std::less&lt;T&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            The vector is ordered.
            Template argument pack \p Options &lt;b&gt;must&lt;/b&gt; contain \p cds::opt::less or \p cds::opt::compare for type \p T stored in the list
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p std::set&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_set/std_set.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_set/std_set.h&gt;
            #include &lt;cds/container/striped_hash_set.h&gt;
            typedef cds::container::StripedSet&lt;
                std::set&lt; T, std::less&lt;T&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p std::unordered_set&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_set/std_hash_set.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_set/std_hash_set.h&gt;
            #include &lt;cds/container/striped_hash_set.h&gt;
            typedef cds::container::StripedSet&lt;
                std::unordered_set&lt;
                    T,
                    hash&lt;T&gt;,
                    equal&lt;T&gt;
                &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            You should provide two different hash function \p h1 and \p h2 - one for \p std::unordered_set and other for \p %StripedSet.
            For the best result, \p h1 and \p h2 must be orthogonal i.e. &lt;tt&gt; h1(X) != h2(X) &lt;/tt&gt; for any value \p X.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::slist&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_set/boost_slist.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_set/boost_slist.h&gt;
            #include &lt;cds/container/striped_hash_set.h&gt;
            typedef cds::container::StripedSet&lt;
                boost::container::slist&lt;T&gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            The list is ordered.
            \p Options &lt;b&gt;must&lt;/b&gt; contain \p cds::opt::less or \p cds::opt::compare.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::list&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_set/boost_list.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_set/boost_list.h&gt;
            #include &lt;cds/container/striped_hash_set.h&gt;
            typedef cds::container::StripedSet&lt;
                boost::container::list&lt;T&gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            The list is ordered.
            \p Options &lt;b&gt;must&lt;/b&gt; contain \p cds::opt::less or \p cds::opt::compare.
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::vector&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_set/boost_vector.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_set/boost_vector.h&gt;
            #include &lt;cds/container/striped_hash_set.h&gt;
            typedef cds::container::StripedSet&lt;
                boost::container::vector&lt;T&gt;,
                cds::opt::less&lt; std::less&lt;T&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            The vector is ordered.
            Template argument pack \p Options &lt;b&gt;must&lt;/b&gt; contain \p cds::opt::less or \p cds::opt::compare for type \p T stored in the vector
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::stable_vector&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_set/boost_stable_vector.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_set/boost_stable_vector.h&gt;
            #include &lt;cds/container/striped_hash_set.h&gt;
            typedef cds::container::StripedSet&lt;
                boost::container::stable_vector&lt;T&gt;,
                cds::opt::less&lt; std::less&lt;T&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            The vector is ordered.
            Template argument pack \p Options &lt;b&gt;must&lt;/b&gt; contain \p cds::opt::less or \p cds::opt::compare for type \p T stored in the vector
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::set&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_set/boost_set.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_set/boost_set.h&gt;
            #include &lt;cds/container/striped_hash_set.h&gt;
            typedef cds::container::StripedSet&lt;
                boost::container::set&lt; T, std::less&lt;T&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::flat_set&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_set/boost_flat_set.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_set/boost_flat_set.h&gt;
            #include &lt;cds/container/striped_hash_set.h&gt;
            typedef cds::container::StripedSet&lt;
                boost::container::flat_set&lt; T, std::less&lt;T&gt; &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::unordered_set&lt;/td&gt;
        &lt;td&gt;&lt;tt&gt;&lt;cds/container/striped_set/boost_unordered_set.h&gt;&lt;/tt&gt;&lt;/td&gt;
        &lt;td&gt;\code
            #include &lt;cds/container/striped_set/boost_unordered_set.h&gt;
            #include &lt;cds/container/striped_hash_set.h&gt;
            typedef cds::container::StripedSet&lt;
                boost::unordered_set&lt;
                    T,
                    hash&lt;T&gt;,
                    equal&lt;T&gt;
                &gt;
            &gt; striped_set;
        \endcode
        &lt;/td&gt;
        &lt;td&gt;
            You should provide two different hash function \p h1 and \p h2 - one for \p boost::unordered_set and other for \p %StripedSet.
            For the best result, \p h1 and \p h2 must be orthogonal i.e. &lt;tt&gt; h1(X) != h2(X) &lt;/tt&gt; for any value \p X.
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

You can use another container type as set's bucket.
Suppose, you have a container class \p MyBestContainer and you want to integrate it with \p %StripedSet as bucket type.
There are two possibility:
- either your \p MyBestContainer class has native support of bucket's interface;
    in this case, you can use default &lt;tt&gt;striped_set::adapt&lt;/tt&gt; metafunction;
- or your \p MyBestContainer class does not support bucket's interface, which means, that you should develop a specialization
    &lt;tt&gt;cds::container::striped_set::adapt&lt;MyBestContainer&gt; &lt;/tt&gt; metafunction providing necessary interface.

The &lt;tt&gt;striped_set::adapt&lt; Container, Options... &gt;&lt;/tt&gt; metafunction has two template argument:
- \p Container is the class that should be used as the bucket, for example, &lt;tt&gt;std::list&lt; T &gt;&lt;/tt&gt;.
- \p Options pack is the options from \p %StripedSet declaration. The \p adapt metafunction can use
    any option from \p Options for its internal use. For example, a \p compare option can be passed to \p adapt
    metafunction via \p Options argument of \p %StripedSet declaration.

See striped_set::adapt metafunction for the description of interface that the bucket container must provide
to be %StripedSet compatible.
</pre><p><b>Copy policy</b> There are three predefined copy policy:</p><ul>
<li><code class="param">cds::container::striped_set::copy_item</code> - copy item from old bucket to new one when resizing using copy ctor. It is default policy for any compiler that do not support move semantics</li>
<li><code class="param">cds::container::striped_set::move_item</code> - move item from old bucket to new one when resizing using move semantics. It is default policy for any compiler that support move semantics. If compiler does not support move semantics, the move policy is the same as <code class="param">copy_item</code> </li>
<li><code class="param">cds::container::striped_set::swap_item</code> - copy item from old bucket to new one when resizing using <code class="param"><a class="el" href="namespacestd.html#a3acbe51b6415e9284430194bf04944e1">std::swap</a></code>. Not all containers support this copy policy, see details in table below.</li>
</ul>
<p>You can define your own copy policy specifically for your case. Note, right copy policy can significantly improve the performance of resizing.</p>
<table class="doxtable">
<tr>
<th>Container </th><th>Policies  </th></tr>
<tr>
<td><ul>
<li><code class="param">std::list</code> </li>
<li><code class="param">std::vector</code> </li>
<li><code class="param">boost::list</code> </li>
<li><code class="param">boost::vector</code> </li>
<li><code class="param">boost::stable_vector</code> </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::list&lt;T&gt;&amp; list, std::list&lt;T&gt;::iterator itInsert, std::list&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert( itInsert, *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// The type T stored in the list must be swappable</span></div>
<div class="line"><span class="keyword">struct </span>swap_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::list&lt;T&gt;&amp; list, std::list&lt;T&gt;::iterator itInsert, std::list&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_function" href="namespacestd.html#a3acbe51b6415e9284430194bf04944e1">std::swap</a>( *list.insert( itInsert, <a class="code hl_define" href="test__overwrite__node_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>()), *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
<div class="ttc" id="anamespacestd_html_a3acbe51b6415e9284430194bf04944e1"><div class="ttname"><a href="namespacestd.html#a3acbe51b6415e9284430194bf04944e1">std::swap</a></div><div class="ttdeci">void swap(rfl::Box&lt; T &gt; &amp;_b1, rfl::Box&lt; T &gt; &amp;_b2)</div><div class="ttdef"><b>定义</b> Box.hpp:154</div></div>
<div class="ttc" id="atest__overwrite__node_8cpp_html_a0acb682b8260ab1c60b918599864e2e5"><div class="ttname"><a href="test__overwrite__node_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a></div><div class="ttdeci">#define T</div><div class="ttdef"><b>定义</b> test_overwrite_node.cpp:29</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::list&lt;T&gt;&amp; list, std::list&lt;T&gt;::iterator itInsert, std::list&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert( itInsert, std::move( *itWhat ));</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->   </td></tr>
<tr>
<td><ul>
<li><code class="param">std::set</code> </li>
<li><code class="param">std::unordered_set</code> </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::set&lt;T&gt;&amp; <a class="code hl_namespace" href="namespaceset.html">set</a>, std::set&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_namespace" href="namespaceset.html">set</a>.insert( *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
<div class="ttc" id="anamespaceset_html"><div class="ttname"><a href="namespaceset.html">set</a></div><div class="ttdef"><b>定义</b> set_del3.cpp:9</div></div>
</div><!-- fragment --><p> <code class="param">swap_item</code> is not applicable (same as <code class="param">copy_item</code>)</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( std::set&lt;T&gt;&amp; <a class="code hl_namespace" href="namespaceset.html">set</a>, std::set&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_namespace" href="namespaceset.html">set</a>.insert( std::move( *itWhat ));</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->  </td></tr>
<tr>
<td><ul>
<li><code class="param">boost::container::slist</code> </li>
</ul>
</td><td><div class="fragment"><div class="line"><span class="keyword">struct </span>copy_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( bc::slist&lt;T&gt;&amp; list, bc::slist&lt;T&gt;::iterator itInsert, bc::slist&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert_after( itInsert, *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// The type T stored in the list must be swappable</span></div>
<div class="line"><span class="keyword">struct </span>swap_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( bc::slist&lt;T&gt;&amp; list, bc::slist&lt;T&gt;::iterator itInsert, bc::slist&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_function" href="namespacestd.html#a3acbe51b6415e9284430194bf04944e1">std::swap</a>( *list.insert_after( itInsert, <a class="code hl_define" href="test__overwrite__node_8cpp.html#a0acb682b8260ab1c60b918599864e2e5">T</a>()), *itWhat );</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">struct </span>move_item {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( bc::slist&lt;T&gt;&amp; list, bc::slist&lt;T&gt;::iterator itInsert, bc::slist&lt;T&gt;::iterator itWhat )</div>
<div class="line">    {</div>
<div class="line">        list.insert_after( itInsert, std::move( *itWhat ));</div>
<div class="line">    }</div>
<div class="line">} </div>
</div><!-- fragment -->   </td></tr>
</table>
<p><b>Advanced functions</b> </p><pre class="fragment">&lt;b&gt;libcds&lt;/b&gt; provides some advanced functions like \p erase_with(), \p find_with(),
that cannot be supported by all underlying containers.
The table below shows whether underlying container supports those functions
(the sign "+" means "container supports the function"):

&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Container&lt;/th&gt;
        &lt;th&gt;\p find_with&lt;/th&gt;
        &lt;th&gt;\p erse_with&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p std::list&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p std::vector&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p std::set&lt;/td&gt;
        &lt;td&gt;-&lt;/td&gt;
        &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p std::unordered_set&lt;/td&gt;
        &lt;td&gt;-&lt;/td&gt;
        &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::slist&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::list&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::vector&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::stable_vector&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
        &lt;td&gt;+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::set&lt;/td&gt;
        &lt;td&gt;-&lt;/td&gt;
        &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::container::flat_set&lt;/td&gt;
        &lt;td&gt;-&lt;/td&gt;
        &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt; \p boost::unordered_set&lt;/td&gt;
        &lt;td&gt;-&lt;/td&gt;
        &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</pre> </div><h2 class="groupheader">成员类型定义说明</h2>
<a id="ae456575fca3f9634a4cbc25504d01a2a" name="ae456575fca3f9634a4cbc25504d01a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae456575fca3f9634a4cbc25504d01a2a">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::allocator_type <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocator type specified in options. </p>

</div>
</div>
<a id="acd05847a606289e2125e22c390836e2d" name="acd05847a606289e2125e22c390836e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd05847a606289e2125e22c390836e2d">&#9670;&#160;</a></span>bucket_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::bucket_type <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::bucket_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>container type adapted for hash set </p>

</div>
</div>
<a id="ab3b1488d09e53e4fdadf2581db30b311" name="ab3b1488d09e53e4fdadf2581db30b311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b1488d09e53e4fdadf2581db30b311">&#9670;&#160;</a></span>hash</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::hash <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;<a class="el" href="structhash.html">::hash</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_hash.html">Hash</a> functor </p>

</div>
</div>
<a id="aff8e128e84f4a17ae60a837867556050" name="aff8e128e84f4a17ae60a837867556050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8e128e84f4a17ae60a837867556050">&#9670;&#160;</a></span>item_counter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::item_counter <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::item_counter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Item counter </p>

</div>
</div>
<a id="a52867de81f8ae19c2bc1d261694470ec" name="a52867de81f8ae19c2bc1d261694470ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52867de81f8ae19c2bc1d261694470ec">&#9670;&#160;</a></span>mutex_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::mutex_policy <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::mutex_policy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutex policy </p>

</div>
</div>
<a id="a132347759ae9e7929c5dc75a53890687" name="a132347759ae9e7929c5dc75a53890687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132347759ae9e7929c5dc75a53890687">&#9670;&#160;</a></span>resizing_policy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::resizing_policy <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::resizing_policy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizing policy </p>

</div>
</div>
<a id="ab78f765a66999a851520edd05688f688" name="ab78f765a66999a851520edd05688f688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78f765a66999a851520edd05688f688">&#9670;&#160;</a></span>underlying_container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Container <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::underlying_container_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>original intrusive container type for the bucket </p>

</div>
</div>
<a id="a2497aaa946640a16825e61d14a6d6189" name="a2497aaa946640a16825e61d14a6d6189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2497aaa946640a16825e61d14a6d6189">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bucket_type::value_type <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>value type stored in the set </p>

</div>
</div>
<h2 class="groupheader">构造及析构函数说明</h2>
<a id="a5b62b8c4af0730a78837e3c8a29994c2" name="a5b62b8c4af0730a78837e3c8a29994c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b62b8c4af0730a78837e3c8a29994c2">&#9670;&#160;</a></span>StripedSet() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::StripedSet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default ctor. The initial capacity is 16. </p>

</div>
</div>
<a id="a319c779ca7127d5fc03ade9a521a0338" name="a319c779ca7127d5fc03ade9a521a0338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319c779ca7127d5fc03ade9a521a0338">&#9670;&#160;</a></span>StripedSet() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::StripedSet </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nCapacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with initial capacity specified </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a481f34c5eb75bfb09aa7eca7f91c6e13" name="a481f34c5eb75bfb09aa7eca7f91c6e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481f34c5eb75bfb09aa7eca7f91c6e13">&#9670;&#160;</a></span>StripedSet() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::StripedSet </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nCapacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>resizingPolicy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (copy semantics) </p>
<p>This constructor initializes m_ResizingPolicy member with copy of <code class="param">resizingPolicy</code> parameter </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16.  </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a2289fff041c278598a6fe5e447ceb7" name="a0a2289fff041c278598a6fe5e447ceb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2289fff041c278598a6fe5e447ceb7">&#9670;&#160;</a></span>StripedSet() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::StripedSet </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nCapacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>resizingPolicy</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ctor with resizing policy (move semantics) </p>
<p>This constructor initializes m_ResizingPolicy member moving <code class="param">resizingPolicy</code> parameter Move semantics is used. Available only for the compilers that supports C++11 rvalue reference. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">nCapacity</td><td>Initial size of bucket table and lock array. Must be power of two, the minimum is 16.  </td></tr>
    <tr><td class="paramname">resizingPolicy</td><td>Resizing policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eee4ba35c6a33a03d12ad436cefc832" name="a0eee4ba35c6a33a03d12ad436cefc832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eee4ba35c6a33a03d12ad436cefc832">&#9670;&#160;</a></span>~StripedSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::~<a class="el" href="classcds_1_1container_1_1_striped_set.html">StripedSet</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor destroys internal data </p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a4e88c75874196bc4a034da5a5ac2806c" name="a4e88c75874196bc4a034da5a5ac2806c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e88c75874196bc4a034da5a5ac2806c">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of hash table </p>
<p>The hash table size is non-constant and can be increased via resizing. </p>

</div>
</div>
<a id="a4bdfcbca5e48b3d517b9e450a06e9be1" name="a4bdfcbca5e48b3d517b9e450a06e9be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdfcbca5e48b3d517b9e450a06e9be1">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the set </p>
<p>The function erases all items from the set. </p>

</div>
</div>
<a id="aa0dfbf9bd83bc92c1d7611532811c523" name="aa0dfbf9bd83bc92c1d7611532811c523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0dfbf9bd83bc92c1d7611532811c523">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the set contains <code class="param">key</code> </p>
<p>The function searches the item with key equal to <code class="param">key</code> and returns <code class="param">true</code> if it is found, and <code class="param">false</code> otherwise.</p>
<p>Note the hash functor specified for class <code class="param">Traits</code> template parameter should accept a parameter of type <code class="param">Q</code> that can be not the same as <code class="param"><a class="el" href="#a2497aaa946640a16825e61d14a6d6189" title="value type stored in the set">value_type</a></code>. Otherwise, you may use <code class="param"><a class="el" href="#a4581ada4d40d30156be2138d96209008" title="Checks whether the map contains key using pred predicate for searching">contains( Q const&amp;, Less pred )</a></code> functions with explicit predicate for key comparing. </p>

</div>
</div>
<a id="a4581ada4d40d30156be2138d96209008" name="a4581ada4d40d30156be2138d96209008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4581ada4d40d30156be2138d96209008">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the map contains <code class="param">key</code> using <code class="param">pred</code> predicate for searching </p>
<p>The function is similar to <code>contains( key )</code> but <code class="param">pred</code> is used for key comparing. <code class="param">Less</code> functor has the interface like <code class="param">std::less</code>. <code class="param">Less</code> must imply the same element order as the comparator used for building the map. </p>

</div>
</div>
<a id="a7ad9d39e24e0e1104be28f212e22fedc" name="a7ad9d39e24e0e1104be28f212e22fedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad9d39e24e0e1104be28f212e22fedc">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts data of type <code class="param">value_type</code> constructed with <code>std::forward&lt;Args&gt;(args)...</code> </p>
<p>Returns <code class="param">true</code> if inserting successful, <code class="param">false</code> otherwise. </p>

</div>
</div>
<a id="a1e30b916dabbf37f56dd07915e5102f2" name="a1e30b916dabbf37f56dd07915e5102f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e30b916dabbf37f56dd07915e5102f2">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the set is empty </p>
<p>Emptiness is checked by item counting: if item count is zero then the set is empty. </p>

</div>
</div>
<a id="ad89f2115ab187e2105c91dd933cb82d7" name="ad89f2115ab187e2105c91dd933cb82d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89f2115ab187e2105c91dd933cb82d7">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code class="param">key</code> from the set </p>
<p><a class="anchor" id="cds_nonintrusive_StripedSet_erase"></a> The set item comparator should be able to compare the type <code class="param"><a class="el" href="#a2497aaa946640a16825e61d14a6d6189" title="value type stored in the set">value_type</a></code> and the type <code class="param">Q</code>. Return <code class="param">true</code> if key is found and deleted, <code class="param">false</code> otherwise </p>

</div>
</div>
<a id="a0c3e75924c53c72d92082b484975af7a" name="a0c3e75924c53c72d92082b484975af7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3e75924c53c72d92082b484975af7a">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete <code class="param">key</code> from the set </p>
<p><a class="anchor" id="cds_nonintrusive_StripedSet_erase_func"></a> The function searches an item with key <code class="param">key</code>, calls <code class="param">f</code> functor with item found and deletes it. If <code class="param">key</code> is not found, the functor is not called.</p>
<p>The functor <code class="param">Func</code> interface is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(<a class="code hl_typedef" href="#a2497aaa946640a16825e61d14a6d6189">value_type</a> <span class="keyword">const</span>&amp; val);</div>
<div class="line">};</div>
<div class="ttc" id="aclasscds_1_1container_1_1_striped_set_html_a2497aaa946640a16825e61d14a6d6189"><div class="ttname"><a href="#a2497aaa946640a16825e61d14a6d6189">cds::container::StripedSet::value_type</a></div><div class="ttdeci">bucket_type::value_type value_type</div><div class="ttdoc">value type stored in the set</div><div class="ttdef"><b>定义</b> striped_set.h:480</div></div>
</div><!-- fragment --><p>Return <code class="param">true</code> if key is found and deleted, <code class="param">false</code> otherwise </p>

</div>
</div>
<a id="a93bbd4712424855500108292e10935f7" name="a93bbd4712424855500108292e10935f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93bbd4712424855500108292e10935f7">&#9670;&#160;</a></span>erase_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code class="param">pred</code> predicate for searching </p>
<p>The function is an analog of <a class="el" href="#cds_nonintrusive_StripedSet_erase">erase(Q const&amp;)</a> but <code class="param">pred</code> is used for key comparing. <code class="param">Less</code> functor has the interface like <code class="param">std::less</code>. <code class="param">pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>注解</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code class="param">erase_with</code> feature. </dd></dl>

</div>
</div>
<a id="af161c84a97d8357664c37720bdf77879" name="af161c84a97d8357664c37720bdf77879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af161c84a97d8357664c37720bdf77879">&#9670;&#160;</a></span>erase_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_erase_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::erase_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the item from the set using <code class="param">pred</code> predicate for searching </p>
<p>The function is an analog of <a class="el" href="#cds_nonintrusive_StripedSet_erase_func">erase(Q const&amp;, Func)</a> but <code class="param">pred</code> is used for key comparing. <code class="param">Less</code> functor has the interface like <code class="param">std::less</code>. <code class="param">pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>注解</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code class="param">erase_with</code> feature. </dd></dl>

</div>
</div>
<a id="a203525441d38698012f814d8408f6d36" name="a203525441d38698012f814d8408f6d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203525441d38698012f814d8408f6d36">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> </p>
<p><a class="anchor" id="cds_nonintrusive_StripedSet_find_func"></a> The function searches the item with key equal to <code class="param">val</code> and calls the functor <code class="param">f</code> for item found. The interface of <code class="param">Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code hl_typedef" href="#a2497aaa946640a16825e61d14a6d6189">value_type</a>&amp; item, <a class="code hl_variable" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&amp; val );</div>
<div class="line">};</div>
<div class="ttc" id="a_householder_q_r__householder_q_8cpp_html_a7e56035a736d269ad670f312496a0846"><div class="ttname"><a href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a></div><div class="ttdeci">MatrixXf Q</div><div class="ttdef"><b>定义</b> HouseholderQR_householderQ.cpp:1</div></div>
</div><!-- fragment --><p> where <code class="param">item</code> is the item found, <code class="param">val</code> is the <code>find</code> function argument.</p>
<p>The functor can change non-key fields of <code class="param">item</code>. The <code class="param">val</code> argument is non-const since it can be used as <code class="param">f</code> functor destination i.e., the functor can modify both arguments.</p>
<p>The type <code class="param">Q</code> can differ from <code class="param"><a class="el" href="#a2497aaa946640a16825e61d14a6d6189" title="value type stored in the set">value_type</a></code> of items storing in the container. Therefore, the <code class="param"><a class="el" href="#a2497aaa946640a16825e61d14a6d6189" title="value type stored in the set">value_type</a></code> should be comparable with type <code class="param">Q</code>.</p>
<p>The function returns <code class="param">true</code> if <code class="param">val</code> is found, <code class="param">false</code> otherwise. </p>

</div>
</div>
<a id="acb9099506c1034b3a5f437db5e73c1d0" name="acb9099506c1034b3a5f437db5e73c1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9099506c1034b3a5f437db5e73c1d0">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> </p>
<p><a class="anchor" id="cds_nonintrusive_StripedSet_find_cfunc"></a> The function searches the item with key equal to <code class="param">val</code> and calls the functor <code class="param">f</code> for item found. The interface of <code class="param">Func</code> functor is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>functor {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <a class="code hl_typedef" href="#a2497aaa946640a16825e61d14a6d6189">value_type</a>&amp; item, <a class="code hl_variable" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> <span class="keyword">const</span>&amp; val );</div>
<div class="line">};</div>
</div><!-- fragment --><p> where <code class="param">item</code> is the item found, <code class="param">val</code> is the <code>find</code> function argument.</p>
<p>The functor can change non-key fields of <code class="param">item</code>.</p>
<p>The type <code class="param">Q</code> can differ from <code class="param"><a class="el" href="#a2497aaa946640a16825e61d14a6d6189" title="value type stored in the set">value_type</a></code> of items storing in the container. Therefore, the <code class="param"><a class="el" href="#a2497aaa946640a16825e61d14a6d6189" title="value type stored in the set">value_type</a></code> should be comparable with type <code class="param">Q</code>.</p>
<p>The function returns <code class="param">true</code> if <code class="param">val</code> is found, <code class="param">false</code> otherwise. </p>

</div>
</div>
<a id="a7aaecb8e05cd335c57507c1a69ea3078" name="a7aaecb8e05cd335c57507c1a69ea3078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aaecb8e05cd335c57507c1a69ea3078">&#9670;&#160;</a></span>find_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate </p>
<p>The function is an analog of <a class="el" href="#cds_nonintrusive_StripedSet_find_func">find(Q&amp;, Func)</a> but <code class="param">pred</code> is used for key comparing <code class="param">Less</code> has the interface like <code class="param">std::less</code>. <code class="param">pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>注解</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code class="param">find_with</code> feature. </dd></dl>

</div>
</div>
<a id="a6a062a1d56946e140c120856be09b04a" name="a6a062a1d56946e140c120856be09b04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a062a1d56946e140c120856be09b04a">&#9670;&#160;</a></span>find_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Less, typename Func, typename Bucket = bucket_type, typename = typename std::enable_if&lt; Bucket::has_find_with &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::find_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Less</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_find.html">Find</a> the key <code class="param">val</code> using <code class="param">pred</code> predicate </p>
<p>The function is an analog of <a class="el" href="#cds_nonintrusive_StripedSet_find_cfunc">find(Q const&amp;, Func)</a> but <code class="param">pred</code> is used for key comparing <code class="param">Less</code> has the interface like <code class="param">std::less</code>. <code class="param">pred</code> must imply the same element order as the comparator used for building the set.</p>
<dl class="section note"><dt>注解</dt><dd>This function is enabled if the compiler supports C++11 default template arguments for function template <b>and</b> the underlying container supports <code class="param">find_with</code> feature. </dd></dl>

</div>
</div>
<a id="a9dd67e51632fa6661b0c242f6963b85d" name="a9dd67e51632fa6661b0c242f6963b85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd67e51632fa6661b0c242f6963b85d">&#9670;&#160;</a></span>get_resizing_policy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> &amp; <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::get_resizing_policy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns resizing policy object </p>

</div>
</div>
<a id="a0e5a5482b98e8971be6bbbe242904ec5" name="a0e5a5482b98e8971be6bbbe242904ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5a5482b98e8971be6bbbe242904ec5">&#9670;&#160;</a></span>get_resizing_policy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a132347759ae9e7929c5dc75a53890687">resizing_policy</a> const  &amp; <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::get_resizing_policy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns resizing policy (const version) </p>

</div>
</div>
<a id="aff8843b99b6f85ad37e9b4e4d920f523" name="aff8843b99b6f85ad37e9b4e4d920f523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8843b99b6f85ad37e9b4e4d920f523">&#9670;&#160;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node </p>
<p>The function creates a node with copy of <code class="param">val</code> value and then inserts the node created into the set.</p>
<p>The type <code class="param">Q</code> should contain as minimum the complete key for the node. The object of <code class="param"><a class="el" href="#a2497aaa946640a16825e61d14a6d6189" title="value type stored in the set">value_type</a></code> should be constructible from a value of type <code class="param">Q</code>. In trivial case, <code class="param">Q</code> is equal to <code class="param"><a class="el" href="#a2497aaa946640a16825e61d14a6d6189" title="value type stored in the set">value_type</a></code>.</p>
<p>Returns <code class="param">true</code> if <code class="param">val</code> is inserted into the set, <code class="param">false</code> otherwise. </p>

</div>
</div>
<a id="a6516d09d6a558712c1827bf57bd65b53" name="a6516d09d6a558712c1827bf57bd65b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6516d09d6a558712c1827bf57bd65b53">&#9670;&#160;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts new node </p>
<p>The function allows to split creating of new item into two part:</p><ul>
<li>create item with key only</li>
<li>insert new item into the set</li>
<li>if inserting is success, calls <code class="param">f</code> functor to initialize value-field of new item .</li>
</ul>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="benchmarks_2async__task_2async__task_8hpp.html#abce53bb5cc1ee70cdc013fd9b93547eb">func</a>( <a class="code hl_typedef" href="#a2497aaa946640a16825e61d14a6d6189">value_type</a>&amp; item );</div>
<div class="ttc" id="abenchmarks_2async__task_2async__task_8hpp_html_abce53bb5cc1ee70cdc013fd9b93547eb"><div class="ttname"><a href="benchmarks_2async__task_2async__task_8hpp.html#abce53bb5cc1ee70cdc013fd9b93547eb">func</a></div><div class="ttdeci">void func(std::atomic&lt; size_t &gt; &amp;counter)</div><div class="ttdef"><b>定义</b> async_task.hpp:13</div></div>
</div><!-- fragment --><p> where <code class="param">item</code> is the item inserted.</p>
<p>The type <code class="param">Q</code> can differ from <code class="param"><a class="el" href="#a2497aaa946640a16825e61d14a6d6189" title="value type stored in the set">value_type</a></code> of items storing in the set. Therefore, the <code class="param"><a class="el" href="#a2497aaa946640a16825e61d14a6d6189" title="value type stored in the set">value_type</a></code> should be constructible from type <code class="param">Q</code>.</p>
<p>The user-defined functor is called only if the inserting is success. </p>

</div>
</div>
<a id="ac40ae86014cc00810a3999531bd90f82" name="ac40ae86014cc00810a3999531bd90f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40ae86014cc00810a3999531bd90f82">&#9670;&#160;</a></span>lock_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::lock_count </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns lock array size </p>

</div>
</div>
<a id="a57316947488c56167c0a0b39907e90ec" name="a57316947488c56167c0a0b39907e90ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57316947488c56167c0a0b39907e90ec">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;<a class="el" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">::size</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns item count in the set </p>

</div>
</div>
<a id="ae7015cd2952dd86da2b035b34be624fd" name="ae7015cd2952dd86da2b035b34be624fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7015cd2952dd86da2b035b34be624fd">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container, typename... Options&gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>, typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>, <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> &gt; <a class="el" href="classcds_1_1container_1_1_striped_set.html">cds::container::StripedSet</a>&lt; Container, Options &gt;::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>bAllowInsert</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="yyjson_8h.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the node </p>
<p>The operation performs inserting or changing data with lock-free manner.</p>
<p>If <code class="param">key</code> is not found in the set, then <code class="param">key</code> is inserted iff <code class="param">bAllowInsert</code> is <code class="param">true</code>. Otherwise, the functor <code class="param">func</code> is called with item found.</p>
<p>The functor signature is: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structmy__functor.html">my_functor</a> {</div>
<div class="line">    <span class="keywordtype">void</span> operator()( <span class="keywordtype">bool</span> bNew, <a class="code hl_typedef" href="#a2497aaa946640a16825e61d14a6d6189">value_type</a>&amp; item, <span class="keyword">const</span> <a class="code hl_variable" href="_householder_q_r__householder_q_8cpp.html#a7e56035a736d269ad670f312496a0846">Q</a>&amp; val );</div>
<div class="line">};</div>
<div class="ttc" id="astructmy__functor_html"><div class="ttname"><a href="structmy__functor.html">my_functor</a></div><div class="ttdef"><b>定义</b> NumericalDiff.cpp:35</div></div>
</div><!-- fragment --><p> with arguments:</p><ul>
<li><code class="param">bNew</code> - <code class="param">true</code> if the item has been inserted, <code class="param">false</code> otherwise</li>
<li><code class="param">item</code> - item of the set</li>
<li><code class="param">val</code> - argument <code class="param">val</code> passed into the <code class="param">update</code>() function</li>
</ul>
<p>The functor may change non-key fields of the <code class="param">item</code>.</p>
<p>Returns <code> std::pair&lt;bool, bool&gt; </code> where <code class="param">first</code> is true if operation is successful, <code class="param">second</code> is true if new item has been added or <code class="param">false</code> if the item with <code class="param">key</code> already is in the map. </p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>external/libcds/cds/container/<a class="el" href="container_2striped__set_8h_source.html">striped_set.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1container.html">container</a></li><li class="navelem"><a class="el" href="classcds_1_1container_1_1_striped_set.html">StripedSet</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
