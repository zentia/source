<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: Writing efficient matrix product expressions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_topic_writing_efficient_product_expression.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Writing efficient matrix product expressions</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In general achieving good performance with <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> does no require any special effort: simply write your expressions in the most high level way. This is especially true for small fixed size matrices. For large matrices, however, it might be useful to take some care when writing your expressions in order to minimize useless evaluations and optimize the performance. In this page we will give a brief overview of the <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>'s internal mechanism to simplify and evaluate complex product expressions, and discuss the current limitations. In particular we will focus on expressions matching level 2 and 3 BLAS routines, i.e, all kind of matrix products and triangular solvers.</p>
<p>Indeed, in <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> we have implemented a set of highly optimized routines which are very similar to BLAS's ones. Unlike BLAS, those routines are made available to user via a high level and natural API. Each of these routines can compute in a single evaluation a wide variety of expressions. Given an expression, the challenge is then to map it to a minimal set of routines. As explained latter, this mechanism has some limitations, and knowing them will allow you to write faster code by making your expressions more <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> friendly.</p>
<h1><a class="anchor" id="GEMM"></a>
General Matrix-Matrix product (GEMM)</h1>
<p>Let's start with the most common primitive: the matrix product of general dense matrices. In the BLAS world this corresponds to the GEMM routine. Our equivalent primitive can perform the following operation: <picture><source srcset="form_23_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ C.noalias() += \alpha op1(A) op2(B) $" src="form_23.png"/></picture> where <a class="el" href="bench__gemm_8cpp.html#addc86e8508f14411ec98f521c520f875">A</a>, <a class="el" href="bench__gemm_8cpp.html#a37a83060ac796961b44991c836f083f7">B</a>, and C are column and/or row major matrices (or sub-matrices), alpha is a scalar value, and op1, op2 can be transpose, adjoint, conjugate, or the identity. When <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> detects a matrix product, it analyzes both sides of the product to extract a unique scalar factor alpha, and for each side, its effective storage order, shape, and conjugation states. More precisely each side is simplified by iteratively removing trivial expressions such as scalar multiple, negation and conjugation. <a class="el" href="class_eigen_1_1_transpose.html" title="Expression of the transpose of a matrix">Transpose</a> and <a class="el" href="class_eigen_1_1_block.html" title="Expression of a fixed-size or dynamic-size block">Block</a> expressions are not evaluated and they only modify the storage order and shape. All other expressions are immediately evaluated. For instance, the following expression: </p><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.noalias() -= <a class="code hl_enumvalue" href="test_8cpp.html#a21f4f7c5167375f4c94da96e76e944e2a7e7cb6814b74d6596098fc80127569a5">s4</a> * (<a class="code hl_enumvalue" href="test_8cpp.html#a699149a8a0361dd2130f512a98582e85a9aad8b8adbe6ec1aef47dba5064b8785">s1</a> * <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a>.adjoint() * (-(<a class="code hl_enumvalue" href="test_8cpp.html#a37b62beb33c3cd7f0dff8e168225f0d8ac0828e0381730befd1f7a025057c74fb">s3</a>*m3).<a class="code hl_function" href="_common_cwise_unary_ops_8h.html#acea5b38fcb99c3e0b91a43bfcca923ce">conjugate</a>()*<a class="code hl_enumvalue" href="test_8cpp.html#aa21f5b78c3b20ddd438dee22514b99e0a2ba65cf51dfe40e58e06095ee2c3fec4">s2</a>))  </div>
<div class="ttc" id="a_common_cwise_unary_ops_8h_html_acea5b38fcb99c3e0b91a43bfcca923ce"><div class="ttname"><a href="_common_cwise_unary_ops_8h.html#acea5b38fcb99c3e0b91a43bfcca923ce">conjugate</a></div><div class="ttdeci">EIGEN_DEVICE_FUNC ConjugateReturnType conjugate() const</div><div class="ttdef"><b>定义</b> CommonCwiseUnaryOps.h:74</div></div>
<div class="ttc" id="a_i_o_format_8cpp_html_ade6f22163da3c189aade978b48a8bb74"><div class="ttname"><a href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a></div><div class="ttdeci">Matrix3d m1</div><div class="ttdef"><b>定义</b> IOFormat.cpp:2</div></div>
<div class="ttc" id="a_tutorial___map__using_8cpp_html_ab3a01b595d22393ace0d30d5fa299f76"><div class="ttname"><a href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a></div><div class="ttdeci">MatrixType m2(n_dims)</div></div>
<div class="ttc" id="atest_8cpp_html_a21f4f7c5167375f4c94da96e76e944e2a7e7cb6814b74d6596098fc80127569a5"><div class="ttname"><a href="test_8cpp.html#a21f4f7c5167375f4c94da96e76e944e2a7e7cb6814b74d6596098fc80127569a5">lt4::s4</a></div><div class="ttdeci">@ s4</div><div class="ttdef"><b>定义</b> test.cpp:455</div></div>
<div class="ttc" id="atest_8cpp_html_a37b62beb33c3cd7f0dff8e168225f0d8ac0828e0381730befd1f7a025057c74fb"><div class="ttname"><a href="test_8cpp.html#a37b62beb33c3cd7f0dff8e168225f0d8ac0828e0381730befd1f7a025057c74fb">lt3::s3</a></div><div class="ttdeci">@ s3</div><div class="ttdef"><b>定义</b> test.cpp:454</div></div>
<div class="ttc" id="atest_8cpp_html_a699149a8a0361dd2130f512a98582e85a9aad8b8adbe6ec1aef47dba5064b8785"><div class="ttname"><a href="test_8cpp.html#a699149a8a0361dd2130f512a98582e85a9aad8b8adbe6ec1aef47dba5064b8785">s1</a></div><div class="ttdeci">@ s1</div><div class="ttdef"><b>定义</b> test.cpp:452</div></div>
<div class="ttc" id="atest_8cpp_html_aa21f5b78c3b20ddd438dee22514b99e0a2ba65cf51dfe40e58e06095ee2c3fec4"><div class="ttname"><a href="test_8cpp.html#aa21f5b78c3b20ddd438dee22514b99e0a2ba65cf51dfe40e58e06095ee2c3fec4">s2</a></div><div class="ttdeci">@ s2</div><div class="ttdef"><b>定义</b> test.cpp:453</div></div>
</div><!-- fragment --><p> is automatically simplified to: </p><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.noalias() += (<a class="code hl_enumvalue" href="test_8cpp.html#a699149a8a0361dd2130f512a98582e85a9aad8b8adbe6ec1aef47dba5064b8785">s1</a>*<a class="code hl_enumvalue" href="test_8cpp.html#aa21f5b78c3b20ddd438dee22514b99e0a2ba65cf51dfe40e58e06095ee2c3fec4">s2</a>*<a class="code hl_function" href="namespace_eigen.html#a065d353fcbff30a8e902d2900a784d45">conj</a>(<a class="code hl_enumvalue" href="test_8cpp.html#a37b62beb33c3cd7f0dff8e168225f0d8ac0828e0381730befd1f7a025057c74fb">s3</a>)*<a class="code hl_enumvalue" href="test_8cpp.html#a21f4f7c5167375f4c94da96e76e944e2a7e7cb6814b74d6596098fc80127569a5">s4</a>) * <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a>.adjoint() * m3.conjugate() </div>
<div class="ttc" id="anamespace_eigen_html_a065d353fcbff30a8e902d2900a784d45"><div class="ttname"><a href="namespace_eigen.html#a065d353fcbff30a8e902d2900a784d45">Eigen::conj</a></div><div class="ttdeci">const AutoDiffScalar&lt; DerType &gt; &amp; conj(const AutoDiffScalar&lt; DerType &gt; &amp;x)</div><div class="ttdef"><b>定义</b> AutoDiffScalar.h:543</div></div>
</div><!-- fragment --><p> which exactly matches our GEMM routine.</p>
<h2><a class="anchor" id="GEMM_Limitations"></a>
Limitations</h2>
<p>Unfortunately, this simplification mechanism is not perfect yet and not all expressions which could be handled by a single GEMM-like call are correctly detected. </p><table class="manual" style="width:100%">
<tr>
<th>Not optimal expression </th><th>Evaluated as </th><th>Optimal version (single evaluation) </th><th>Comments  </th></tr>
<tr>
<td><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a> += <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3; </div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">temp = <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3;</div>
<div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a> += temp; </div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.noalias() += <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3; </div>
</div><!-- fragment --> </td><td>Use .noalias() to tell <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> the result and right-hand-sides do not alias. Otherwise the product m2 * m3 is evaluated into a temporary.  </td></tr>
<tr class="alt">
<td></td><td></td><td><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.noalias() += <a class="code hl_enumvalue" href="test_8cpp.html#a699149a8a0361dd2130f512a98582e85a9aad8b8adbe6ec1aef47dba5064b8785">s1</a> * (<a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3); </div>
</div><!-- fragment --> </td><td>This is a special feature of <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>. Here the product between a scalar and a matrix product does not evaluate the matrix product but instead it returns a matrix product expression tracking the scalar scaling factor. <br  />
 Without this optimization, the matrix product would be evaluated into a temporary as in the next example.  </td></tr>
<tr>
<td><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.noalias() += (<a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3).<a class="code hl_function" href="adjoint_8cpp.html#a7333648f53414b05be9e4fd2f009fc22">adjoint</a>(); </div>
<div class="ttc" id="aadjoint_8cpp_html_a7333648f53414b05be9e4fd2f009fc22"><div class="ttname"><a href="adjoint_8cpp.html#a7333648f53414b05be9e4fd2f009fc22">adjoint</a></div><div class="ttdeci">void adjoint(const MatrixType &amp;m)</div><div class="ttdef"><b>定义</b> adjoint.cpp:67</div></div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">temp = <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3;</div>
<div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a> += temp.adjoint(); </div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.noalias() += m3.adjoint()</div>
<div class="line">               * <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a>.adjoint(); </div>
</div><!-- fragment --> </td><td>This is because the product expression has the EvalBeforeNesting bit which enforces the evaluation of the product by the Tranpose expression.  </td></tr>
<tr class="alt">
<td><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a> = <a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a> + <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3; </div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">temp = <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3;</div>
<div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a> = <a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a> + temp; </div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.noalias() += <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3; </div>
</div><!-- fragment --> </td><td>Here there is no way to detect at compile time that the two m1 are the same, and so the matrix product will be immediately evaluated.  </td></tr>
<tr>
<td><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.noalias() = m4 + <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3; </div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">temp = <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3;</div>
<div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a> = m4 + temp; </div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a> = m4;</div>
<div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.noalias() += <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a> * m3; </div>
</div><!-- fragment --> </td><td>First of all, here the .noalias() in the first expression is useless because m2*m3 will be evaluated anyway. However, note how this expression can be rewritten so that no temporary is required. (tip: for very small fixed size matrix it is slighlty better to rewrite it like this: m1.noalias() = m2 * m3; m1 += m4;  </td></tr>
<tr class="alt">
<td><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.noalias() += (<a class="code hl_enumvalue" href="test_8cpp.html#a699149a8a0361dd2130f512a98582e85a9aad8b8adbe6ec1aef47dba5064b8785">s1</a>*<a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a>).<a class="code hl_typedef" href="mimalloc_8h.html#af7f922b73e3acdb4a430b72f1a1334a5">block</a>(..) * m3; </div>
<div class="ttc" id="amimalloc_8h_html_af7f922b73e3acdb4a430b72f1a1334a5"><div class="ttname"><a href="mimalloc_8h.html#af7f922b73e3acdb4a430b72f1a1334a5">block</a></div><div class="ttdeci">const mi_heap_area_t void * block</div><div class="ttdoc">This is the const version of block(Index,Index,Index,Index). *‍/</div><div class="ttdef"><b>定义</b> mimalloc.h:265</div></div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line">temp = (<a class="code hl_enumvalue" href="test_8cpp.html#a699149a8a0361dd2130f512a98582e85a9aad8b8adbe6ec1aef47dba5064b8785">s1</a>*<a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a>).<a class="code hl_typedef" href="mimalloc_8h.html#af7f922b73e3acdb4a430b72f1a1334a5">block</a>(..);</div>
<div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a> += temp * m3; </div>
</div><!-- fragment --> </td><td><div class="fragment"><div class="line"><a class="code hl_variable" href="_i_o_format_8cpp.html#ade6f22163da3c189aade978b48a8bb74">m1</a>.noalias() += <a class="code hl_enumvalue" href="test_8cpp.html#a699149a8a0361dd2130f512a98582e85a9aad8b8adbe6ec1aef47dba5064b8785">s1</a> * <a class="code hl_function" href="_tutorial___map__using_8cpp.html#ab3a01b595d22393ace0d30d5fa299f76">m2</a>.block(..) * m3; </div>
</div><!-- fragment --> </td><td>This is because our expression analyzer is currently not able to extract trivial expressions nested in a <a class="el" href="class_eigen_1_1_block.html" title="Expression of a fixed-size or dynamic-size block">Block</a> expression. Therefore the nested scalar multiple cannot be properly extracted.  </td></tr>
</table>
<p>Of course all these remarks hold for all other kind of products involving triangular or selfadjoint matrices. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
