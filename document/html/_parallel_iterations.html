<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: Parallel Iterations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_parallel_iterations.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Parallel Iterations</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>目录</h3>
<ul>
  <li class="level1">
    <a href="#ParallelIterationsIncludeTheHeader">Include the Header</a>
  </li>
  <li class="level1">
    <a href="#A1IndexBasedParallelFor">Create an Index-based Parallel-Iteration Task</a>
  </li>
  <li class="level1">
    <a href="#ParallelForEachCaptureIndicesByReference">Capture Indices by Reference</a>
  </li>
  <li class="level1">
    <a href="#A1IteratorBasedParallelFor">Create an Iterator-based Parallel-Iteration Task</a>
  </li>
  <li class="level1">
    <a href="#ParallelForEachCaptureIteratorsByReference">Capture Iterators by Reference</a>
  </li>
  <li class="level1">
    <a href="#ParallelIterationsConfigureAPartitioner">Configure a Partitioner</a>
  </li>
</ul>
</div>
<div class="textblock"><p>Taskflow provides template functions for constructing tasks to perform parallel iterations over ranges of items.</p>
<h1><a class="anchor" id="ParallelIterationsIncludeTheHeader"></a>
Include the Header</h1>
<p>You need to include the header file, <code>taskflow/algorithm/for_each.hpp</code>, for using parallel-iteration algorithms.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="taskflow_2algorithm_2for__each_8hpp.html">taskflow/algorithm/for_each.hpp</a>&gt;</span></div>
<div class="ttc" id="ataskflow_2algorithm_2for__each_8hpp_html"><div class="ttname"><a href="taskflow_2algorithm_2for__each_8hpp.html">for_each.hpp</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="A1IndexBasedParallelFor"></a>
Create an Index-based Parallel-Iteration Task</h1>
<p>Index-based parallel-for performs parallel iterations over a range <code>[first, last)</code> with the given <code>step</code> size. The task created by <a class="el" href="classtf_1_1_flow_builder.html#a3b132bd902331a11b04b4ad66cf8bf77" title="constructs an index-based parallel-for task">tf::Taskflow::for_each_index(B first, E last, S step, C callable, P part)</a> represents parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="comment">// positive step</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=first; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;last; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>+=step) {</div>
<div class="line">  callable(<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// negative step</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=first; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&gt;last; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>+=step) {</div>
<div class="line">  callable(<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>);</div>
<div class="line">}</div>
<div class="ttc" id="a_bi_c_g_s_t_a_b__step__by__step_8cpp_html_acb559820d9ca11295b4500f179ef6392"><div class="ttname"><a href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a></div><div class="ttdeci">int i</div><div class="ttdef"><b>定义</b> BiCGSTAB_step_by_step.cpp:9</div></div>
</div><!-- fragment --><p>We support only integer-based range. The range can go positive or negative direction.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.for_each_index(0, 100,  2, [](<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>) { });  <span class="comment">// 50 loops with a + step</span></div>
<div class="line"><a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.for_each_index(100, 0, -2, [](<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>) { });  <span class="comment">// 50 loops with a - step</span></div>
<div class="ttc" id="apoisson_8hpp_html_aa56fe360bb0ae38e0082f49e394ff825"><div class="ttname"><a href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a></div><div class="ttdeci">void taskflow(int nx, int ny, double dx, double dy, double *f, int itold, int itnew, double *u, double *unew, int block_size, unsigned num_threads)</div><div class="ttdef"><b>定义</b> taskflow.cpp:6</div></div>
</div><!-- fragment --><p>Notice that either positive or negative direction is defined in terms of the range, <code>[first, last)</code>, where <code>end</code> is excluded. In the positive case, the 50 items are 0, 2, 4, 6, 8, ..., 96, 98. In the negative case, the 50 items are 100, 98, 96, 04, ... 4, 2. An example of the Taskflow graph for the positive case under 12 workers is depicted below:</p>
<p>Instead of explicitly specifying the index range and the callable for each index invocation, the overload <a class="el" href="classtf_1_1_flow_builder.html#a2582a216d54dacca2b7022ea7e89452a" title="constructs an index range-based parallel-for task">tf::Taskflow::for_each_by_index(R range, C callable, P part)</a> provides you with a more flexible way to iterate over subranges of indices. This overload uses <a class="el" href="classtf_1_1_index_range.html" title="class to create an index range of integral indices with a step size">tf::IndexRange</a> to partition the range into subranges, allowing finer control over how each subrange is processed. For instance, the code below does the same thing using two different approaches:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; data1(100), data2(100);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Approach 1: initialize data1 using explicit index range</span></div>
<div class="line"><a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.for_each_index(0, 100, 1, [&amp;](<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>){ data1[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = 10; });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Approach 2: initialize data2 using tf::IndexRange</span></div>
<div class="line"><a class="code hl_class" href="classtf_1_1_index_range.html">tf::IndexRange&lt;int&gt;</a> range(0, 100, 1);</div>
<div class="line"><a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.for_each_by_index(range, [&amp;](<a class="code hl_class" href="classtf_1_1_index_range.html">tf::IndexRange&lt;int&gt;</a> subrange){</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=subrange.<a class="code hl_function" href="classtf_1_1_index_range.html#a2b52381358ab392efa257e185a33d4af">begin</a>(); <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;subrange.<a class="code hl_function" href="classtf_1_1_index_range.html#a280096cb4056bc19b86da77d019434e4">end</a>(); <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>+=subrange.<a class="code hl_function" href="classtf_1_1_index_range.html#aafd4f2d04614e550649cd9b7912e0bf1">step_size</a>()) {</div>
<div class="line">    data2[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] = 10;</div>
<div class="line">  }</div>
<div class="line">});</div>
<div class="ttc" id="aclasstf_1_1_index_range_html"><div class="ttname"><a href="classtf_1_1_index_range.html">tf::IndexRange</a></div><div class="ttdoc">class to create an index range of integral indices with a step size</div><div class="ttdef"><b>定义</b> iterator.hpp:98</div></div>
<div class="ttc" id="aclasstf_1_1_index_range_html_a280096cb4056bc19b86da77d019434e4"><div class="ttname"><a href="classtf_1_1_index_range.html#a280096cb4056bc19b86da77d019434e4">tf::IndexRange::end</a></div><div class="ttdeci">T end() const</div><div class="ttdoc">queries the ending index of the range</div><div class="ttdef"><b>定义</b> iterator.hpp:131</div></div>
<div class="ttc" id="aclasstf_1_1_index_range_html_a2b52381358ab392efa257e185a33d4af"><div class="ttname"><a href="classtf_1_1_index_range.html#a2b52381358ab392efa257e185a33d4af">tf::IndexRange::begin</a></div><div class="ttdeci">T begin() const</div><div class="ttdoc">queries the starting index of the range</div><div class="ttdef"><b>定义</b> iterator.hpp:126</div></div>
<div class="ttc" id="aclasstf_1_1_index_range_html_aafd4f2d04614e550649cd9b7912e0bf1"><div class="ttname"><a href="classtf_1_1_index_range.html#aafd4f2d04614e550649cd9b7912e0bf1">tf::IndexRange::step_size</a></div><div class="ttdeci">T step_size() const</div><div class="ttdoc">queries the step size of the range</div><div class="ttdef"><b>定义</b> iterator.hpp:136</div></div>
</div><!-- fragment --><p>Both approaches produce the same result, but the second approach offers more flexibility in terms of how each partitioned subrange is iterated. This is particularly useful for applications that benefit from SIMD optimizations or other range-based processing strategies.</p>
<h1><a class="anchor" id="ParallelForEachCaptureIndicesByReference"></a>
Capture Indices by Reference</h1>
<p>You can pass indices by reference using @std_ref to marshal parameter update between dependent tasks. This is especially useful when the range indices are unknown at the time of creating a for-each-index task, but is initialized from another task.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>* <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>;</div>
<div class="line"><span class="keywordtype">int</span> first, last;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_struct" href="structinit.html">init</a> = <a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.emplace([&amp;](){</div>
<div class="line">  first = 0;</div>
<div class="line">  last  = 1000;</div>
<div class="line">  <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a> = <span class="keyword">new</span> <span class="keywordtype">int</span>[1000];  </div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> pf = <a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.for_each_index(std::ref(first), std::ref(last), 1, </div>
<div class="line">  [&amp;] (<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;parallel iteration on index &quot;</span> &lt;&lt; <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>[<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">  }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// wrong! must use std::ref, or first and last are captured by copy</span></div>
<div class="line"><span class="comment">// auto pf = taskflow.for_each_index(first, last, 1, [&amp;](int i) {</span></div>
<div class="line"><span class="comment">//   std::cout &lt;&lt; &quot;parallel iteration on index &quot; &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;</span></div>
<div class="line"><span class="comment">// });</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structinit.html">init</a>.precede(pf);</div>
<div class="ttc" id="abenchmarks_2for__each_2for__each_8hpp_html_ad86cbaae2e3f21959301250e9f7c2701"><div class="ttname"><a href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a></div><div class="ttdeci">std::vector&lt; double &gt; vec</div><div class="ttdef"><b>定义</b> for_each.hpp:14</div></div>
<div class="ttc" id="astructinit_html"><div class="ttname"><a href="structinit.html">init</a></div><div class="ttdef"><b>定义</b> TutorialInplaceLU.cpp:2</div></div>
</div><!-- fragment --><p>When <code>init</code> finishes, the parallel-for task <code>pf</code> will see <code>first</code> as 0 and <code>last</code> as 1000 and performs parallel iterations over the 1000 items.</p>
<h1><a class="anchor" id="A1IteratorBasedParallelFor"></a>
Create an Iterator-based Parallel-Iteration Task</h1>
<p>Iterator-based parallel-for performs parallel iterations over a range specified by two <a href="https://en.cppreference.com/w/cpp/iterator/iterator">STL-styled iterators</a>, <code>first</code> and <code>last</code>. The task created by <a class="el" href="classtf_1_1_flow_builder.html#aae3edfa278baa75b08414e083c14c836" title="constructs an STL-styled parallel-for task">tf::Taskflow::for_each(B first, E last, C callable, P part)</a> represents a parallel execution of the following loop:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>=first; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>&lt;last; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>++) {</div>
<div class="line">  callable(*<a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>tf::Taskflow::for_each(B first, E last, C callable, P&amp;&amp; part) simultaneously applies the callable to the object obtained by dereferencing every iterator in the range <code>[first, last)</code>. It is user's responsibility for ensuring the range is valid within the execution of the parallel-for task. Iterators must have the post-increment operator ++ defined.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a> = {1, 2, 3, 4, 5};</div>
<div class="line"><a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.for_each(<a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>.begin(), <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>.end(), [](<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>){ </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;parallel for on item &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&#39;\n&#39;</span>;  </div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">std::list&lt;std::string&gt; list = {<span class="stringliteral">&quot;hi&quot;</span>, <span class="stringliteral">&quot;from&quot;</span>, <span class="stringliteral">&quot;t&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;s&quot;</span>, <span class="stringliteral">&quot;k&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;low&quot;</span>};</div>
<div class="line"><a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.for_each(list.begin(), list.end(), [](<span class="keyword">const</span> std::string&amp; str){ </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;parallel for on item &quot;</span> &lt;&lt; str &lt;&lt; <span class="stringliteral">&#39;\n&#39;</span>;  </div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="ParallelForEachCaptureIteratorsByReference"></a>
Capture Iterators by Reference</h1>
<p>Similar to <a class="el" href="classtf_1_1_flow_builder.html#a3b132bd902331a11b04b4ad66cf8bf77" title="constructs an index-based parallel-for task">tf::Taskflow::for_each_index</a>, iterators of <a class="el" href="classtf_1_1_flow_builder.html#aae3edfa278baa75b08414e083c14c836" title="constructs an STL-styled parallel-for task">tf::Taskflow::for_each</a> are templated to allow capturing range parameters by reference, such that one task can set up the range before another task performs the parallel-for algorithm. For example:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>;</div>
<div class="line">std::vector&lt;int&gt;::iterator first, last;;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classtf_1_1_task.html">tf::Task</a> <a class="code hl_struct" href="structinit.html">init</a> = <a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.emplace([&amp;](){</div>
<div class="line">  <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>.resize(1000);</div>
<div class="line">  first = <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>.begin();</div>
<div class="line">  last  = <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>.end();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classtf_1_1_task.html">tf::Task</a> pf = <a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.for_each(std::ref(first), std::ref(last), [&amp;](<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>) {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;parallel iteration on item &quot;</span> &lt;&lt; <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a> &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// wrong! must use std::ref, or first and last are captured by copy</span></div>
<div class="line"><span class="comment">// tf::Task pf = taskflow.for_each(first, last, [&amp;](int i) {</span></div>
<div class="line"><span class="comment">//   std::cout &lt;&lt; &quot;parallel iteration on item &quot; &lt;&lt; i &lt;&lt; &#39;\n&#39;;</span></div>
<div class="line"><span class="comment">// });</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structinit.html">init</a>.precede(pf);</div>
<div class="ttc" id="aclasstf_1_1_task_html"><div class="ttname"><a href="classtf_1_1_task.html">tf::Task</a></div><div class="ttdoc">class to create a task handle over a node in a taskflow graph</div><div class="ttdef"><b>定义</b> task.hpp:150</div></div>
</div><!-- fragment --><p>When <code>init</code> finishes, the parallel-for task <code>pf</code> will see <code>first</code> pointing to the beginning of <code>vec</code> and <code>last</code> pointing to the end of <code>vec</code> and performs parallel iterations over the 1000 items. The two tasks form an end-to-end task graph where the parameters of parallel-for are computed on the fly.</p>
<h1><a class="anchor" id="ParallelIterationsConfigureAPartitioner"></a>
Configure a Partitioner</h1>
<p>You can configure a partitioner for parallel-iteration tasks to run with different scheduling methods, such as guided partitioning, dynamic partitioning, and static partitioning. The following example creates two parallel-iteration tasks using two different partitioners, one with the static partitioning algorithm and another one with the guided partitioning algorithm:</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>(1024, 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create two partitioners with a chunk size of 10</span></div>
<div class="line"><a class="code hl_class" href="classtf_1_1_static_partitioner.html">tf::StaticPartitioner</a> static_partitioner(10);</div>
<div class="line"><a class="code hl_class" href="classtf_1_1_guided_partitioner.html">tf::GuidedPartitioner</a> guided_partitioner(10);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a parallel-iteration task with static partitioner</span></div>
<div class="line"><a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.for_each(</div>
<div class="line">  <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>.begin(), <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>.end(), [&amp;](<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;parallel iteration on item &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&#39;\n&#39;</span>;</div>
<div class="line">  },</div>
<div class="line">  static_partitioner</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a parallel-iteration task with guided partitioner</span></div>
<div class="line"><a class="code hl_function" href="poisson_8hpp.html#aa56fe360bb0ae38e0082f49e394ff825">taskflow</a>.for_each(</div>
<div class="line">  <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>.begin(), <a class="code hl_variable" href="benchmarks_2for__each_2for__each_8hpp.html#ad86cbaae2e3f21959301250e9f7c2701">vec</a>.end(), [&amp;](<span class="keywordtype">int</span> <a class="code hl_variable" href="_bi_c_g_s_t_a_b__step__by__step_8cpp.html#acb559820d9ca11295b4500f179ef6392">i</a>) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;parallel iteration on item &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&#39;\n&#39;</span>;</div>
<div class="line">  },</div>
<div class="line">  guided_partitioner</div>
<div class="line">);</div>
<div class="ttc" id="aclasstf_1_1_guided_partitioner_html"><div class="ttname"><a href="classtf_1_1_guided_partitioner.html">tf::GuidedPartitioner</a></div><div class="ttdoc">class to construct a guided partitioner for scheduling parallel algorithms</div><div class="ttdef"><b>定义</b> partitioner.hpp:259</div></div>
<div class="ttc" id="aclasstf_1_1_static_partitioner_html"><div class="ttname"><a href="classtf_1_1_static_partitioner.html">tf::StaticPartitioner</a></div><div class="ttdoc">class to construct a static partitioner for scheduling parallel algorithms</div><div class="ttdef"><b>定义</b> partitioner.hpp:560</div></div>
</div><!-- fragment --><dl class="section attention"><dt>注意</dt><dd>By default, parallel-iteration tasks use <a class="el" href="namespacetf.html#ace2c5adcd5039483eebb6dbdbb6f33e3" title="default partitioner set to tf::GuidedPartitioner">tf::DefaultPartitioner</a> if no partitioner is specified. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
