<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>source: cds::urcu::general_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt; 模板类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">source
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="搜索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classcds_1_1urcu_1_1general__threaded.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public 类型</a> &#124;
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="classcds_1_1urcu_1_1general__threaded-members.html">所有成员列表</a>  </div>
  <div class="headertitle"><div class="title">cds::urcu::general_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt; 模板类 参考</div></div>
</div><!--header-->
<div class="contents">

<p>User-space general-purpose RCU with deferred threaded reclamation  
 <a href="#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="general__threaded_8h_source.html">cds/urcu/general_threaded.h</a>&gt;</code></p>
<div class="dynheader">
类 cds::urcu::general_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt; 继承关系图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1urcu_1_1general__threaded__inherit__graph.png" border="0" usemap="#acds_1_1urcu_1_1general__threaded_3_01_buffer_00_01_lock_00_01_disposer_thread_00_01_backoff_01_4_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<div class="dynheader">
cds::urcu::general_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt; 的协作图:</div>
<div class="dyncontent">
<div class="center"><img src="classcds_1_1urcu_1_1general__threaded__coll__graph.png" border="0" usemap="#acds_1_1urcu_1_1general__threaded_3_01_buffer_00_01_lock_00_01_disposer_thread_00_01_backoff_01_4_coll__map" alt="Collaboration graph"/></div>
<!-- MAP 1 -->
<center><span class="legend">[<a target="top" href="graph_legend.html">图例</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:afa8bfda3080555858eb590730a5f8628" id="r_afa8bfda3080555858eb590730a5f8628"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_buffer.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa8bfda3080555858eb590730a5f8628">buffer_type</a></td></tr>
<tr class="memdesc:afa8bfda3080555858eb590730a5f8628"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_buffer.html">Buffer</a> type  <br /></td></tr>
<tr class="separator:afa8bfda3080555858eb590730a5f8628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3acd914549dfb0ae2267ada1a54ea1" id="r_adc3acd914549dfb0ae2267ada1a54ea1"><td class="memItemLeft" align="right" valign="top">typedef Lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc3acd914549dfb0ae2267ada1a54ea1">lock_type</a></td></tr>
<tr class="memdesc:adc3acd914549dfb0ae2267ada1a54ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock type  <br /></td></tr>
<tr class="separator:adc3acd914549dfb0ae2267ada1a54ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738eeba04354d08ca2a4d61e01157422" id="r_a738eeba04354d08ca2a4d61e01157422"><td class="memItemLeft" align="right" valign="top">typedef Backoff&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a738eeba04354d08ca2a4d61e01157422">back_off</a></td></tr>
<tr class="memdesc:a738eeba04354d08ca2a4d61e01157422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Back-off scheme  <br /></td></tr>
<tr class="separator:a738eeba04354d08ca2a4d61e01157422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ece49571f8b5690efaebc5fb31b8b88" id="r_a3ece49571f8b5690efaebc5fb31b8b88"><td class="memItemLeft" align="right" valign="top">typedef DisposerThread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ece49571f8b5690efaebc5fb31b8b88">disposer_thread</a></td></tr>
<tr class="memdesc:a3ece49571f8b5690efaebc5fb31b8b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disposer thread type  <br /></td></tr>
<tr class="separator:a3ece49571f8b5690efaebc5fb31b8b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a159a7acb8e823ab43acb17141b856b" id="r_a8a159a7acb8e823ab43acb17141b856b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structcds_1_1urcu_1_1general__threaded__tag.html">general_threaded_tag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a159a7acb8e823ab43acb17141b856b">rcu_tag</a></td></tr>
<tr class="memdesc:a8a159a7acb8e823ab43acb17141b856b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-side RCU part  <br /></td></tr>
<tr class="separator:a8a159a7acb8e823ab43acb17141b856b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462bb1c532fbb35161f92be90f2f5b34" id="r_a462bb1c532fbb35161f92be90f2f5b34"><td class="memItemLeft" align="right" valign="top">typedef base_class::thread_gc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a462bb1c532fbb35161f92be90f2f5b34">thread_gc</a></td></tr>
<tr class="memdesc:a462bb1c532fbb35161f92be90f2f5b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access lock class  <br /></td></tr>
<tr class="separator:a462bb1c532fbb35161f92be90f2f5b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08414197934e6efe5d4634646bdca332" id="r_a08414197934e6efe5d4634646bdca332"><td class="memItemLeft" align="right" valign="top">typedef thread_gc::scoped_lock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08414197934e6efe5d4634646bdca332">scoped_lock</a></td></tr>
<tr class="memdesc:a08414197934e6efe5d4634646bdca332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access lock class  <br /></td></tr>
<tr class="separator:a08414197934e6efe5d4634646bdca332"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a3235164a97b7818e3b57c69e174c8e28" id="r_a3235164a97b7818e3b57c69e174c8e28"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3235164a97b7818e3b57c69e174c8e28">retire_ptr</a> (<a class="el" href="namespacecds_1_1urcu.html#a9fd06318cc85d4d956ba7fb8152083c1">retired_ptr</a> &amp;<a class="el" href="main-override_8cpp.html#a117104b82864d3b23ec174af6d392709">p</a>) override</td></tr>
<tr class="memdesc:a3235164a97b7818e3b57c69e174c8e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retires <code class="param">p</code> pointer  <br /></td></tr>
<tr class="separator:a3235164a97b7818e3b57c69e174c8e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671875895d999ef51585e4a13d193bb1" id="r_a671875895d999ef51585e4a13d193bb1"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr class="memitem:a671875895d999ef51585e4a13d193bb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a671875895d999ef51585e4a13d193bb1">batch_retire</a> (ForwardIterator itFirst, ForwardIterator itLast)</td></tr>
<tr class="memdesc:a671875895d999ef51585e4a13d193bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retires the pointer chain [<code class="param">itFirst</code>, <code class="param">itLast</code>)  <br /></td></tr>
<tr class="separator:a671875895d999ef51585e4a13d193bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5881551f0feab62b3865892b603afbf5" id="r_a5881551f0feab62b3865892b603afbf5"><td class="memTemplParams" colspan="2">template&lt;typename Func&gt; </td></tr>
<tr class="memitem:a5881551f0feab62b3865892b603afbf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5881551f0feab62b3865892b603afbf5">batch_retire</a> (Func <a class="el" href="_cwise__array__power__array_8cpp.html#a9cb86ff854760bf91a154f2724a9101d">e</a>)</td></tr>
<tr class="memdesc:a5881551f0feab62b3865892b603afbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retires the pointer chain until <code class="param">Func</code> returns <code class="param">nullptr</code> retired pointer  <br /></td></tr>
<tr class="separator:a5881551f0feab62b3865892b603afbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd92691234888a31059b578821d272a" id="r_addd92691234888a31059b578821d272a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addd92691234888a31059b578821d272a">synchronize</a> ()</td></tr>
<tr class="memdesc:addd92691234888a31059b578821d272a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits to finish a grace period and calls disposing thread  <br /></td></tr>
<tr class="separator:addd92691234888a31059b578821d272a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea96b2165e8479c18aeffd2fe0bfad78" id="r_aea96b2165e8479c18aeffd2fe0bfad78"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea96b2165e8479c18aeffd2fe0bfad78">capacity</a> () const</td></tr>
<tr class="memdesc:aea96b2165e8479c18aeffd2fe0bfad78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the threshold of internal buffer  <br /></td></tr>
<tr class="separator:aea96b2165e8479c18aeffd2fe0bfad78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:a905811bc82c2ff7d61385d6fc21f77ce" id="r_a905811bc82c2ff7d61385d6fc21f77ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">general_threaded</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a905811bc82c2ff7d61385d6fc21f77ce">instance</a> ()</td></tr>
<tr class="memdesc:a905811bc82c2ff7d61385d6fc21f77ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns singleton instance  <br /></td></tr>
<tr class="separator:a905811bc82c2ff7d61385d6fc21f77ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d161c6819c1e175f7ae386789f6efd" id="r_a63d161c6819c1e175f7ae386789f6efd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63d161c6819c1e175f7ae386789f6efd">isUsed</a> ()</td></tr>
<tr class="memdesc:a63d161c6819c1e175f7ae386789f6efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the singleton is created and ready to use  <br /></td></tr>
<tr class="separator:a63d161c6819c1e175f7ae386789f6efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1023b1984b3c48bf973a24dbeb563de9" id="r_a1023b1984b3c48bf973a24dbeb563de9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1023b1984b3c48bf973a24dbeb563de9">Construct</a> (size_t nBufferCapacity=256)</td></tr>
<tr class="memdesc:a1023b1984b3c48bf973a24dbeb563de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates singleton object and starts reclamation thread  <br /></td></tr>
<tr class="separator:a1023b1984b3c48bf973a24dbeb563de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218aeb0c7b969bed2f630446c0d887d5" id="r_a218aeb0c7b969bed2f630446c0d887d5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a218aeb0c7b969bed2f630446c0d887d5">Destruct</a> (<a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> bDetachAll=<a class="el" href="yyjson_8h.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:a218aeb0c7b969bed2f630446c0d887d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys singleton object and terminates internal reclamation thread  <br /></td></tr>
<tr class="separator:a218aeb0c7b969bed2f630446c0d887d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt;<br />
class cds::urcu::general_threaded&lt; Buffer, Lock, DisposerThread, Backoff &gt;</div><p>User-space general-purpose RCU with deferred threaded reclamation </p>
<p>This implementation is similar to <a class="el" href="classcds_1_1urcu_1_1general__buffered.html">general_buffered</a> but separate thread is created for deleting the retired objects. Like <code class="param">general_buffered</code>, the class contains an internal buffer where retired objects are accumulated. When the buffer becomes full, the RCU <code class="param"><a class="el" href="#addd92691234888a31059b578821d272a" title="Waits to finish a grace period and calls disposing thread">synchronize()</a></code> function is called that waits until all reader/updater threads end up their read-side critical sections, i.e. until the RCU quiescent state will come. After that the "work ready" message is sent to reclamation thread. The reclamation thread frees the buffer. This synchronization cycle may be called in any thread that calls <code class="param"><a class="el" href="#a3235164a97b7818e3b57c69e174c8e28" title="Retires p pointer">retire_ptr()</a></code> function.</p>
<p>There is a wrapper <a class="el" href="classcds_1_1urcu_1_1gc_3_01general__threaded_3_01_buffer_00_01_lock_00_01_disposer_thread_00_01_backoff_01_4_01_4.html#cds_urcu_general_threaded_gc">gc&lt;general_threaded&gt;</a> for <code class="param">general_threaded</code> class that provides unified RCU interface. You should use this wrapper class instead <code class="param">general_threaded</code> </p>
<p>The <code class="param"><a class="el" href="struct_buffer.html">Buffer</a></code> contains items of <a class="el" href="namespacecds_1_1urcu.html#cds_urcu_retired_ptr">epoch_retired_ptr</a> type</p>
<p>and it should support a multiple producer/single consumer queue with the following interface:</p><ul>
<li><code> bool push( epoch_retired_ptr&amp; p ) </code> - places the retired pointer <code class="param">p</code> into queue. If the function returns <code class="param">false</code> it means that the buffer is full and RCU synchronization cycle must be processed.</li>
<li><code><a class="el" href="structcds_1_1urcu_1_1epoch__retired__ptr.html" title="Epoch-based retired ptr">epoch_retired_ptr</a> * front() </code> - returns a pointer to the top element or <code class="param">nullptr</code> if the buffer is empty.</li>
<li><code>bool pop_front() </code> - pops the top element; returns <code class="param">false</code> if the buffer is empty.</li>
<li><code>size_t <a class="el" href="imgui__impl__opengl3__loader_8h.html#ac42c05b5701aef6bab82675cf3b55fee">size()</a></code> - returns queue's item count.</li>
</ul>
<p>The buffer is considered as full if <code class="param"><a class="el" href="test__concurrent__queue_8cpp.html#a262227aa72b9cc1db7b9a80d7f295211">push()</a></code> returns <code class="param">false</code> or the buffer size reaches the RCU threshold.</p>
<p>Template arguments:</p><ul>
<li><p class="startli"><code class="param"><a class="el" href="struct_buffer.html">Buffer</a></code> - MPSC (muliple producer/single consumer) buffer type with FIFO semantics.</p>
<p class="startli">Default is <code class="param"><a class="el" href="namespacecds_1_1container.html#af611ea3db0802913eb8dafdb6dda8c0f" title="Vyukov&#39;s queue multiple producer - single consumer version">cds::container::VyukovMPSCCycleQueue</a></code>. The buffer contains the objects of <a class="el" href="structcds_1_1urcu_1_1epoch__retired__ptr.html">epoch_retired_ptr</a> type that contains additional <code class="param">m_nEpoch</code> field. This field specifies an epoch when the object has been placed into the buffer. The <code class="param">general_threaded</code> object has a global epoch counter that is incremented on each <code class="param"><a class="el" href="#addd92691234888a31059b578821d272a" title="Waits to finish a grace period and calls disposing thread">synchronize()</a></code> call. The epoch is used internally to prevent early deletion.</p>
</li>
<li><code class="param">Lock</code> - mutex type, default is <code class="param">std::mutex</code> </li>
<li><code class="param">DisposerThread</code> - the reclamation thread class. Default is <a class="el" href="classcds_1_1urcu_1_1dispose__thread.html">cds::urcu::dispose_thread</a>, see the description of this class for required interface.</li>
<li><code class="param">Backoff</code> - back-off schema, default is <a class="el" href="namespacecds_1_1backoff.html#a0f64f7bc371e3ad006fba5bd855d6e96" title="Default backoff strategy">cds::backoff::Default</a> </li>
</ul>
</div><h2 class="groupheader">成员类型定义说明</h2>
<a id="a738eeba04354d08ca2a4d61e01157422" name="a738eeba04354d08ca2a4d61e01157422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738eeba04354d08ca2a4d61e01157422">&#9670;&#160;</a></span>back_off</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Backoff <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::back_off</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Back-off scheme </p>

</div>
</div>
<a id="afa8bfda3080555858eb590730a5f8628" name="afa8bfda3080555858eb590730a5f8628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8bfda3080555858eb590730a5f8628">&#9670;&#160;</a></span>buffer_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_buffer.html">Buffer</a> <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::buffer_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="struct_buffer.html">Buffer</a> type </p>

</div>
</div>
<a id="a3ece49571f8b5690efaebc5fb31b8b88" name="a3ece49571f8b5690efaebc5fb31b8b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ece49571f8b5690efaebc5fb31b8b88">&#9670;&#160;</a></span>disposer_thread</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef DisposerThread <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::disposer_thread</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disposer thread type </p>

</div>
</div>
<a id="adc3acd914549dfb0ae2267ada1a54ea1" name="adc3acd914549dfb0ae2267ada1a54ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3acd914549dfb0ae2267ada1a54ea1">&#9670;&#160;</a></span>lock_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Lock <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::lock_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock type </p>

</div>
</div>
<a id="a8a159a7acb8e823ab43acb17141b856b" name="a8a159a7acb8e823ab43acb17141b856b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a159a7acb8e823ab43acb17141b856b">&#9670;&#160;</a></span>rcu_tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcds_1_1urcu_1_1general__threaded__tag.html">general_threaded_tag</a> <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::rcu_tag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread-side RCU part </p>

</div>
</div>
<a id="a08414197934e6efe5d4634646bdca332" name="a08414197934e6efe5d4634646bdca332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08414197934e6efe5d4634646bdca332">&#9670;&#160;</a></span>scoped_lock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef thread_gc::scoped_lock <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::scoped_lock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access lock class </p>

</div>
</div>
<a id="a462bb1c532fbb35161f92be90f2f5b34" name="a462bb1c532fbb35161f92be90f2f5b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462bb1c532fbb35161f92be90f2f5b34">&#9670;&#160;</a></span>thread_gc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef base_class::thread_gc <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::thread_gc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access lock class </p>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a671875895d999ef51585e4a13d193bb1" name="a671875895d999ef51585e4a13d193bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671875895d999ef51585e4a13d193bb1">&#9670;&#160;</a></span>batch_retire() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a> <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::batch_retire </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator</td>          <td class="paramname"><span class="paramname"><em>itFirst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator</td>          <td class="paramname"><span class="paramname"><em>itLast</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retires the pointer chain [<code class="param">itFirst</code>, <code class="param">itLast</code>) </p>

</div>
</div>
<a id="a5881551f0feab62b3865892b603afbf5" name="a5881551f0feab62b3865892b603afbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5881551f0feab62b3865892b603afbf5">&#9670;&#160;</a></span>batch_retire() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
<div class="memtemplate">
template&lt;typename Func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a> <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::batch_retire </td>
          <td>(</td>
          <td class="paramtype">Func</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retires the pointer chain until <code class="param">Func</code> returns <code class="param">nullptr</code> retired pointer </p>

</div>
</div>
<a id="aea96b2165e8479c18aeffd2fe0bfad78" name="aea96b2165e8479c18aeffd2fe0bfad78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea96b2165e8479c18aeffd2fe0bfad78">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the threshold of internal buffer </p>

</div>
</div>
<a id="a1023b1984b3c48bf973a24dbeb563de9" name="a1023b1984b3c48bf973a24dbeb563de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1023b1984b3c48bf973a24dbeb563de9">&#9670;&#160;</a></span>Construct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a> <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::Construct </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nBufferCapacity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">256</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates singleton object and starts reclamation thread </p>
<p>The <code class="param">nBufferCapacity</code> parameter defines RCU threshold. </p>

</div>
</div>
<a id="a218aeb0c7b969bed2f630446c0d887d5" name="a218aeb0c7b969bed2f630446c0d887d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218aeb0c7b969bed2f630446c0d887d5">&#9670;&#160;</a></span>Destruct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a> <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::Destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a></td>          <td class="paramname"><span class="paramname"><em>bDetachAll</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="yyjson_8h.html#a65e9886d74aaee76545e83dd09011727">false</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys singleton object and terminates internal reclamation thread </p>

</div>
</div>
<a id="a905811bc82c2ff7d61385d6fc21f77ce" name="a905811bc82c2ff7d61385d6fc21f77ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905811bc82c2ff7d61385d6fc21f77ce">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">general_threaded</a> * <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::instance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns singleton instance </p>

</div>
</div>
<a id="a63d161c6819c1e175f7ae386789f6efd" name="a63d161c6819c1e175f7ae386789f6efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d161c6819c1e175f7ae386789f6efd">&#9670;&#160;</a></span>isUsed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="sugar_8h.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::isUsed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the singleton is created and ready to use </p>

</div>
</div>
<a id="a3235164a97b7818e3b57c69e174c8e28" name="a3235164a97b7818e3b57c69e174c8e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3235164a97b7818e3b57c69e174c8e28">&#9670;&#160;</a></span>retire_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a> <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::retire_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecds_1_1urcu.html#a9fd06318cc85d4d956ba7fb8152083c1">retired_ptr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retires <code class="param">p</code> pointer </p>
<p>The method pushes <code class="param">p</code> pointer to internal buffer. When the buffer becomes full <a class="el" href="#addd92691234888a31059b578821d272a">synchronize</a> function is called to wait for the end of grace period and then a message is sent to the reclamation thread. </p>

</div>
</div>
<a id="addd92691234888a31059b578821d272a" name="addd92691234888a31059b578821d272a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd92691234888a31059b578821d272a">&#9670;&#160;</a></span>synchronize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="struct_buffer.html">Buffer</a> = cds::container::VyukovMPSCCycleQueue&lt; epoch_retired_ptr &gt;, class Lock = std::mutex, class DisposerThread = dispose_thread&lt;Buffer&gt;, class Backoff = cds::backoff::Default&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ittnotify__static_8h.html#a61af67d9d838a9497ca5b188dabc1aa0">void</a> <a class="el" href="classcds_1_1urcu_1_1general__threaded.html">cds::urcu::general_threaded</a>&lt; <a class="el" href="struct_buffer.html">Buffer</a>, Lock, DisposerThread, Backoff &gt;::synchronize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits to finish a grace period and calls disposing thread </p>

</div>
</div>
<hr/>该类的文档由以下文件生成:<ul>
<li>external/libcds/cds/urcu/details/<a class="el" href="gpt_8h_source.html">gpt.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecds.html">cds</a></li><li class="navelem"><a class="el" href="namespacecds_1_1urcu.html">urcu</a></li><li class="navelem"><a class="el" href="classcds_1_1urcu_1_1general__threaded.html">general_threaded</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
