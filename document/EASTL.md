下面是一个清单，描述为什么STL不适合游戏开发：

一些 STL 实现（尤其是 Microsoft STL）具有较差的性能特征，使其不适合游戏开发。EASTL 比所有现有的 STL 实现都快。
STL 有时很难调试，因为大多数 STL 实现使用神秘的变量名和不寻常的数据结构。
STL 分配器有时很难使用，因为它们有很多要求，并且一旦绑定到容器就不能修改。
STL 包含过多的功能，可能导致代码量超出预期。告诉程序员他们不应该使用该功能并不容易。
STL 是通过非常深入的函数调用实现的。这导致在非优化构建中的性能不可接受，有时在优化构建中也是如此。
STL 不支持包含对象的对齐。
STL 容器不允许您在不提供要从中复制的条目的情况下将条目插入容器。这可能是低效的。
在现有的 STL 实现（例如 STLPort）中发现的有用的 STL 扩展（例如 slist、hash_map、shared_ptr）是不可移植的，因为它们在其他版本的 STL 中不存在或者在 STL 版本之间不一致。
STL 缺少游戏程序员认为有用的扩展（例如 intrusive_list），但在可移植的 STL 环境中可以得到最佳优化。
STL 的规范限制了我们有效使用它的能力。例如，STL 向量不能保证使用连续内存，因此不能安全地用作数组。
STL 在性能之前强调正确性，而有时您可以通过降低学术纯粹性来获得显着的性能提升。
STL 容器具有私有实现，不允许您以可移植的方式处理它们的数据，但有时这是一件很重要的事情（例如节点池）。
所有现有版本的 STL 至少在其某些容器的空版本中分配内存。这并不理想，并且会阻止诸如容器内存重置之类的优化，这些优化可以在某些情况下大大提高性能。
STL 的编译速度很慢，因为大多数现代 STL 实现都非常大。
有一些法律问题使我们很难自由使用 STLPort 等可移植的 STL 实现。
我们对 STL 的设计和实现没有发言权，因此无法对其进行更改以满足我们的需求。
评价
总的来讲，STL注重的是标准，EASTL注重的是在游戏开发中的实践和性能
