\doxysection{eastl\+::move\+\_\+and\+\_\+copy\+\_\+helper\texorpdfstring{$<$}{<} typename, bool, bool \texorpdfstring{$>$}{>} 模板结构体 参考}
\hypertarget{structeastl_1_1move__and__copy__helper}{}\label{structeastl_1_1move__and__copy__helper}\index{eastl::move\_and\_copy\_helper$<$ typename, bool, bool $>$@{eastl::move\_and\_copy\_helper$<$ typename, bool, bool $>$}}


{\ttfamily \#include $<$copy\+\_\+help.\+h$>$}

\doxysubsubsection*{静态 Public 成员函数}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Input\+Iterator, typename Output\+Iterator$>$ }\\static Output\+Iterator \mbox{\hyperlink{structeastl_1_1move__and__copy__helper_aa9de7d135fbe5ddb02a94513283cf77b}{move\+\_\+or\+\_\+copy}} (Input\+Iterator first, Input\+Iterator last, Output\+Iterator \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}})
\end{DoxyCompactItemize}


\doxysubsection{详细描述}
\subsubsection*{template$<$typename, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}$>$\newline
struct eastl\+::move\+\_\+and\+\_\+copy\+\_\+helper$<$ typename, bool, bool $>$}
move / move\+\_\+n / move\+\_\+backward copy / copy\+\_\+n / copy\+\_\+backward

We want to optimize move, move\+\_\+n, move\+\_\+backward, copy, copy\+\_\+backward, copy\+\_\+n to do memmove operations when possible.

We could possibly use memcpy, though it has stricter overlap requirements than the move and copy algorithms and would require a runtime if/else to choose it over memmove. In particular, memcpy allows no range overlap at all, whereas move/copy allow output end overlap and move\+\_\+backward/copy\+\_\+backward allow output begin overlap. Despite this it might be useful to use memcpy for any platforms where memcpy is significantly faster than memmove, and since in most cases the copy/move operation in fact doesn\textquotesingle{}t target overlapping memory and so memcpy would be usable.

We can use memmove/memcpy if the following hold true\+: Input\+Iterator and Output\+Iterator have the same value type. Input\+Iterator and Output\+Iterator are of type \doxylink{structeastl_1_1contiguous__iterator__tag}{contiguous\+\_\+iterator\+\_\+tag} or simply are pointers (the two are virtually synonymous). \doxylink{structeastl_1_1is__trivially__copyable_abaea9b2b4bdc9cbbd24e6fad3c4d606a}{is\+\_\+trivially\+\_\+copyable$<$\+T$>$\+::value} is true. i.\+e. from the standard (\href{http://www.eel.is/c++draft/basic.types.general\#2}{\texttt{ http\+://www.\+eel.\+is/c++draft/basic.\+types.\+general\#2}})\+: For any object (other than a potentially-\/overlapping subobject) of trivially copyable type T, whether or not the object holds a valid value of type T, the underlying bytes making up the object can be copied into an array of char, unsigned char, or std\+::byte \mbox{[}footnote\+: By using, for example, the library functions std\+::memcpy or std\+::memmove\mbox{]}.

copy normally differs from move, but there is a case where copy is the same as move\+: when copy is used with a \doxylink{classeastl_1_1move__iterator}{move\+\_\+iterator}. We handle that case here by detecting that copy is being done with a \doxylink{classeastl_1_1move__iterator}{move\+\_\+iterator} and redirect it to move (which can take advantage of memmove/memcpy).

The \doxylink{classeastl_1_1generic__iterator}{generic\+\_\+iterator} class is typically used for wrapping raw memory pointers so they can act like formal iterators. Since pointers provide an opportunity for memmove/memcpy operations, we can detect a generic iterator and use it\textquotesingle{}s wrapped type as a pointer if it happens to be one. 

\doxysubsection{成员函数说明}
\Hypertarget{structeastl_1_1move__and__copy__helper_aa9de7d135fbe5ddb02a94513283cf77b}\index{eastl::move\_and\_copy\_helper$<$ typename, bool, bool $>$@{eastl::move\_and\_copy\_helper$<$ typename, bool, bool $>$}!move\_or\_copy@{move\_or\_copy}}
\index{move\_or\_copy@{move\_or\_copy}!eastl::move\_and\_copy\_helper$<$ typename, bool, bool $>$@{eastl::move\_and\_copy\_helper$<$ typename, bool, bool $>$}}
\doxysubsubsection{\texorpdfstring{move\_or\_copy()}{move\_or\_copy()}}
{\footnotesize\ttfamily \label{structeastl_1_1move__and__copy__helper_aa9de7d135fbe5ddb02a94513283cf77b} 
template$<$typename, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}$>$ \\
template$<$typename Input\+Iterator, typename Output\+Iterator$>$ \\
static Output\+Iterator \mbox{\hyperlink{structeastl_1_1move__and__copy__helper}{eastl\+::move\+\_\+and\+\_\+copy\+\_\+helper}}$<$ typename, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} $>$\+::move\+\_\+or\+\_\+copy (\begin{DoxyParamCaption}\item[{Input\+Iterator}]{first}{, }\item[{Input\+Iterator}]{last}{, }\item[{Output\+Iterator}]{result}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



该结构体的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
runtime/\+EASTL/include/\+EASTL/internal/\mbox{\hyperlink{copy__help_8h}{copy\+\_\+help.\+h}}\end{DoxyCompactItemize}
