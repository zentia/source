\chapter{GPU Tasking (sycl\+Flow)}
\hypertarget{_g_p_u_taskingsycl_flow}{}\label{_g_p_u_taskingsycl_flow}\index{GPU Tasking (\%syclFlow)@{GPU Tasking (\%syclFlow)}}
Taskflow supports SYCL, a general-\/purpose heterogeneous programming model, to program heterogeneous tasks in a single-\/source C++ environment. This chapter discusses how to write SYCL C++ kernel code with Taskflow based on @sycl20\+\_\+spec.\hypertarget{_g_p_u_taskingsycl_flow_GPUTaskingsyclFlowIncludeTheHeader}{}\doxysection{\texorpdfstring{Include the Header}{Include the Header}}\label{_g_p_u_taskingsycl_flow_GPUTaskingsyclFlowIncludeTheHeader}
You need to include the header file, {\ttfamily taskflow/sycl/syclflow.hpp}, for using \doxylink{classtf_1_1sycl_flow}{tf\+::sycl\+Flow}.\hypertarget{_g_p_u_taskingsycl_flow_Create_a_syclFlow}{}\doxysection{\texorpdfstring{Create a sycl\+Flow}{Create a sycl\+Flow}}\label{_g_p_u_taskingsycl_flow_Create_a_syclFlow}
Taskflow introduces a task graph-\/based programming model, \doxylink{classtf_1_1sycl_flow}{tf\+::sycl\+Flow}, to program SYCL tasks and their dependencies. \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} sycl\+Flow is a task in a taskflow and is associated with a SYCL queue to execute kernels on a SYCL device. To create a sycl\+Flow task, emplace a callable with an argument of type \doxylink{classtf_1_1sycl_flow}{tf\+::sycl\+Flow} and associate it with a SYCL queue. The following example ({\ttfamily saxpy.\+cpp}) implements the canonical saxpy (A·X Plus Y) task graph using \doxylink{classtf_1_1sycl_flow}{tf\+::sycl\+Flow}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 1:\ \#include\ <\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}/syclflow.hpp>}
\DoxyCodeLine{\ 2:\ }
\DoxyCodeLine{\ 3:\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}\ =\ 1000000;}
\DoxyCodeLine{\ 4:\ }
\DoxyCodeLine{\ 5:\ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{main-override-static_8c_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()\ \{}
\DoxyCodeLine{\ 6:\ }
\DoxyCodeLine{\ 7:\ \ \ \mbox{\hyperlink{classtf_1_1_executor}{tf::Executor}}\ \mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}};}
\DoxyCodeLine{\ 8:\ \ \ \mbox{\hyperlink{classtf_1_1_taskflow}{tf::Taskflow}}\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}(\textcolor{stringliteral}{"{}saxpy\ example"{}});}
\DoxyCodeLine{\ 9:\ \ }
\DoxyCodeLine{10:\ \ \ sycl::queue\ \mbox{\hyperlink{namespacequeue}{queue}}\{sycl::gpu\_selector\{\}\};}
\DoxyCodeLine{11:\ \ }
\DoxyCodeLine{12:\ \ \ \textcolor{comment}{//\ allocate\ shared\ memory\ that\ is\ accessible\ on\ both\ host\ and\ device}}
\DoxyCodeLine{13:\ \ \ \textcolor{keywordtype}{float}*\ \mbox{\hyperlink{icosphere_8cpp_a207fd5507206d307cd63f95374fcd00d}{X}}\ =\ sycl::malloc\_shared<float>(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ queue);}
\DoxyCodeLine{14:\ \ \ \textcolor{keywordtype}{float}*\ \mbox{\hyperlink{namespace_spine_a3625b0b38867d83424d7aeec9f0ce394a57cec4137b614c87cb4e24a3d003a3e0}{Y}}\ =\ sycl::malloc\_shared<float>(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ queue);}
\DoxyCodeLine{15:\ \ }
\DoxyCodeLine{16:\ \ \ \textcolor{comment}{//\ create\ a\ syclFlow\ to\ perform\ the\ saxpy\ operation}}
\DoxyCodeLine{17:\ \ \ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace\_on([\&](tf::syclFlow\&\ sf)\{}
\DoxyCodeLine{18:\ \ \ \ \ tf::syclTask\ fillX\ =\ sf.\mbox{\hyperlink{classtf_1_1sycl_flow_a628843c986d60bea61eca8c48028159e}{fill}}(\mbox{\hyperlink{icosphere_8cpp_a207fd5507206d307cd63f95374fcd00d}{X}},\ 1.0f,\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}).\mbox{\hyperlink{classtf_1_1sycl_task_a738dfa209da08d8783127a5c5654558e}{name}}(\textcolor{stringliteral}{"{}fillX"{}});}
\DoxyCodeLine{19:\ \ \ \ \ tf::syclTask\ fillY\ =\ sf.\mbox{\hyperlink{classtf_1_1sycl_flow_a628843c986d60bea61eca8c48028159e}{fill}}(Y,\ 2.0f,\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}).\mbox{\hyperlink{classtf_1_1sycl_task_a738dfa209da08d8783127a5c5654558e}{name}}(\textcolor{stringliteral}{"{}fillY"{}});}
\DoxyCodeLine{20:\ \ \ \ \ tf::syclTask\ \mbox{\hyperlink{bench_2btl_2libs_2_b_l_a_s_2blas_8h_ad53e5aed16187a6bb50b8aa5f24cca8b}{saxpy}}\ =\ sf.\mbox{\hyperlink{classtf_1_1sycl_flow_ae42b1da441d5696dc589ee9ee89b9deb}{parallel\_for}}(sycl::range<1>(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}),\ }
\DoxyCodeLine{21:\ \ \ \ \ \ \ [=]\ (sycl::id<1>\ \textcolor{keywordtype}{id})\ \{}
\DoxyCodeLine{22:\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{icosphere_8cpp_a207fd5507206d307cd63f95374fcd00d}{X}}[\mbox{\hyperlink{cocoa__platform_8h_acf00cd75f37488e1d4ac463303ccfec4}{id}}]\ =\ 3.0f\ *\ \mbox{\hyperlink{icosphere_8cpp_a207fd5507206d307cd63f95374fcd00d}{X}}[\mbox{\hyperlink{cocoa__platform_8h_acf00cd75f37488e1d4ac463303ccfec4}{id}}]\ +\ \mbox{\hyperlink{namespace_spine_a3625b0b38867d83424d7aeec9f0ce394a57cec4137b614c87cb4e24a3d003a3e0}{Y}}[\mbox{\hyperlink{cocoa__platform_8h_acf00cd75f37488e1d4ac463303ccfec4}{id}}];}
\DoxyCodeLine{23:\ \ \ \ \ \ \ \}}
\DoxyCodeLine{24:\ \ \ \ \ ).\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{name}}(\textcolor{stringliteral}{"{}saxpy"{}});}
\DoxyCodeLine{25:\ \ \ \ \ \mbox{\hyperlink{bench_2btl_2libs_2_b_l_a_s_2blas_8h_ad53e5aed16187a6bb50b8aa5f24cca8b}{saxpy}}.\mbox{\hyperlink{classtf_1_1sycl_task_a05f42a7fa26997193068ce6502eabe16}{succeed}}(fillX,\ fillY);}
\DoxyCodeLine{26:\ \ \ \},\ \mbox{\hyperlink{namespaceluisa_aa1eb922874c2e5b0b13f4fc9a37747eb}{queue}}).\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{name}}(\textcolor{stringliteral}{"{}syclFlow"{}});}
\DoxyCodeLine{27:\ \ \ }
\DoxyCodeLine{28:\ \ \ \mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.\mbox{\hyperlink{classtf_1_1_executor_a519777f5783981d534e9e53b99712069}{run}}(\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}).wait();\ \ \textcolor{comment}{//\ run\ the\ taskflow}}
\DoxyCodeLine{29:\ \ \ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.dump(std::cout);\ \ \ \ \ \ \ \textcolor{comment}{//\ dump\ the\ taskflow}}
\DoxyCodeLine{30:\ \ }
\DoxyCodeLine{31:\ \ \ \textcolor{comment}{//\ free\ the\ shared\ memory\ to\ avoid\ memory\ leak}}
\DoxyCodeLine{32:\ \ \ sycl::free(\mbox{\hyperlink{icosphere_8cpp_a207fd5507206d307cd63f95374fcd00d}{X}},\ queue);\ }
\DoxyCodeLine{33:\ \ \ sycl::free(Y,\ queue);\ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{34:\ \}}

\end{DoxyCode}


Debrief\+:

\begin{DoxyItemize}
\item Lines 7-\/8 create a taskflow and an executor \item Lines 10 creates a SYCL queue on a default-\/selected GPU device \item Lines 13-\/14 allocate shared memory that is accessible on both host and device \item Lines 17-\/26 creates a sycl\+Flow to define the saxpy task graph that contains\+:
\begin{DoxyItemize}
\item one fill task to fill the memory area {\ttfamily X} with {\ttfamily 1.\+0f} 
\item one fill task to fill the memory area {\ttfamily Y} with {\ttfamily 2.\+0f} 
\item one kernel task to perform the saxpy operation on the GPU 
\end{DoxyItemize}\item Lines 28-\/29 executes the taskflow and dumps its graph to a DOT format \item Lines 32-\/33 deallocates the shared memory to avoid memory leak\end{DoxyItemize}
\doxylink{classtf_1_1sycl_flow}{tf\+::sycl\+Flow} is a lightweight task graph-\/based programming layer atop SYCL. We do not expend yet another effort on simplifying kernel programming but focus on tasking SYCL operations and their dependencies. This organization lets users fully take advantage of SYCL features that are commensurate with their domain knowledge, while leaving difficult task parallelism details to Taskflow.\hypertarget{_g_p_u_taskingsycl_flow_Compile_a_syclFlow_program}{}\doxysection{\texorpdfstring{Compile a sycl\+Flow Program}{Compile a sycl\+Flow Program}}\label{_g_p_u_taskingsycl_flow_Compile_a_syclFlow_program}
Use DPC++ clang to compile a sycl\+Flow program\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{.shell-\/session\}\ }
\DoxyCodeLine{\string~\$\ clang++\ -\/fsycl\ -\/fsycl-\/unnamed-\/\mbox{\hyperlink{sugar_8h_aa2bc5aa57d417f3226228d9058ab9f20}{lambda}}\ \(\backslash\)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ -\/fsycl-\/targets=nvptx64-\/nvidia-\/cuda\ \(\backslash\)\ \ \#\ \textcolor{keywordflow}{for}\ CUDA\ target}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ -\/I\ \mbox{\hyperlink{ittnotify__static_8h_a7016119bc831a22d1a351d56128518ed}{path}}/to/\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}\ -\/pthread\ -\/\mbox{\hyperlink{namespacestd}{std}}=\mbox{\hyperlink{bench_vec_add_8cpp_a41689956983587b085f9da3e48f31d99}{c}}++17\ \mbox{\hyperlink{bench_2btl_2libs_2_b_l_a_s_2blas_8h_ad53e5aed16187a6bb50b8aa5f24cca8b}{saxpy}}.cpp\ -\/o\ \mbox{\hyperlink{bench_2btl_2libs_2_b_l_a_s_2blas_8h_ad53e5aed16187a6bb50b8aa5f24cca8b}{saxpy}}}
\DoxyCodeLine{\string~\$\ ./\mbox{\hyperlink{bench_2btl_2libs_2_b_l_a_s_2blas_8h_ad53e5aed16187a6bb50b8aa5f24cca8b}{saxpy}}}

\end{DoxyCode}


Please visit the page \doxysectlink{_compile_taskflow_with_s_y_c_l}{Compile Taskflow with SYCL}{0} for more details.\hypertarget{_g_p_u_taskingsycl_flow_CreateMemoryOperationTasks}{}\doxysection{\texorpdfstring{Create Memory Operation Tasks}{Create Memory Operation Tasks}}\label{_g_p_u_taskingsycl_flow_CreateMemoryOperationTasks}
\doxylink{classtf_1_1sycl_flow}{tf\+::sycl\+Flow} provides a set of methods for creating tasks to perform common memory operations, such as copy, set, and fill, on memory area pointed to by {\itshape unified shared memory} (USM) pointers. The following example creates a sycl\+Flow task of two copy operations and one fill operation that set the first {\ttfamily N/2} elements in the vector to {\ttfamily -\/1}.


\begin{DoxyCode}{0}
\DoxyCodeLine{sycl::queue\ \mbox{\hyperlink{namespacequeue}{queue}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}\ \ =\ 1000;}
\DoxyCodeLine{\textcolor{keywordtype}{int}*\ hvec\ =\ \textcolor{keyword}{new}\ \textcolor{keywordtype}{int}[\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}]\ (100);}
\DoxyCodeLine{\textcolor{keywordtype}{int}*\ dvec\ =\ sycl::malloc\_device<int>(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ \mbox{\hyperlink{namespacequeue}{queue}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ create\ a\ syclflow\ task\ to\ set\ the\ first\ N/2\ elements\ to\ -\/1}}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace\_on([\&](\mbox{\hyperlink{classtf_1_1sycl_flow}{tf::syclFlow}}\&\ syclflow)\{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ ch2d\ =\ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_ac433456f3960028fb12a53018b263aee}{copy}}(dvec,\ hvec,\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}});}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ \mbox{\hyperlink{namespacetf_ab79480aaf575cd33eda54141ab5afcf1}{fill}}\ =\ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_a628843c986d60bea61eca8c48028159e}{fill}}(dvec,\ -\/1,\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}/2);}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ cd2h\ =\ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_ac433456f3960028fb12a53018b263aee}{copy}}(hvec,\ dvec,\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}});\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacetf_ab79480aaf575cd33eda54141ab5afcf1}{fill}}.precede(cd2h)}
\DoxyCodeLine{\ \ \ \ \ \ .succeed(ch2d);}
\DoxyCodeLine{\},\ \mbox{\hyperlink{namespacequeue}{queue}});}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.run(\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}).wait();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ inspect\ the\ result}}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}=0;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}<\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}/2;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}++)\ \{}
\DoxyCodeLine{\ \ (\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}\ <\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}\ /\ 2)\ ?\ assert(hvec[\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}]\ ==\ -\/1)\ :\ assert(hvec[\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}]\ ==\ 100);}
\DoxyCodeLine{\}}

\end{DoxyCode}


Both \doxylink{classtf_1_1sycl_flow_ac433456f3960028fb12a53018b263aee}{tf\+::sycl\+Flow\+::copy} and \doxylink{classtf_1_1sycl_flow_a628843c986d60bea61eca8c48028159e}{tf\+::sycl\+Flow\+::fill} operate on {\ttfamily typed} data. You can use \doxylink{classtf_1_1sycl_flow_ac1e1eb858d9271ed61ff4fe00f135e92}{tf\+::sycl\+Flow\+::memcpy} and \doxylink{classtf_1_1sycl_flow_a54b7497c0f4763bb4f8604f6c5654a5f}{tf\+::sycl\+Flow\+::memset} to operate on {\ttfamily untyped} data (i.\+e., array of bytes).


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace\_on([\&](\mbox{\hyperlink{classtf_1_1sycl_flow}{tf::syclFlow}}\&\ syclflow)\{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ ch2d\ =\ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_ac1e1eb858d9271ed61ff4fe00f135e92}{memcpy}}(dvec,\ hvec,\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ mset\ =\ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_a54b7497c0f4763bb4f8604f6c5654a5f}{memset}}(dvec,\ -\/1,\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}/2*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ cd2h\ =\ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_ac1e1eb858d9271ed61ff4fe00f135e92}{memcpy}}(hvec,\ dvec,\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacetf_ab79480aaf575cd33eda54141ab5afcf1}{fill}}.precede(cd2h)}
\DoxyCodeLine{\ \ \ \ \ \ .succeed(ch2d);}
\DoxyCodeLine{\},\ \mbox{\hyperlink{namespacequeue}{queue}});}

\end{DoxyCode}
\hypertarget{_g_p_u_taskingsycl_flow_CreateKernelTasks}{}\doxysection{\texorpdfstring{Create Kernel Tasks}{Create Kernel Tasks}}\label{_g_p_u_taskingsycl_flow_CreateKernelTasks}
SYCL allows a simple execution model in which a kernel is invoked over an N-\/dimensional index space defined by {\ttfamily sycl\+::range$<$\+N$>$}, where {\ttfamily N} is one, two or three. Each work item in such a kernel executes independently across a set of partitioned work groups. \doxylink{classtf_1_1sycl_flow_ae42b1da441d5696dc589ee9ee89b9deb}{tf\+::sycl\+Flow\+::parallel\+\_\+for} defines several variants to create a kernel task. The following variant pairs up a {\ttfamily sycl\+::range} and a {\ttfamily sycl\+::id} to set each element in {\ttfamily data} to {\ttfamily 1.\+0f} when it is not necessary to query the global range of the index space being executed across.


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}\ =\ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_ae42b1da441d5696dc589ee9ee89b9deb}{parallel\_for}}(}
\DoxyCodeLine{\ \ sycl::range<1>(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}),\ [\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}](sycl::id<1>\ \textcolor{keywordtype}{id})\{\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}[\mbox{\hyperlink{cocoa__platform_8h_acf00cd75f37488e1d4ac463303ccfec4}{id}}]\ =\ 1.0f;\ \}}
\DoxyCodeLine{);}

\end{DoxyCode}


As the same example, the following variant enables low-\/level functionality of work items and work groups using {\ttfamily sycl\+::nd\+\_\+range} and {\ttfamily sycl\+::nd\+\_\+item}. This becomes valuable when an execution requires groups of work items that communicate and synchronize.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ partition\ the\ N-\/element\ range\ to\ N/M\ work\ groups\ each\ of\ M\ work\ items}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}\ =\ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_ae42b1da441d5696dc589ee9ee89b9deb}{parallel\_for}}(}
\DoxyCodeLine{\ \ sycl::nd\_range<1>\{sycl::range<1>(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}),\ sycl::range<1>(\mbox{\hyperlink{test__overwrite__node_8cpp_a52037c938e3c1b126c6277da5ca689d0}{M}})\},}
\DoxyCodeLine{\ \ [\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}](sycl::nd\_item<1>\ item)\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ \textcolor{keywordtype}{id}\ =\ item.get\_global\_linear\_id();}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}[\mbox{\hyperlink{cocoa__platform_8h_acf00cd75f37488e1d4ac463303ccfec4}{id}}]\ =\ 1.0f;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ query\ detailed\ work\ group\ information}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ item.get\_group\_linear\_id();}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ item.get\_local\_linear\_id();}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ ...}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{);}

\end{DoxyCode}


All the kernel methods defined in the SYCL queue are applicable for \doxylink{classtf_1_1sycl_flow_ae42b1da441d5696dc589ee9ee89b9deb}{tf\+::sycl\+Flow\+::parallel\+\_\+for}.\hypertarget{_g_p_u_taskingsycl_flow_CreateCommandGroupFunctionObjectTasks}{}\doxysection{\texorpdfstring{Create Command Group Function Object Tasks}{Create Command Group Function Object Tasks}}\label{_g_p_u_taskingsycl_flow_CreateCommandGroupFunctionObjectTasks}
SYCL provides a way to encapsulate a device-\/side operation and all its data and event dependencies in a single {\itshape command group function object}. The function object accepts an argument of command group {\itshape handler} constructed by the SYCL runtime. Command group handler is the heart of SYCL programming as it defines pretty much all kernel-\/related methods, including submission, execution, and synchronization. You can directly create a SYCL task from a command group function object using \doxylink{classtf_1_1sycl_flow_a20b79581d27eaed2812ffb14dc821a64}{tf\+::sycl\+Flow\+::on}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}\ =\ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_a20b79581d27eaed2812ffb14dc821a64}{on}}(}
\DoxyCodeLine{\ \ [=]\ (sycl::handler\&\ handler)\ \{}
\DoxyCodeLine{\ \ \ \ handler.require(accessor);}
\DoxyCodeLine{\ \ \ \ handler.single\_task([=]()\{\ \ \textcolor{comment}{//\ place\ a\ single-\/threaded\ kernel\ function}}
\DoxyCodeLine{\ \ \ \ \ \ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}[0]\ =\ 1;}
\DoxyCodeLine{\ \ \ \ );}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{);}

\end{DoxyCode}
\hypertarget{_g_p_u_taskingsycl_flow_OffloadAsyclFlow}{}\doxysection{\texorpdfstring{Offload a sycl\+Flow}{Offload a sycl\+Flow}}\label{_g_p_u_taskingsycl_flow_OffloadAsyclFlow}
By default, the executor offloads and executes the sycl\+Flow once. When a sycl\+Flow is being executed, its task graph will be materialized by the Taskflow runtime and submitted to its associated SYCL queue in a topological order of task dependencies defined in that graph. You can explicitly execute a sycl\+Flow using different offload methods\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace\_on([](\mbox{\hyperlink{classtf_1_1sycl_flow}{tf::syclFlow}}\&\ sf)\ \{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ ...\ create\ SYCL\ tasks}}
\DoxyCodeLine{\ \ sf.offload();\ \ \ \ \ \ \textcolor{comment}{//\ offload\ the\ syclFlow\ and\ run\ it\ once}}
\DoxyCodeLine{\ \ sf.offload\_n(10);\ \ \textcolor{comment}{//\ offload\ the\ syclFlow\ and\ run\ it\ 10\ times}}
\DoxyCodeLine{\ \ sf.offload\_until([repeat=5]\ ()\ \textcolor{keyword}{mutable}\ \{\ \textcolor{keywordflow}{return}\ repeat-\/-\/\ ==\ 0;\ \})\ \ \textcolor{comment}{//\ five\ times}}
\DoxyCodeLine{\},\ \mbox{\hyperlink{namespaceluisa_aa1eb922874c2e5b0b13f4fc9a37747eb}{queue}});}

\end{DoxyCode}


After you offload a sycl\+Flow, it is considered executed, and the executor will {\itshape not} run an offloaded sycl\+Flow after leaving the sycl\+Flow task callable. On the other hand, if a sycl\+Flow is not offloaded, the executor runs it once. For example, the following two versions represent the same execution logic.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ version\ 1:\ explicitly\ offload\ a\ syclFlow\ once}}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace\_on([](\mbox{\hyperlink{classtf_1_1sycl_flow}{tf::syclFlow}}\&\ sf)\ \{}
\DoxyCodeLine{\ \ sf.single\_task([]()\{\});}
\DoxyCodeLine{\ \ sf.offload();}
\DoxyCodeLine{\},\ \mbox{\hyperlink{namespaceluisa_aa1eb922874c2e5b0b13f4fc9a37747eb}{queue}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ version\ 2\ (same\ as\ version\ 1):\ executor\ offloads\ the\ syclFlow\ once}}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace\_on([](tf::syclFlow\&\ sf)\ \{}
\DoxyCodeLine{\ \ sf.\mbox{\hyperlink{classtf_1_1sycl_flow_a05ff6f331b6cf48e21ae7f0d6aea9094}{single\_task}}([]()\{\});}
\DoxyCodeLine{\},\ \mbox{\hyperlink{namespaceluisa_aa1eb922874c2e5b0b13f4fc9a37747eb}{queue}});}

\end{DoxyCode}
\hypertarget{_g_p_u_taskingsycl_flow_UpdateAsyclFlow}{}\doxysection{\texorpdfstring{Update a sycl\+Flow}{Update a sycl\+Flow}}\label{_g_p_u_taskingsycl_flow_UpdateAsyclFlow}
You can update a SYCL task from an offloaded sycl\+Flow and {\itshape rebind} it to another task type. For example, you can rebind a memory operation task to a parallel-\/for kernel task from an offloaded sycl\+Flow and vice versa.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}\ =\ 10000;}
\DoxyCodeLine{sycl::queue\ \mbox{\hyperlink{namespacequeue}{queue}};}
\DoxyCodeLine{\textcolor{keywordtype}{int}*\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}\ =\ sycl::malloc\_shared<int>(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ \mbox{\hyperlink{namespacequeue}{queue}});}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace\_on([\&](\mbox{\hyperlink{classtf_1_1sycl_flow}{tf::syclFlow}}\&\ syclflow)\{}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ create\ a\ task\ to\ set\ each\ element\ to\ -\/1\ }}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}\ =\ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_a628843c986d60bea61eca8c48028159e}{fill}}(\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}},\ -\/1,\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}});}
\DoxyCodeLine{\ \ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_a2928c2edc466dd625741080c147de4ef}{offload}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ std::for\_each(\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}},\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}+\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ [](\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}})\{\ assert(\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}[\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}]\ ==\ -\/1);\ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ rebind\ the\ task\ to\ a\ parallel-\/for\ kernel\ task\ setting\ each\ element\ to\ 100}}
\DoxyCodeLine{\ \ syclflow.rebind\_parallel\_for(\mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}},\ sycl::range<1>(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}),\ [](sycl::id<1>\ \textcolor{keywordtype}{id})\{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}[\mbox{\hyperlink{cocoa__platform_8h_acf00cd75f37488e1d4ac463303ccfec4}{id}}]\ =\ 100;}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{\ \ syclflow.\mbox{\hyperlink{classtf_1_1sycl_flow_a2928c2edc466dd625741080c147de4ef}{offload}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ std::for\_each(\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}},\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}+\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ [\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}](\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}})\{\ assert(\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}[\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}]\ ==\ 100);\ \});}
\DoxyCodeLine{\},\ \mbox{\hyperlink{namespaceluisa_aa1eb922874c2e5b0b13f4fc9a37747eb}{queue}});}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.\mbox{\hyperlink{classtf_1_1_executor_a519777f5783981d534e9e53b99712069}{run}}(\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}).wait();}

\end{DoxyCode}


Each method of task creation in \doxylink{classtf_1_1sycl_flow}{tf\+::sycl\+Flow} has a corresponding method of rebinding a task to that task type (e.\+g., \doxylink{classtf_1_1sycl_flow_a20b79581d27eaed2812ffb14dc821a64}{tf\+::sycl\+Flow\+::on} and tf\+::sycl\+Flow\+::rebind\+\_\+on, \doxylink{classtf_1_1sycl_flow_ae42b1da441d5696dc589ee9ee89b9deb}{tf\+::sycl\+Flow\+::parallel\+\_\+for} and \doxylink{classtf_1_1sycl_flow_ae42b1da441d5696dc589ee9ee89b9deb}{tf\+::sycl\+Flow\+::parallel\+\_\+for}).\hypertarget{_g_p_u_taskingsycl_flow_UsesyclFlowInAStandaloneEnvironment}{}\doxysection{\texorpdfstring{Use sycl\+Flow in a Standalone Environment}{Use sycl\+Flow in a Standalone Environment}}\label{_g_p_u_taskingsycl_flow_UsesyclFlowInAStandaloneEnvironment}
You can use \doxylink{classtf_1_1sycl_flow}{tf\+::sycl\+Flow} in a standalone environment without going through \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow} and offloads it to a SYCL device from the caller thread. All the tasking methods we have discussed so far apply to the standalone use.


\begin{DoxyCode}{0}
\DoxyCodeLine{sycl::queue\ \mbox{\hyperlink{namespacequeue}{queue}};\ \ \ \ \ \ \ }
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1sycl_flow}{tf::syclFlow}}\ sf(\mbox{\hyperlink{namespacequeue}{queue}});\ \ \textcolor{comment}{//\ create\ a\ standalone\ syclFlow}}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ h2d\_x\ =\ sf.copy(dx,\ hx.data(),\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}).\mbox{\hyperlink{classtf_1_1sycl_task_a738dfa209da08d8783127a5c5654558e}{name}}(\textcolor{stringliteral}{"{}h2d\_x"{}});}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ h2d\_y\ =\ sf.copy(dy,\ hy.data(),\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}).\mbox{\hyperlink{classtf_1_1sycl_task_a738dfa209da08d8783127a5c5654558e}{name}}(\textcolor{stringliteral}{"{}h2d\_y"{}});}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ d2h\_x\ =\ sf.copy(hx.data(),\ dx,\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}).\mbox{\hyperlink{classtf_1_1sycl_task_a738dfa209da08d8783127a5c5654558e}{name}}(\textcolor{stringliteral}{"{}d2h\_x"{}});}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ d2h\_y\ =\ sf.copy(hy.data(),\ dy,\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}).\mbox{\hyperlink{classtf_1_1sycl_task_a738dfa209da08d8783127a5c5654558e}{name}}(\textcolor{stringliteral}{"{}d2h\_y"{}});}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1sycl_task}{tf::syclTask}}\ \mbox{\hyperlink{bench_2btl_2libs_2_b_l_a_s_2blas_8h_ad53e5aed16187a6bb50b8aa5f24cca8b}{saxpy}}\ =\ sf.parallel\_for(}
\DoxyCodeLine{\ \ sycl::range<1>(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}),\ [=]\ (sycl::id<1>\ \textcolor{keywordtype}{id})\ \{}
\DoxyCodeLine{\ \ \ \ dx[\mbox{\hyperlink{cocoa__platform_8h_acf00cd75f37488e1d4ac463303ccfec4}{id}}]\ =\ 2.0f\ *\ dx[\mbox{\hyperlink{cocoa__platform_8h_acf00cd75f37488e1d4ac463303ccfec4}{id}}]\ +\ dy[\mbox{\hyperlink{cocoa__platform_8h_acf00cd75f37488e1d4ac463303ccfec4}{id}}];}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{).\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{name}}(\textcolor{stringliteral}{"{}saxpy"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{bench_2btl_2libs_2_b_l_a_s_2blas_8h_ad53e5aed16187a6bb50b8aa5f24cca8b}{saxpy}}.succeed(h2d\_x,\ h2d\_y)\ \ \ \textcolor{comment}{//\ kernel\ runs\ after\ \ host-\/to-\/device\ copy}}
\DoxyCodeLine{\ \ \ \ \ .precede(d2h\_x,\ d2h\_y);\ \ \textcolor{comment}{//\ kernel\ runs\ before\ device-\/to-\/host\ copy}}
\DoxyCodeLine{}
\DoxyCodeLine{sf.offload();\ \ \textcolor{comment}{//\ offload\ and\ run\ the\ standalone\ syclFlow\ once}}

\end{DoxyCode}


\begin{DoxyNote}{注解}
In the standalone mode, a written sycl\+Flow will not be executed untile you explicitly call an offload method, as there is neither a taskflow nor an executor. 
\end{DoxyNote}
