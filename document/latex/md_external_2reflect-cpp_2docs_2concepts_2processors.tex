\chapter{Processors}
\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors}{}\label{md_external_2reflect-cpp_2docs_2concepts_2processors}\index{Processors@{Processors}}
\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md537}%
\Hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md537}%


Processors can be used to apply transformations to struct serialization and deserialization.

For instance, C++ \href{http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines\#Rl-camel}{\texttt{ usually}} uses {\ttfamily snake\+\_\+case}, but JSON uses {\ttfamily camel\+Case}. One way to handle this is {\ttfamily \doxylink{structrfl_1_1_rename}{rfl\+::\+Rename}}, but a more automated way would be to use a {\itshape processor}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ \ \ std::string\ first\_name;}
\DoxyCodeLine{\ \ \ \ std::string\ last\_name;}
\DoxyCodeLine{\ \ \ \ std::vector<Person>\ children;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ homer\ =}
\DoxyCodeLine{\ \ \ \ Person\{.first\_name\ =\ \textcolor{stringliteral}{"{}Homer"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ .last\_name\ =\ \textcolor{stringliteral}{"{}Simpson"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ .age\ =\ 45\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ json\_string\ =\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacerfl_1_1json_af39a23539424555b8c970d12a58e547f}{rfl::json::write<rfl::SnakeCaseToCamelCase>}}(homer);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ homer2\ =\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl::json::read<Person,\ rfl::SnakeCaseToCamelCase>}}(json\_string).value();}

\end{DoxyCode}


The resulting JSON string looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}firstName"{}:"{}Homer"{},"{}lastName"{}:"{}Simpson"{},"{}age"{}:45\}}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md538}{}\doxysection{\texorpdfstring{Supported processors}{Supported processors}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md538}
reflect-\/cpp currently supports the following processors\+:


\begin{DoxyItemize}
\item {\ttfamily \doxylink{structrfl_1_1_add_struct_name}{rfl\+::\+Add\+Struct\+Name}}
\item {\ttfamily \doxylink{structrfl_1_1_add_tags_to_variants}{rfl\+::\+Add\+Tags\+To\+Variants}}
\item {\ttfamily \doxylink{structrfl_1_1_allow_raw_ptrs}{rfl\+::\+Allow\+Raw\+Ptrs}}
\item {\ttfamily \doxylink{structrfl_1_1_default_if_missing}{rfl\+::\+Default\+If\+Missing}}
\item {\ttfamily \doxylink{structrfl_1_1_no_extra_fields}{rfl\+::\+No\+Extra\+Fields}}
\item {\ttfamily \doxylink{structrfl_1_1_no_field_names}{rfl\+::\+No\+Field\+Names}}
\item {\ttfamily \doxylink{structrfl_1_1_no_optionals}{rfl\+::\+No\+Optionals}}
\item {\ttfamily \doxylink{structrfl_1_1_underlying_enums}{rfl\+::\+Underlying\+Enums}}
\item {\ttfamily \doxylink{structrfl_1_1_snake_case_to_camel_case}{rfl\+::\+Snake\+Case\+To\+Camel\+Case}}
\item {\ttfamily \doxylink{structrfl_1_1_snake_case_to_pascal_case}{rfl\+::\+Snake\+Case\+To\+Pascal\+Case}}
\end{DoxyItemize}\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md539}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::\+Add\+Struct\+Name}}{{\ttfamily rfl\+::\+Add\+Struct\+Name}}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md539}
It is also possible to add the struct name as an additional field, like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ json\_string\ =\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacerfl_1_1json_af39a23539424555b8c970d12a58e547f}{rfl::json::write}}<\mbox{\hyperlink{structrfl_1_1_add_struct_name}{rfl::AddStructName}}<\textcolor{stringliteral}{"{}type"{}}>>(homer);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ homer2\ =\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl::json::read}}<Person,\ \mbox{\hyperlink{structrfl_1_1_add_struct_name}{rfl::AddStructName}}<\textcolor{stringliteral}{"{}type"{}}>>(json\_string).\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_abe8e049f756b5ba547bda825af81b645}{value}}();}

\end{DoxyCode}


The resulting JSON string looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}type"{}:"{}Person"{},"{}first\_name"{}:"{}Homer"{},"{}last\_name"{}:"{}Simpson"{},"{}age"{}:45\}}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md540}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::\+Add\+Tags\+To\+Variants}}{{\ttfamily rfl\+::\+Add\+Tags\+To\+Variants}}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md540}
This processor automatically adds tags to variants. Consider the following example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }button\_pressed\_t\ \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct\ }button\_released\_t\ \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct\ }key\_pressed\_t\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{char}\ \mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}};}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using\ }\mbox{\hyperlink{namespacetest__add__tag__to__rfl__variant_a77e735c13ac4c14a79da5b14b0cfdb41}{my\_event\_type\_t}}\ =}
\DoxyCodeLine{\ \ \ \ std::variant<button\_pressed\_t,\ button\_released\_t,\ key\_pressed\_t,\ int>;}

\end{DoxyCode}


The problem here is that {\ttfamily button\+\_\+pressed\+\_\+t} and {\ttfamily button\+\_\+released\+\_\+t} virtually look indistinguishable when they are serialized. The will both be serialized to {\ttfamily \{\}}.

But you can add this processor to automatically add tags and avoid the problem\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}\ =\ std::vector<my\_event\_type\_t>(}
\DoxyCodeLine{\ \ \{button\_pressed\_t\{\},\ button\_released\_t\{\},\ key\_pressed\_t\{\textcolor{charliteral}{'c'}\},\ 3\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ json\_string\ =\ \mbox{\hyperlink{namespacerfl_1_1json_af39a23539424555b8c970d12a58e547f}{rfl::json::write<rfl::AddTagsToVariants>}}(\mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}});}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{namespacerfl_1_1json_af39a23539424555b8c970d12a58e547f}{rfl::json::write<std::vector<my\_event\_type\_t>}},\ \mbox{\hyperlink{structrfl_1_1_add_tags_to_variants}{rfl::AddTagsToVariants}}>(json\_string);}

\end{DoxyCode}


{\ttfamily vec} will now be serialized as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[\{"{}button\_pressed\_t"{}:\{\}\},\{"{}button\_released\_t"{}:\{\}\},\{"{}key\_pressed\_t"{}:\{"{}key"{}:99\}\},\{"{}int"{}:3\}]}

\end{DoxyCode}


You can also set your own custom tags like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }key\_pressed\_t\ \{}
\DoxyCodeLine{\ \ \textcolor{keyword}{using\ }Tag\ =\ rfl::Literal<\textcolor{stringliteral}{"{}your\_custom\_tag"{}}>;}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{char}\ \mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}};}
\DoxyCodeLine{\};}

\end{DoxyCode}


{\ttfamily key\+\_\+pressed\+\_\+t} will now be serialized as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}your\_custom\_tag"{}:\{"{}key"{}:99\}\}}

\end{DoxyCode}


Note that there are other ways to address problems like this, for instance {\ttfamily \doxylink{structrfl_1_1_tagged_union}{rfl\+::\+Tagged\+Union}}. Please refer to the relevant sections of the documentation.\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md541}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::\+Allow\+Raw\+Ptrs}}{{\ttfamily rfl\+::\+Allow\+Raw\+Ptrs}}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md541}
By default, reflect-\/cpp does not allow {\itshape reading into} raw pointers. ({\itshape Writing from} raw pointers is never a problem.) This is because reading into raw pointers means that the library will allocate memory that the user then has to manually delete. This can lead to misunderstandings and memory leaks.

You might want to consider using some alternatives, such as {\ttfamily std\+::unique\+\_\+ptr}, {\ttfamily \doxylink{classrfl_1_1_box}{rfl\+::\+Box}}, {\ttfamily std\+::shared\+\_\+ptr}, {\ttfamily \doxylink{classrfl_1_1_ref}{rfl\+::\+Ref}} or {\ttfamily std\+::optional}. But if you absolutely have to use raw pointers, you can pass {\ttfamily \doxylink{structrfl_1_1_allow_raw_ptrs}{rfl\+::\+Allow\+Raw\+Ptrs}} to {\ttfamily read}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ rfl::Rename<\textcolor{stringliteral}{"{}firstName"{}},\ std::string>\ first\_name;}
\DoxyCodeLine{\ \ rfl::Rename<\textcolor{stringliteral}{"{}lastName"{}},\ std::string>\ last\_name\ =\ \textcolor{stringliteral}{"{}Simpson"{}};}
\DoxyCodeLine{\ \ std::vector<Person>*\ children;\`{}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ person\ =}
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl::json::read<Person,\ rfl::AllowRawPtrs>}}(json\_str);}

\end{DoxyCode}


However, you must keep in mind that it is now {\bfseries{YOUR}} responsibility to clean up. Otherwise, there {\bfseries{WILL}} be a memory leak.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ delete\_raw\_pointers(\textcolor{keyword}{const}\ Person\&\ \_person)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}\ (!\_person.children)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ child:\ \_person.children)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ delete\_raw\_pointers(child);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{delete}\ \_person.children;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{delete\_raw\_pointers(person);}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md542}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::\+Default\+If\+Missing}}{{\ttfamily rfl\+::\+Default\+If\+Missing}}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md542}
The {\ttfamily \doxylink{structrfl_1_1_default_if_missing}{rfl\+::\+Default\+If\+Missing}} processor is only relevant for reading data. For writing data, it will make no difference.

Usually, when fields are missing in the input data, this will lead to an error (unless they are optional fields). But if you pass the {\ttfamily \doxylink{structrfl_1_1_default_if_missing}{rfl\+::\+Default\+If\+Missing}} processor, then missing fields will be replaced by their default value.

For instance, consider the following struct\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ std::string\ first\_name;}
\DoxyCodeLine{\ \ std::string\ last\_name\ =\ \textcolor{stringliteral}{"{}Simpson"{}};}
\DoxyCodeLine{\ \ std::string\ town;}
\DoxyCodeLine{\};}

\end{DoxyCode}


Suppose you are reading a JSON like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}first\_name"{}:"{}Homer"{}\}}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl::json::read<Person,\ rfl::DefaultIfMissing>}}(json\_string);}

\end{DoxyCode}


Then the resulting struct will be equivalent to what you would have gotten had you read the following JSON string\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}first\_name"{}:"{}Homer"{},"{}last\_name"{}:"{}Simpson"{},"{}town"{}:"{}"{}\}}

\end{DoxyCode}


{\ttfamily last\+\_\+name} and {\ttfamily town} have been replaced by the default values. Because you have not passed a default value to town, the default value of the type is used instead.\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md543}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::\+No\+Extra\+Fields}}{{\ttfamily rfl\+::\+No\+Extra\+Fields}}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md543}
When reading an object and the object contains a field that cannot be matched to any of the fields in the struct, that field is simply ignored.

However, when {\ttfamily \doxylink{structrfl_1_1_no_extra_fields}{rfl\+::\+No\+Extra\+Fields}} is added to {\ttfamily read}, then such extra fields will lead to an error.

This can be overriden by adding {\ttfamily \doxylink{classrfl_1_1_extra_fields}{rfl\+::\+Extra\+Fields}} to the struct.

Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ std::string\ first\_name;}
\DoxyCodeLine{\ \ std::string\ last\_name\ =\ \textcolor{stringliteral}{"{}Simpson"{}};}
\DoxyCodeLine{\};}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}first\_name"{}:"{}Homer"{},"{}last\_name"{}:"{}Simpson"{},"{}extra\_field"{}:0\}}

\end{DoxyCode}


If you call {\ttfamily \doxylink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl\+::json\+::read}\texorpdfstring{$<$}{<}Person\texorpdfstring{$>$}{>}(json\+\_\+string)}, then {\ttfamily extra\+\_\+field} will simply be ignored.

But if you call {\ttfamily \doxylink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl\+::json\+::read}\texorpdfstring{$<$}{<}Person, \doxylink{structrfl_1_1_no_extra_fields}{rfl\+::\+No\+Extra\+Fields}\texorpdfstring{$>$}{>}(json\+\_\+string)}, you will get an error.

However, suppose the struct looked like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ std::string\ first\_name;}
\DoxyCodeLine{\ \ std::string\ last\_name\ =\ \textcolor{stringliteral}{"{}Simpson"{}};}
\DoxyCodeLine{\ \ rfl::ExtraFields<int>\ extras;}
\DoxyCodeLine{\};}

\end{DoxyCode}


In this case, {\ttfamily \doxylink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl\+::json\+::read}\texorpdfstring{$<$}{<}Person, \doxylink{structrfl_1_1_no_extra_fields}{rfl\+::\+No\+Extra\+Fields}\texorpdfstring{$>$}{>}(json\+\_\+string)} will not fail, because {\ttfamily extra\+\_\+field} would be included in {\ttfamily extras}.\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md544}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::\+No\+Field\+Names}}{{\ttfamily rfl\+::\+No\+Field\+Names}}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md544}
We can also remove the field names altogether\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ json\_string\ =\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacerfl_1_1json_af39a23539424555b8c970d12a58e547f}{rfl::json::write<rfl::NoFieldNames>}}(homer);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ homer2\ =\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl::json::read<Person,\ rfl::NoFieldNames>}}(json\_string).value();}

\end{DoxyCode}


The resulting JSON string looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{["{}Homer"{},"{}Simpson"{},45]}

\end{DoxyCode}


This is particularly relevant for binary formats, which do not emphasize readability, like msgpack or flexbuffers. Removing the field names can reduce the size of the resulting bytestrings and significantly speed up read and write time, depending on the dataset.

However, it makes it more difficult to maintain backwards compatability.

Note that {\ttfamily \doxylink{structrfl_1_1_no_field_names}{rfl\+::\+No\+Field\+Names}} is not supported for BSON, TOML, XML, or YAML, due to limitations of these formats.\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md545}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::\+No\+Optionals}}{{\ttfamily rfl\+::\+No\+Optionals}}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md545}
As we have seen in the section on optional fields, when a {\ttfamily std\+::optional} is {\ttfamily std\+::nullopt}, it is usually not written at all. But if you want them to be explicitly written as {\ttfamily null}, you can use this processor. The same thing applies to {\ttfamily std\+::shared\+\_\+ptr} and {\ttfamily std\+::unique\+\_\+ptr}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ std::string\ first\_name;}
\DoxyCodeLine{\ \ std::string\ last\_name\ =\ \textcolor{stringliteral}{"{}Simpson"{}};}
\DoxyCodeLine{\ \ std::optional<std::string>\ town\ =\ std::nullopt;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ homer\ =\ Person\{.first\_name\ =\ \textcolor{stringliteral}{"{}Homer"{}}\};}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{namespacerfl_1_1json_af39a23539424555b8c970d12a58e547f}{rfl::json::write<rfl::NoOptionals>}}(homer);}

\end{DoxyCode}


The resulting JSON string looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}first\_name"{}:"{}Homer"{},"{}last\_name"{}:"{}Simpson"{},"{}town"{}:null\}}

\end{DoxyCode}


By default, {\ttfamily \doxylink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl\+::json\+::read}} will accept both {\ttfamily "{}town"{}\+:null} and just leaving out the field {\ttfamily town}. However, if you want to require the field {\ttfamily town} to be included, you can add {\ttfamily \doxylink{structrfl_1_1_no_optionals}{rfl\+::\+No\+Optionals}} to {\ttfamily read}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{rfl::json::read<Person,\ rfl::NoOptionals>(json\_string);}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md546}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::\+Underlying\+Enums}}{{\ttfamily rfl\+::\+Underlying\+Enums}}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md546}
By passing the processor {\ttfamily \doxylink{structrfl_1_1_underlying_enums}{rfl\+::\+Underlying\+Enums}}, fields of the enum type will be written and read as integers


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{enum\ class}\ \mbox{\hyperlink{external_2magic__enum_2example_2example_8cpp_a692f5062ca261bdb3a62a63faddfd27f}{Color}}\ \{\ \mbox{\hyperlink{runtime_2spdlog_2include_2spdlog_2fmt_2bundled_2color_8h_a80d1dc5f416b97f92939a4166d41203cabda9643ac6601722a28f238714274da4}{red}},\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aef30e4e3dccbffce99b7509d5366faef}{green}},\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_ab4fcc6ff520ae4d9de259c8468a5cd93}{blue}},\ \mbox{\hyperlink{runtime_2spdlog_2include_2spdlog_2fmt_2bundled_2color_8h_a80d1dc5f416b97f92939a4166d41203cad487dd0b55dfcacdd920ccbdaeafa351}{yellow}}\ \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Circle\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{float}\ radius;}
\DoxyCodeLine{\ \ \mbox{\hyperlink{external_2magic__enum_2example_2example_8cpp_a692f5062ca261bdb3a62a63faddfd27f}{Color}}\ \mbox{\hyperlink{runtime_2spdlog_2include_2spdlog_2fmt_2bundled_2color_8h_a80d1dc5f416b97f92939a4166d41203c}{color}};}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ circle\ =\ Circle\{.radius\ =\ 2.0,\ .color\ =\ Color::green\};}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{namespacerfl_1_1json_af39a23539424555b8c970d12a58e547f}{rfl::json::write<rfl::UnderlyingEnums>}}(circle);}

\end{DoxyCode}


The resulting JSON string looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}radius"{}:2.0,"{}color"{}:1\}}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md547}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::\+Snake\+Case\+To\+Camel\+Case}}{{\ttfamily rfl\+::\+Snake\+Case\+To\+Camel\+Case}}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md547}
Please refer to the example above.\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md548}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::\+Snake\+Case\+To\+Pascal\+Case}}{{\ttfamily rfl\+::\+Snake\+Case\+To\+Pascal\+Case}}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md548}
If you want {\ttfamily Pascal\+Case} instead of {\ttfamily camel\+Case}, you can use the appropriate processor\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ json\_string\ =\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacerfl_1_1json_af39a23539424555b8c970d12a58e547f}{rfl::json::write<rfl::SnakeCaseToPascalCase>}}(homer);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ homer2\ =\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl::json::read<Person,\ rfl::SnakeCaseToPascalCase>}}(json\_string).value();}

\end{DoxyCode}


The resulting JSON string looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}FirstName"{}:"{}Homer"{},"{}LastName"{}:"{}Simpson"{},"{}Age"{}:45\}}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md549}{}\doxysection{\texorpdfstring{Combining several processors}{Combining several processors}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md549}
You can combine several processors\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ json\_string\ =\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacerfl_1_1json_af39a23539424555b8c970d12a58e547f}{rfl::json::write}}<\mbox{\hyperlink{structrfl_1_1_snake_case_to_camel_case}{rfl::SnakeCaseToCamelCase}},\ \mbox{\hyperlink{structrfl_1_1_add_struct_name}{rfl::AddStructName}}<\textcolor{stringliteral}{"{}type"{}}>>(homer);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ homer2\ =\ }
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl::json::read}}<Person,\ \mbox{\hyperlink{structrfl_1_1_snake_case_to_camel_case}{rfl::SnakeCaseToCamelCase}},\ \mbox{\hyperlink{structrfl_1_1_add_struct_name}{rfl::AddStructName}}<\textcolor{stringliteral}{"{}type"{}}>>(json\_string).\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_abe8e049f756b5ba547bda825af81b645}{value}}();}

\end{DoxyCode}


The resulting JSON string looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}type"{}:"{}Person"{},"{}firstName"{}:"{}Homer"{},"{}lastName"{}:"{}Simpson"{},"{}age"{}:45\}}

\end{DoxyCode}


When you have several processors, it is probably more convenient to combine them like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ }Processors\ =\ \mbox{\hyperlink{structrfl_1_1_processors}{rfl::Processors}}<}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_snake_case_to_camel_case}{rfl::SnakeCaseToCamelCase}},\ \mbox{\hyperlink{structrfl_1_1_add_struct_name}{rfl::AddStructName}}<\textcolor{stringliteral}{"{}type"{}}>>;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ json\_string\ =\ \mbox{\hyperlink{namespacerfl_1_1json_af39a23539424555b8c970d12a58e547f}{rfl::json::write<Processors>}}(homer);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ homer2\ =\ \mbox{\hyperlink{namespacerfl_1_1json_a905573518eca04a9c269d1bb32de7dd1}{rfl::json::read<Person,\ Processors>}}(json\_string).value();}

\end{DoxyCode}


The resulting JSON string looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}type"{}:"{}Person"{},"{}firstName"{}:"{}Homer"{},"{}lastName"{}:"{}Simpson"{},"{}age"{}:45\}}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md550}{}\doxysection{\texorpdfstring{Writing your own processors}{Writing your own processors}}\label{md_external_2reflect-cpp_2docs_2concepts_2processors_autotoc_md550}
In principle, writing your own processors is not very difficult. You need to define a struct, which takes has a static method called {\ttfamily process} taking a named tuple as an input and then returning a modified named tuple. The {\ttfamily process} method should accept the type of the original struct as a template parameter.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }MyOwnProcessor\ \{}
\DoxyCodeLine{\ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{class}\ StructType>}
\DoxyCodeLine{\ \ \textcolor{keyword}{static}\ \textcolor{keyword}{auto}\ process(\textcolor{keyword}{auto}\&\&\ \_named\_tuple)\ \{...\}}
\DoxyCodeLine{\};}

\end{DoxyCode}
 