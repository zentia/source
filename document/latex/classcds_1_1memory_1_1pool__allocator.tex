\doxysection{cds\+::memory\+::pool\+\_\+allocator\texorpdfstring{$<$}{<} T, Accessor \texorpdfstring{$>$}{>} 模板类 参考}
\hypertarget{classcds_1_1memory_1_1pool__allocator}{}\label{classcds_1_1memory_1_1pool__allocator}\index{cds::memory::pool\_allocator$<$ T, Accessor $>$@{cds::memory::pool\_allocator$<$ T, Accessor $>$}}


Pool allocator adapter  




{\ttfamily \#include $<$pool\+\_\+allocator.\+h$>$}



\doxysubsection{详细描述}
\subsubsection*{template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, typename Accessor$>$\newline
class cds\+::memory\+::pool\+\_\+allocator$<$ T, Accessor $>$}
Pool allocator adapter 

This class is an adapter for an object pool. It gives {\ttfamily std\+::allocator} interface for the \doxylink{group__cds__memory__pool}{pool}.

Template arguments\+:
\begin{DoxyItemize}
\item {\ttfamily T} -\/ value type
\item {\ttfamily Accessor} -\/ a functor to access to the pool object. The pool has the following interface\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{class\ }pool\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{typedef}\ \mbox{\hyperlink{test__overwrite__node_8cpp_a0acb682b8260ab1c60b918599864e2e5}{T}}\ value\_type\ \ \ \ ;\ \ \ \textcolor{comment}{//\ Object\ type\ maintained\ by\ pool}}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{test__overwrite__node_8cpp_a0acb682b8260ab1c60b918599864e2e5}{T}}\ *\ \mbox{\hyperlink{allocator_8c_a3a4fc1fa103fa3a33fc168de4cd6703e}{allocate}}(\ \textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__simple_8cpp_a5150192f625f4d7970d61169b9567f39}{n}}\ )\ \ \ \ \ \ \ \ \ \ \ \ ;\ \ \ \textcolor{comment}{//\ Allocate\ an\ array\ of\ object\ of\ type\ T}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{allocator_8c_af6d0cf7cc14ac871f484ce755a237a06}{deallocate}}(\ \mbox{\hyperlink{test__overwrite__node_8cpp_a0acb682b8260ab1c60b918599864e2e5}{T}}\ *\ \mbox{\hyperlink{main-override_8cpp_a117104b82864d3b23ec174af6d392709}{p}},\ \textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__simple_8cpp_a5150192f625f4d7970d61169b9567f39}{n}}\ )\ \ ;\ \ \ \textcolor{comment}{//\ Deallocate\ the\ array\ p\ of\ size\ n}}
\DoxyCodeLine{\};}

\end{DoxyCode}

\end{DoxyItemize}

{\bfseries{Usage}} \begin{DoxyVerb}Suppose, we have a pool with interface above. Usually, the pool is a static object:
\code
    static pool<Foo>     thePool;
\endcode

The \p %pool_allocator gives \p std::allocator interface for the pool.
It is needed to declare an <i>accessor</i> functor to access to \p thePool:
\code
    struct pool_accessor {
        typedef typename pool::value_type   value_type;

        pool& operator()() const
        {
            return thePool;
        }
    };
\endcode

Now, <tt>cds::memory::pool_allocator< T, pool_accessor > </tt> can be used instead of \p std::allocator.
\end{DoxyVerb}
 

该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
external/libcds/cds/memory/\mbox{\hyperlink{pool__allocator_8h}{pool\+\_\+allocator.\+h}}\end{DoxyCompactItemize}
