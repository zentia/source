\doxysection{ff\+::ff\+\_\+allocator类 参考}
\hypertarget{classff_1_1ff__allocator}{}\label{classff_1_1ff__allocator}\index{ff::ff\_allocator@{ff::ff\_allocator}}


The \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator}, based on the idea of the \href{http://www.ibm.com/developerworks/linux/library/l-linux-slab-allocator/}{\texttt{ Slab allocator}}  




{\ttfamily \#include $<$allocator.\+hpp$>$}



类 ff\+::ff\+\_\+allocator 继承关系图\+:
% FIG 0


ff\+::ff\+\_\+allocator 的协作图\+:
% FIG 1
\doxysubsubsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} \mbox{\hyperlink{classff_1_1ff__allocator_a8382d619374c20723c838afff6dc0585}{getslabs}} (size\+\_\+t \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_ac42c05b5701aef6bab82675cf3b55fee}{size}})
\item 
\mbox{\hyperlink{classff_1_1ff__allocator_a3f4683ff1c69931dfc1edc6679c0b2cd}{ff\+\_\+allocator}} (size\+\_\+t=0, const \mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} \mbox{\hyperlink{classff_1_1ff__allocator_ab4acffca209f242ece598bff4499ba9e}{delayed\+Reclaim}}=0)
\begin{DoxyCompactList}\small\item\em Default Constructor \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{classff_1_1ff__allocator_aa9787a0f1539c6f0bd559c9ab4d98442}{\texorpdfstring{$\sim$}{\string~}ff\+\_\+allocator}} ()
\item 
\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} \mbox{\hyperlink{classff_1_1ff__allocator_a4256355feee6ed6fd39a515da813fbcb}{init}} (const \mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} \+\_\+nslabs\mbox{[}\mbox{\hyperlink{namespaceff_ac70617c84eb066a57e5d904bf5c3e62da9b057b825c2a8d1ab94ef55519344dd1}{N\+\_\+\+SLABBUFFER}}\mbox{]}=0, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} prealloc=\mbox{\hyperlink{yyjson_8h_a41f9c5fb8b08eb5dc3edce4dcb37fee7}{true}})
\begin{DoxyCompactList}\small\item\em init the allocator \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} \mbox{\hyperlink{classff_1_1ff__allocator_a09e650148ba1d77a17015eb302808714}{register\+Allocator}} ()
\begin{DoxyCompactList}\small\item\em register \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator} (get ownership) \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classff_1_1ff__allocator_acc24fb135fae47a76d9c4581f7fe74ea}{deregister\+Allocator}} (\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} reclaim\+Memory=\mbox{\hyperlink{yyjson_8h_a41f9c5fb8b08eb5dc3edce4dcb37fee7}{true}})
\begin{DoxyCompactList}\small\item\em de-\/register the \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator} (release ownership) \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} \mbox{\hyperlink{classff_1_1ff__allocator_ac09381e5eaa8279a60b7a191f2210174}{register4free}} ()
\begin{DoxyCompactList}\small\item\em register for the free operation \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classff_1_1ff__allocator_a9cfb8892d71d1fa72d233cc22b117dbf}{malloc}} (size\+\_\+t \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_ac42c05b5701aef6bab82675cf3b55fee}{size}})
\begin{DoxyCompactList}\small\item\em malloc \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} \mbox{\hyperlink{classff_1_1ff__allocator_a3ad062e04d2c1739a089cbc0a60dda0b}{posix\+\_\+memalign}} (\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}memptr, size\+\_\+t alignment, size\+\_\+t \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_ac42c05b5701aef6bab82675cf3b55fee}{size}})
\begin{DoxyCompactList}\small\item\em ff posix\+\_\+memalign. \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classff_1_1ff__allocator_ad4fe08078fc1624b607c3a9fdd823350}{free}} (\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{yyjson_8h_a26c622783fa717b24fe0bbd3e060f74a}{ptr}})
\begin{DoxyCompactList}\small\item\em free \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classff_1_1ff__allocator_a83e8958912ce97820addd8ad2ad999f7}{realloc}} (\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{yyjson_8h_a26c622783fa717b24fe0bbd3e060f74a}{ptr}}, size\+\_\+t newsize)
\begin{DoxyCompactList}\small\item\em realloc \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classff_1_1ff__allocator_a9e72260f154d03da4edb766a5edfe116}{growsup}} (\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{yyjson_8h_a26c622783fa717b24fe0bbd3e060f74a}{ptr}}, size\+\_\+t newsize)
\end{DoxyCompactItemize}
\doxysubsubsection*{Public 属性}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{allocator_8hpp_a2fbd97af3a198200b674b6658fb90a50}{ALLSTATS}}(\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} printstats(std\+::ostream \&out) \{ all\+\_\+stats\+::instance() -\/$>$\mbox{\hyperlink{runtime_2spdlog_2include_2spdlog_2fmt_2bundled_2base_8h_a59025bfaf390e425b4e274c966a77557}{print}}(out);\}) \mbox{\hyperlink{rml__server_8cpp_a6a1d6e1a12975a4e9a0b5b952e79eaad}{private}} \mbox{\hyperlink{classff_1_1_segment_allocator}{Segment\+Allocator}} \mbox{\hyperlink{classff_1_1ff__allocator_a83eef76f0a8022f2528e4e23d1ba5603}{alloc}} )
\item 
const \mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} \mbox{\hyperlink{classff_1_1ff__allocator_ab4acffca209f242ece598bff4499ba9e}{delayed\+Reclaim}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected 成员函数}
\begin{DoxyCompactItemize}
\item 
virtual \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classff_1_1ff__allocator_a6fe7b7eef67f4bebfba3c705096a067d}{free}} (\mbox{\hyperlink{structff_1_1_buf__ctl}{Buf\+\_\+ctl}} \texorpdfstring{$\ast$}{*}buf)
\item 
size\+\_\+t \mbox{\hyperlink{classff_1_1ff__allocator_a1156e5f5142be9fa15d1b703e8032246}{allocatedsize}} ()
\end{DoxyCompactItemize}
\doxysubsubsection*{Private 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structff_1_1_seg__ctl}{Seg\+\_\+ctl}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classff_1_1ff__allocator_a632c9d399d139cee6317dc4fd3a625e6}{getsegctl}} (\mbox{\hyperlink{structff_1_1_buf__ctl}{Buf\+\_\+ctl}} \texorpdfstring{$\ast$}{*}buf)
\item 
\mbox{\hyperlink{classff_1_1_slab_cache}{Slab\+Cache}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classff_1_1ff__allocator_adbff514152f454289da91e44ffb5f49b}{getslabs}} (\mbox{\hyperlink{structff_1_1_buf__ctl}{Buf\+\_\+ctl}} \texorpdfstring{$\ast$}{*}buf)
\end{DoxyCompactItemize}
\doxysubsubsection*{友元}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classff_1_1ff__allocator_a90dcaed0c9c7a0dc2f18aaa9468cc743}{FFAllocator}}
\end{DoxyCompactItemize}


\doxysubsection{详细描述}
The \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator}, based on the idea of the \href{http://www.ibm.com/developerworks/linux/library/l-linux-slab-allocator/}{\texttt{ Slab allocator}} 

\doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator} is owner by a single \doxylink{classff_1_1ff__node}{ff\+\_\+node}, which is the \doxylink{classff_1_1ff__node}{ff\+\_\+node} which {\ttfamily } it. The owner can {\ttfamily  malloc/realloc/posix\+\_\+memalign}. Other \doxylink{classff_1_1ff__node}{ff\+\_\+node} can {\ttfamily free} provided they /p register4free. \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} \doxylink{classff_1_1ff__node}{ff\+\_\+node} can init more than one \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator}. Every violation cause unexpected results (e.\+g. segfault).

The \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator} works over the \doxylink{classff_1_1_slab_cache}{Slab\+Cache} and is tuned to outperform standard allocators\textquotesingle{} performance in a multi-\/threaded envirnoment. When it is initialised, it creates a (predefined) number of Slab\+Caches, each one containing a (predefined) number of buffers of different sizes, from 32 to 8192 bytes. The thread that calls first the allocator object and wants to allocate memory has to register itself to the shared leak queue. Only one thread can perform this operation. The allocator obtains memory from the pre-\/allocated \doxylink{classff_1_1_slab_cache}{Slab\+Cache}\+: if there is a slab (i.\+e. a buffer) big enough to contain an object of the requested size, the pointer to that buffer is passed to the thread that requested the memory. This latter thread has to register as well to the same shared leak queue, so that when it has finished its operations, it can return memory to the allocator thread.

\begin{DoxyNote}{注解}
Very efficient but delicate to use, expert only. Not designed to end-\/user but to build Fast\+Flow pattern runtime support. Not expert should use \doxylink{classff_1_1_f_f_allocator}{ff\+::\+FFAllocator}. 
\end{DoxyNote}


\doxysubsection{构造及析构函数说明}
\Hypertarget{classff_1_1ff__allocator_a3f4683ff1c69931dfc1edc6679c0b2cd}\index{ff::ff\_allocator@{ff::ff\_allocator}!ff\_allocator@{ff\_allocator}}
\index{ff\_allocator@{ff\_allocator}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{ff\_allocator()}{ff\_allocator()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a3f4683ff1c69931dfc1edc6679c0b2cd} 
ff\+::ff\+\_\+allocator\+::ff\+\_\+allocator (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{}{ = {\ttfamily 0}, }\item[{const \mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}}}]{delayed\+Reclaim}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Default Constructor 

\Hypertarget{classff_1_1ff__allocator_aa9787a0f1539c6f0bd559c9ab4d98442}\index{ff::ff\_allocator@{ff::ff\_allocator}!````~ff\_allocator@{\texorpdfstring{$\sim$}{\string~}ff\_allocator}}
\index{````~ff\_allocator@{\texorpdfstring{$\sim$}{\string~}ff\_allocator}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{\texorpdfstring{$\sim$}{\string~}ff\_allocator()}{\string~ff\_allocator()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_aa9787a0f1539c6f0bd559c9ab4d98442} 
virtual ff\+::ff\+\_\+allocator\+::\texorpdfstring{$\sim$}{\string~}ff\+\_\+allocator (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



\doxysubsection{成员函数说明}
\Hypertarget{classff_1_1ff__allocator_a1156e5f5142be9fa15d1b703e8032246}\index{ff::ff\_allocator@{ff::ff\_allocator}!allocatedsize@{allocatedsize}}
\index{allocatedsize@{allocatedsize}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{allocatedsize()}{allocatedsize()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a1156e5f5142be9fa15d1b703e8032246} 
size\+\_\+t ff\+::ff\+\_\+allocator\+::allocatedsize (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

函数调用图\+:
% FIG 2
\Hypertarget{classff_1_1ff__allocator_acc24fb135fae47a76d9c4581f7fe74ea}\index{ff::ff\_allocator@{ff::ff\_allocator}!deregisterAllocator@{deregisterAllocator}}
\index{deregisterAllocator@{deregisterAllocator}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{deregisterAllocator()}{deregisterAllocator()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_acc24fb135fae47a76d9c4581f7fe74ea} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} ff\+::ff\+\_\+allocator\+::deregister\+Allocator (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}}]{reclaim\+Memory}{ = {\ttfamily \mbox{\hyperlink{yyjson_8h_a41f9c5fb8b08eb5dc3edce4dcb37fee7}{true}}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



de-\/register the \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator} (release ownership) 

Deregister the \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator} (i.\+e. release ownership) and reclaim allocated memory back to the allocator. Every \doxylink{classff_1_1ff__node}{ff\+\_\+node} can perform this action. No {\ttfamily malloc/realloc/posix\+\_\+memalign} requires than one \doxylink{classff_1_1ff__node}{ff\+\_\+node} own the \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator}


\begin{DoxyParams}{参数}
{\em reclaim\+Memory} & {\ttfamily true} if reclaim; {\ttfamily false} if deregister only \\
\hline
\end{DoxyParams}
函数调用图\+:
% FIG 3
\Hypertarget{classff_1_1ff__allocator_a6fe7b7eef67f4bebfba3c705096a067d}\index{ff::ff\_allocator@{ff::ff\_allocator}!free@{free}}
\index{free@{free}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{free()}{free()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a6fe7b7eef67f4bebfba3c705096a067d} 
virtual \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} ff\+::ff\+\_\+allocator\+::free (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structff_1_1_buf__ctl}{Buf\+\_\+ctl}} \texorpdfstring{$\ast$}{*}}]{buf}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}



被 \mbox{\hyperlink{classff_1_1ffa__wrapper_ada3370f18adff1597c079ee64fb15329}{ff\+::ffa\+\_\+wrapper}} 重载.

函数调用图\+:
% FIG 4
\Hypertarget{classff_1_1ff__allocator_ad4fe08078fc1624b607c3a9fdd823350}\index{ff::ff\_allocator@{ff::ff\_allocator}!free@{free}}
\index{free@{free}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{free()}{free()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_ad4fe08078fc1624b607c3a9fdd823350} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} ff\+::ff\+\_\+allocator\+::free (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}}]{ptr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



free 

free the requested memory chunk on a given \doxylink{classff_1_1ff__allocator}{ff\+::ff\+\_\+allocator} object.

The memory should have been allocated using {\ttfamily malloc} on the same object (otherwise segfault), and the \doxylink{classff_1_1ff__node}{ff\+\_\+node} should have been {\ttfamily ff\+::register4free()} on the calling \doxylink{classff_1_1ff__node}{ff\+::ff\+\_\+node}.

Wrong registering cause segfault or unspected behaviour.

\begin{DoxyNote}{注解}
Very efficient but delicate to use, expert only. Not designed to end-\/user but to build Fast\+Flow pattern runtime support. Not expert should use \doxylink{classff_1_1_f_f_allocator}{ff\+::\+FFAllocator}
\end{DoxyNote}

\begin{DoxyParams}{参数}
{\em ptr} & a pointer to the buffer. \\
\hline
\end{DoxyParams}
\Hypertarget{classff_1_1ff__allocator_a632c9d399d139cee6317dc4fd3a625e6}\index{ff::ff\_allocator@{ff::ff\_allocator}!getsegctl@{getsegctl}}
\index{getsegctl@{getsegctl}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{getsegctl()}{getsegctl()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a632c9d399d139cee6317dc4fd3a625e6} 
\mbox{\hyperlink{structff_1_1_seg__ctl}{Seg\+\_\+ctl}} \texorpdfstring{$\ast$}{*} ff\+::ff\+\_\+allocator\+::getsegctl (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structff_1_1_buf__ctl}{Buf\+\_\+ctl}} \texorpdfstring{$\ast$}{*}}]{buf}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}

\Hypertarget{classff_1_1ff__allocator_adbff514152f454289da91e44ffb5f49b}\index{ff::ff\_allocator@{ff::ff\_allocator}!getslabs@{getslabs}}
\index{getslabs@{getslabs}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{getslabs()}{getslabs()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_adbff514152f454289da91e44ffb5f49b} 
\mbox{\hyperlink{classff_1_1_slab_cache}{Slab\+Cache}} \texorpdfstring{$\ast$}{*} ff\+::ff\+\_\+allocator\+::getslabs (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structff_1_1_buf__ctl}{Buf\+\_\+ctl}} \texorpdfstring{$\ast$}{*}}]{buf}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}

函数调用图\+:
% FIG 5
\Hypertarget{classff_1_1ff__allocator_a8382d619374c20723c838afff6dc0585}\index{ff::ff\_allocator@{ff::ff\_allocator}!getslabs@{getslabs}}
\index{getslabs@{getslabs}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{getslabs()}{getslabs()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a8382d619374c20723c838afff6dc0585} 
\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} ff\+::ff\+\_\+allocator\+::getslabs (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

函数调用图\+:
% FIG 6
\Hypertarget{classff_1_1ff__allocator_a9e72260f154d03da4edb766a5edfe116}\index{ff::ff\_allocator@{ff::ff\_allocator}!growsup@{growsup}}
\index{growsup@{growsup}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{growsup()}{growsup()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a9e72260f154d03da4edb766a5edfe116} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*} ff\+::ff\+\_\+allocator\+::growsup (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}}]{ptr}{, }\item[{size\+\_\+t}]{newsize}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

函数调用图\+:
% FIG 7
\Hypertarget{classff_1_1ff__allocator_a4256355feee6ed6fd39a515da813fbcb}\index{ff::ff\_allocator@{ff::ff\_allocator}!init@{init}}
\index{init@{init}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{init()}{init()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a4256355feee6ed6fd39a515da813fbcb} 
\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} ff\+::ff\+\_\+allocator\+::init (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}}}]{\+\_\+nslabs}{\mbox{[}\+N\+\_\+\+SLABBUFFER\mbox{]} = {\ttfamily 0}, }\item[{\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}}]{prealloc}{ = {\ttfamily \mbox{\hyperlink{yyjson_8h_a41f9c5fb8b08eb5dc3edce4dcb37fee7}{true}}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



init the allocator 

Initialise the allocator. This method is called by one \doxylink{classff_1_1ff__node}{ff\+\_\+node} for each data-\/path. (e.\+g. the Emitter in a Farm skeleton). It creates a number of Slab\+Caches objects, a number specified by the {\ttfamily N\+\_\+\+SLABBUFFER} constant. The size of each created segment goes from 32 (the first one created) to 8192 (the last). Typically the number of buffers in a slab segment decreases as the size of the slab increases.

Default\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{enum\ \{\ N\_SLABBUFFER=9,\ MAX\_SLABBUFFER\_SIZE=8192\};}
\DoxyCodeLine{const\ int\ buffersize[N\_SLABBUFFER]\ =\ \{\ 32,\ 64,128,256,512,1024,2048,4096,8192\ \ \};}
\DoxyCodeLine{const\ int\ nslabs\_default[N\_SLABBUFFER]\ =\ \{\ 512,512,512,512,128,\ \ 64,\ \ 32,\ \ 16,\ \ \ 8\ \};}

\end{DoxyCode}


The number of nslabs is dynamically increased if needed recaliming more memory from OS. This is a reltevely slow and not lock-\/free path of the code.


\begin{DoxyParams}{参数}
{\em \+\_\+nslabs} & an array specifying the allowed numbers of buffers in a \doxylink{classff_1_1_slab_cache}{Slab\+Cache} (overwrite {\ttfamily nslabs\+\_\+default} ) \\
\hline
{\em prealloc} & if \textbackslash{}true use preallocated segments\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
0 if initialisation succedes; a negative value otherwise 
\end{DoxyReturn}
函数调用图\+:
% FIG 8
\Hypertarget{classff_1_1ff__allocator_a9cfb8892d71d1fa72d233cc22b117dbf}\index{ff::ff\_allocator@{ff::ff\_allocator}!malloc@{malloc}}
\index{malloc@{malloc}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{malloc()}{malloc()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a9cfb8892d71d1fa72d233cc22b117dbf} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*} ff\+::ff\+\_\+allocator\+::malloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



malloc 

Request to allocate {\ttfamily size} bytes. If the size is too large, use OS malloc to get a new chunk of memory.

To be called on a \doxylink{classff_1_1ff__allocator}{ff\+::ff\+\_\+allocator} initialised via {\ttfamily ff\+:\doxylink{classff_1_1ff__allocator_a4256355feee6ed6fd39a515da813fbcb}{ff\+\_\+allocator.\+init()}} on the calling \doxylink{classff_1_1ff__node}{ff\+::ff\+\_\+node} (owner). Each \doxylink{classff_1_1ff__allocator}{ff\+::ff\+\_\+allocator} object is owned by the \doxylink{classff_1_1ff__node}{ff\+::ff\+\_\+node} which {\ttfamily register\+Allocator} it. Only the owner can malloc on it, whereas other \doxylink{classff_1_1ff__node}{ff\+\_\+node} can free. More than one \doxylink{classff_1_1ff__allocator}{ff\+::ff\+\_\+allocator} per \doxylink{classff_1_1ff__node}{ff\+\_\+node} can be defined.

Violating ownership cause segfault or unspected behaviour.


\begin{DoxyParams}{参数}
{\em size} & the size of memory requested \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
pointer to allocated memory chunk
\end{DoxyReturn}
\begin{DoxyNote}{注解}
Very efficient but delicate to use, expert only. Not designed to end-\/user but to build Fast\+Flow pattern runtime support. Not expert should use \doxylink{classff_1_1_f_f_allocator}{ff\+::\+FFAllocator} 
\end{DoxyNote}
use standard allocator if the size is too big or we don\textquotesingle{}t want to use the \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator} for that size函数调用图\+:
% FIG 9
\Hypertarget{classff_1_1ff__allocator_a3ad062e04d2c1739a089cbc0a60dda0b}\index{ff::ff\_allocator@{ff::ff\_allocator}!posix\_memalign@{posix\_memalign}}
\index{posix\_memalign@{posix\_memalign}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{posix\_memalign()}{posix\_memalign()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a3ad062e04d2c1739a089cbc0a60dda0b} 
\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} ff\+::ff\+\_\+allocator\+::posix\+\_\+memalign (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{memptr}{, }\item[{size\+\_\+t}]{alignment}{, }\item[{size\+\_\+t}]{size}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



ff posix\+\_\+memalign. 


\begin{DoxyParams}[1]{参数}
\mbox{\texttt{ out}}  & {\em \texorpdfstring{$\ast$}{*}memptr} & pointer to a chunk of memory where the aligned memory will be returned \\
\hline
 & {\em alignment} & allocation\textquotesingle{}s base address is an exact multiple of {\ttfamily alignment}, which must be a power of 2 at least as large as sizeof(void \texorpdfstring{$\ast$}{*}) \\
\hline
 & {\em size} & the size of memory requested. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
0 if successful; otherwise it returns an error value.
\end{DoxyReturn}
\begin{DoxyNote}{注解}
Very efficient but delicate to use, expert only. Not designed to end-\/user but to build Fast\+Flow pattern runtime support. Not expert should use \doxylink{classff_1_1_f_f_allocator}{ff\+::\+FFAllocator} 
\end{DoxyNote}
函数调用图\+:
% FIG 10
\Hypertarget{classff_1_1ff__allocator_a83e8958912ce97820addd8ad2ad999f7}\index{ff::ff\_allocator@{ff::ff\_allocator}!realloc@{realloc}}
\index{realloc@{realloc}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{realloc()}{realloc()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a83e8958912ce97820addd8ad2ad999f7} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*} ff\+::ff\+\_\+allocator\+::realloc (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}}]{ptr}{, }\item[{size\+\_\+t}]{newsize}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



realloc 

It changes the size of the memory block pointed to by {\ttfamily ptr} to {\ttfamily newsize} bytes. If the size is too large, use OS malloc to get a new chunk of memory.

To be called on a \doxylink{classff_1_1ff__allocator}{ff\+::ff\+\_\+allocator} initialised via {\ttfamily \doxylink{classff_1_1ff__allocator_a09e650148ba1d77a17015eb302808714}{register\+Allocator()}} on the calling \doxylink{classff_1_1ff__node}{ff\+::ff\+\_\+node} (owner). Each \doxylink{classff_1_1ff__allocator}{ff\+::ff\+\_\+allocator} object is owned by the \doxylink{classff_1_1ff__node}{ff\+::ff\+\_\+node} which {\ttfamily register\+Allocator} it. Only the owner can malloc/realloc on it, whereas other \doxylink{classff_1_1ff__node}{ff\+\_\+node} can free. More than one \doxylink{classff_1_1ff__allocator}{ff\+::ff\+\_\+allocator} per \doxylink{classff_1_1ff__node}{ff\+\_\+node} can be defined.

Violating ownership cause segfault or unspected behaviour.


\begin{DoxyParams}{参数}
{\em size} & the size of memory requested \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
pointer to allocated memory chunk
\end{DoxyReturn}
\begin{DoxyNote}{注解}
Very efficient but delicate to use, expert only. Not designed to end-\/user but to build Fast\+Flow pattern runtime support. Not expert should use \doxylink{classff_1_1_f_f_allocator}{ff\+::\+FFAllocator} 
\end{DoxyNote}
函数调用图\+:
% FIG 11
\Hypertarget{classff_1_1ff__allocator_ac09381e5eaa8279a60b7a191f2210174}\index{ff::ff\_allocator@{ff::ff\_allocator}!register4free@{register4free}}
\index{register4free@{register4free}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{register4free()}{register4free()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_ac09381e5eaa8279a60b7a191f2210174} 
\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} ff\+::ff\+\_\+allocator\+::register4free (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



register for the free operation 

Threads different from the allocator (i.\+e. those threads that do not allocate memory) have to register themselves to the shared buffer by calling this method. In this way they are provided with a chunk of memory. Since they are registered, once their taks terminates they free the memory assigned and that memory returns back to the allocator thread\textquotesingle{}s buffer, so that it can be reused. 函数调用图\+:
% FIG 12
\Hypertarget{classff_1_1ff__allocator_a09e650148ba1d77a17015eb302808714}\index{ff::ff\_allocator@{ff::ff\_allocator}!registerAllocator@{registerAllocator}}
\index{registerAllocator@{registerAllocator}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{registerAllocator()}{registerAllocator()}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a09e650148ba1d77a17015eb302808714} 
\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} ff\+::ff\+\_\+allocator\+::register\+Allocator (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



register \doxylink{classff_1_1ff__allocator}{ff\+\_\+allocator} (get ownership) 

The \doxylink{classff_1_1ff__node}{ff\+\_\+node} that allocates memory have to call this method in order to register itself to the shared buffer. With this method, a \doxylink{classff_1_1ff__node}{ff\+\_\+node} is allowed to allocate memory. Only one \doxylink{classff_1_1ff__node}{ff\+\_\+node} can allocate memory.

\begin{DoxyReturn}{返回}
0 if operation succedes, -\/1 otherwise 
\end{DoxyReturn}
函数调用图\+:
% FIG 13


\doxysubsection{友元及相关符号说明}
\Hypertarget{classff_1_1ff__allocator_a90dcaed0c9c7a0dc2f18aaa9468cc743}\index{ff::ff\_allocator@{ff::ff\_allocator}!FFAllocator@{FFAllocator}}
\index{FFAllocator@{FFAllocator}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{FFAllocator}{FFAllocator}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a90dcaed0c9c7a0dc2f18aaa9468cc743} 
friend class \mbox{\hyperlink{classff_1_1_f_f_allocator}{FFAllocator}}\hspace{0.3cm}{\ttfamily [friend]}}



\doxysubsection{类成员变量说明}
\Hypertarget{classff_1_1ff__allocator_a83eef76f0a8022f2528e4e23d1ba5603}\index{ff::ff\_allocator@{ff::ff\_allocator}!alloc@{alloc}}
\index{alloc@{alloc}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{alloc}{alloc}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_a83eef76f0a8022f2528e4e23d1ba5603} 
\mbox{\hyperlink{allocator_8hpp_a2fbd97af3a198200b674b6658fb90a50}{ALLSTATS}} ( \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} printstats(std\+::ostream \& out) \{ all\+\_\+stats\+::instance()-\/$>$\mbox{\hyperlink{runtime_2spdlog_2include_2spdlog_2fmt_2bundled_2base_8h_a59025bfaf390e425b4e274c966a77557}{print}}(out); \} ) \mbox{\hyperlink{rml__server_8cpp_a6a1d6e1a12975a4e9a0b5b952e79eaad}{private}} \mbox{\hyperlink{classff_1_1_segment_allocator}{Segment\+Allocator}} ff\+::ff\+\_\+allocator\+::alloc) }

\Hypertarget{classff_1_1ff__allocator_ab4acffca209f242ece598bff4499ba9e}\index{ff::ff\_allocator@{ff::ff\_allocator}!delayedReclaim@{delayedReclaim}}
\index{delayedReclaim@{delayedReclaim}!ff::ff\_allocator@{ff::ff\_allocator}}
\doxysubsubsection{\texorpdfstring{delayedReclaim}{delayedReclaim}}
{\footnotesize\ttfamily \label{classff_1_1ff__allocator_ab4acffca209f242ece598bff4499ba9e} 
const \mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} ff\+::ff\+\_\+allocator\+::delayed\+Reclaim}



该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
external/taskflow/3rd-\/party/ff/\mbox{\hyperlink{allocator_8hpp}{allocator.\+hpp}}\end{DoxyCompactItemize}
