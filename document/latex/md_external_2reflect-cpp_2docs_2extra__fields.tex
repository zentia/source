\chapter{\texorpdfstring{$<$}{<}tt\texorpdfstring{$>$}{>}rfl\+::Extra\+Fields\texorpdfstring{$<$}{<}/tt\texorpdfstring{$>$}{>}}
\hypertarget{md_external_2reflect-cpp_2docs_2extra__fields}{}\label{md_external_2reflect-cpp_2docs_2extra__fields}\index{$<$tt$>$rfl::ExtraFields$<$/tt$>$@{$<$tt$>$rfl::ExtraFields$<$/tt$>$}}
\label{md_external_2reflect-cpp_2docs_2extra__fields_autotoc_md576}%
\Hypertarget{md_external_2reflect-cpp_2docs_2extra__fields_autotoc_md576}%


In some cases, you simply do not know all of the possible field names at compile time. You might know some, but you do not know all of them.

Note that there are many ways of dealing with these kind of uncertainties, such as optional fields or tagged unions.

But in instance where the field names are absolutely not known in advance, you might want to use {\ttfamily \doxylink{classrfl_1_1_extra_fields}{rfl\+::\+Extra\+Fields}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ std::string\ first\_name;}
\DoxyCodeLine{\ \ std::string\ last\_name\ =\ \textcolor{stringliteral}{"{}Simpson"{}};}
\DoxyCodeLine{\ \ rfl::ExtraFields<rfl::Generic>\ extra\_fields;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ homer\ =\ Person\{.first\_name\ =\ \textcolor{stringliteral}{"{}Homer"{}}\};}
\DoxyCodeLine{}
\DoxyCodeLine{homer.extra\_fields[\textcolor{stringliteral}{"{}age"{}}]\ =\ 45;}
\DoxyCodeLine{homer.extra\_fields[\textcolor{stringliteral}{"{}email"{}}]\ =\ \textcolor{stringliteral}{"{}homer@simpson.com"{}};}
\DoxyCodeLine{homer.extra\_fields[\textcolor{stringliteral}{"{}town"{}}]\ =\ \textcolor{stringliteral}{"{}Springfield"{}};}

\end{DoxyCode}


Note that {\ttfamily \doxylink{classrfl_1_1_extra_fields}{rfl\+::\+Extra\+Fields}} inherits from {\ttfamily \doxylink{classrfl_1_1_object}{rfl\+::\+Object}} and therefore behaves exactly like it. Refer to the relevant section of the documentation on {\ttfamily \doxylink{classrfl_1_1_object}{rfl\+::\+Object}}.

This will result in the following JSON string\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}first\_name"{}:"{}Homer"{},"{}last\_name"{}:"{}Simpson"{},"{}age"{}:45,"{}email"{}:"{}homer@simpson.com"{},"{}town"{}:"{}Springfield"{}\}}

\end{DoxyCode}


Likewise, when we parse the JSON string, all of the fields that can\textquotesingle{}t be directly matched to a known field will be parsed into {\ttfamily extra\+\_\+fields}.

Note that in this particular instance, we have set the type to {\ttfamily \doxylink{classrfl_1_1_generic}{rfl\+::\+Generic}}. But if we know in advance that all of the extra fields must be strings, we can set it to {\ttfamily std\+::string} as well\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ std::string\ first\_name;}
\DoxyCodeLine{\ \ std::string\ last\_name\ =\ \textcolor{stringliteral}{"{}Simpson"{}};}
\DoxyCodeLine{\ \ rfl::ExtraFields<std::string>\ extra\_fields;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ homer\ =\ Person\{.first\_name\ =\ \textcolor{stringliteral}{"{}Homer"{}}\};}
\DoxyCodeLine{}
\DoxyCodeLine{homer.extra\_fields[\textcolor{stringliteral}{"{}email"{}}]\ =\ \textcolor{stringliteral}{"{}homer@simpson.com"{}};}
\DoxyCodeLine{homer.extra\_fields[\textcolor{stringliteral}{"{}town"{}}]\ =\ \textcolor{stringliteral}{"{}Springfield"{}};}

\end{DoxyCode}


This will result in the following JSON string\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{"{}first\_name"{}:"{}Homer"{},"{}last\_name"{}:"{}Simpson"{},"{}email"{}:"{}homer@simpson.com"{},"{}town"{}:"{}Springfield"{}\}}

\end{DoxyCode}


If we add an extra field that is not a string (like {\ttfamily "{}age"{}\+:45}), this will result in a parsing error. 