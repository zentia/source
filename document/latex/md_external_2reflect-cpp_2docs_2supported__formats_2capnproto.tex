\chapter{Cap\textquotesingle{}n Proto}
\hypertarget{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto}{}\label{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto}\index{Cap\textquotesingle{}n Proto@{Cap\textquotesingle{}n Proto}}
\label{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md643}%
\Hypertarget{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md643}%


For Cap\textquotesingle{}n \doxylink{ff__network_8hpp_a935ab6746fea268e5bb60a8755bc3c1e}{Proto} support, you must also include the header {\ttfamily \texorpdfstring{$<$}{<}\doxylink{capnproto_8hpp}{rfl/capnproto.\+hpp}\texorpdfstring{$>$}{>}} and link to the \href{https://capnproto.org}{\texttt{ capnproto}} library. Furthermore, when compiling reflect-\/cpp, you need to pass {\ttfamily -\/DREFLECTCPP\+\_\+\+CAPNPROTO=ON} to cmake. If you are using vcpkg or Conan, there should be an appropriate feature (vcpkg) or option (Conan) that will abstract this away for you.

Cap\textquotesingle{}n \doxylink{ff__network_8hpp_a935ab6746fea268e5bb60a8755bc3c1e}{Proto} is a schemaful binary format. This sets it apart from most other formats supported by reflect-\/cpp, which are schemaless.\hypertarget{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md644}{}\doxysection{\texorpdfstring{Reading and writing}{Reading and writing}}\label{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md644}
Suppose you have a struct like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ \ \ std::string\ first\_name;}
\DoxyCodeLine{\ \ \ \ std::string\ last\_name;}
\DoxyCodeLine{\ \ \ \ rfl::Timestamp<\textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%d"{}}>\ birthday;}
\DoxyCodeLine{\ \ \ \ std::vector<Person>\ children;}
\DoxyCodeLine{\};}

\end{DoxyCode}


\doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} {\ttfamily Person} struct can be serialized to a bytes vector like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ person\ =\ Person\{...\};}
\DoxyCodeLine{\textcolor{keyword}{const}\ std::vector<char>\ \mbox{\hyperlink{structbytes}{bytes}}\ =\ \mbox{\hyperlink{namespacerfl_1_1capnproto_a97cdd1f9f6fde9fa46ecb92e3acbe944}{rfl::capnproto::write}}(person);}

\end{DoxyCode}


You can parse bytes like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \mbox{\hyperlink{classrfl_1_1_result}{rfl::Result<Person>}}\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}\ =\ \mbox{\hyperlink{namespacerfl_1_1capnproto_adeed5ace86b284cc00ea03de1c1d1fd8}{rfl::capnproto::read<Person>}}(\mbox{\hyperlink{structbytes}{bytes}});}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md645}{}\doxysection{\texorpdfstring{The schema}{The schema}}\label{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md645}
However, Cap\textquotesingle{}n \doxylink{ff__network_8hpp_a935ab6746fea268e5bb60a8755bc3c1e}{Proto} is a schemaful format, so before you serialize or deserialize, you have to declare a schema. In the two function calls above, this is abstracted away.

If you want to, you can pass the schema explicitly, but it will not yield any performance gains, because the schemata are always created upfront\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ schema\ =\ \mbox{\hyperlink{namespacerfl_1_1capnproto_a38e054f1b60ac90a0030316a2e2f2a74}{rfl::capnproto::to\_schema<Person>}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ person\ =\ Person\{...\};}
\DoxyCodeLine{\textcolor{keyword}{const}\ std::vector<char>\ \mbox{\hyperlink{structbytes}{bytes}}\ =\ \mbox{\hyperlink{namespacerfl_1_1capnproto_a97cdd1f9f6fde9fa46ecb92e3acbe944}{rfl::capnproto::write}}(person,\ schema);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \mbox{\hyperlink{classrfl_1_1_result}{rfl::Result<Person>}}\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}\ =\ \mbox{\hyperlink{namespacerfl_1_1capnproto_adeed5ace86b284cc00ea03de1c1d1fd8}{rfl::capnproto::read<Person>}}(\mbox{\hyperlink{structbytes}{bytes}},\ schema);}

\end{DoxyCode}


Cap\textquotesingle{}n \doxylink{ff__network_8hpp_a935ab6746fea268e5bb60a8755bc3c1e}{Proto} schemas are created using a schema language. You can retrieve the schema like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{schema.str();}

\end{DoxyCode}


In this case, the resulting schema representation looks like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{@0xdbb9ad1f14bf0b36;}
\DoxyCodeLine{}
\DoxyCodeLine{struct\ Person\ \{}
\DoxyCodeLine{\ \ firstName\ @0\ :Text;}
\DoxyCodeLine{\ \ lastName\ @1\ :Text;}
\DoxyCodeLine{\ \ birthday\ @2\ :Text;}
\DoxyCodeLine{\ \ children\ @3\ :List(Person);}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md646}{}\doxysection{\texorpdfstring{Loading and saving}{Loading and saving}}\label{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md646}
You can also load and save to disc using a very similar syntax\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \mbox{\hyperlink{classrfl_1_1_result}{rfl::Result<Person>}}\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}\ =\ \mbox{\hyperlink{namespacerfl_1_1capnproto_ab03800a4b3144b2c568b9ea755b31e95}{rfl::capnproto::load<Person>}}(\textcolor{stringliteral}{"{}/path/to/file.capnproto"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ person\ =\ Person\{...\};}
\DoxyCodeLine{\mbox{\hyperlink{namespacerfl_1_1capnproto_a131e192048571b2858cfc7f46b294413}{rfl::capnproto::save}}(\textcolor{stringliteral}{"{}/path/to/file.capnproto"{}},\ person);}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md647}{}\doxysection{\texorpdfstring{Reading from and writing into streams}{Reading from and writing into streams}}\label{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md647}
You can also read from and write into any {\ttfamily std\+::istream} and {\ttfamily std\+::ostream} respectively.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \mbox{\hyperlink{classrfl_1_1_result}{rfl::Result<Person>}}\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}\ =\ \mbox{\hyperlink{namespacerfl_1_1capnproto_adeed5ace86b284cc00ea03de1c1d1fd8}{rfl::capnproto::read<Person>}}(my\_istream);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ person\ =\ Person\{...\};}
\DoxyCodeLine{\mbox{\hyperlink{namespacerfl_1_1capnproto_a97cdd1f9f6fde9fa46ecb92e3acbe944}{rfl::capnproto::write}}(person,\ my\_ostream);}

\end{DoxyCode}


Note that {\ttfamily std\+::cout} is also an ostream, so this works as well\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacerfl_1_1capnproto_a97cdd1f9f6fde9fa46ecb92e3acbe944}{rfl::capnproto::write}}(person,\ std::cout)\ <<\ std::endl;}

\end{DoxyCode}


(Since Cap\textquotesingle{}n \doxylink{ff__network_8hpp_a935ab6746fea268e5bb60a8755bc3c1e}{Proto} is a binary format, the readability of this will be limited, but it might be useful for debugging).\hypertarget{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md648}{}\doxysection{\texorpdfstring{Custom constructors}{Custom constructors}}\label{md_external_2reflect-cpp_2docs_2supported__formats_2capnproto_autotoc_md648}
One of the great things about C++ is that it gives you control over when and how you code is compiled.

For large and complex systems of structs, it is often a good idea to split up your code into smaller compilation units. You can do so using custom constructors.

For the Cap\textquotesingle{}n \doxylink{ff__network_8hpp_a935ab6746fea268e5bb60a8755bc3c1e}{Proto} format, these must be a static function on your struct or class called {\ttfamily from\+\_\+capnproto} that take a {\ttfamily \doxylink{classrfl_1_1capnproto_1_1_reader_ad967a6289bf1308b9a4139b9737a42f9}{rfl\+::capnproto\+::\+Reader\+::\+Input\+Var\+Type}} as input and return the class or the class wrapped in {\ttfamily \doxylink{classrfl_1_1_result}{rfl\+::\+Result}}.

In your header file you can write something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ \ \ rfl::Rename<\textcolor{stringliteral}{"{}firstName"{}},\ std::string>\ first\_name;}
\DoxyCodeLine{\ \ \ \ rfl::Rename<\textcolor{stringliteral}{"{}lastName"{}},\ std::string>\ last\_name;}
\DoxyCodeLine{\ \ \ \ rfl::Timestamp<\textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%d"{}}>\ birthday;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{using\ }\mbox{\hyperlink{namespacerfl_1_1avro_a1b87f8b534d31b79c6cdcb844cc0ff8f}{InputVarType}}\ =\ \textcolor{keyword}{typename}\ \mbox{\hyperlink{classrfl_1_1capnproto_1_1_reader_ad967a6289bf1308b9a4139b9737a42f9}{rfl::capnproto::Reader::InputVarType}};}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{static}\ rfl::Result<Person>\ from\_capnproto(\textcolor{keyword}{const}\ InputVarType\&\ \_obj);}
\DoxyCodeLine{\};}

\end{DoxyCode}


And in your source file, you implement {\ttfamily from\+\_\+capnproto} as follows\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classrfl_1_1_result}{rfl::Result<Person>}}\ Person::from\_capnproto(\textcolor{keyword}{const}\ InputVarType\&\ \_obj)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ from\_nt\ =\ [](\textcolor{keyword}{auto}\&\&\ \_nt)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespacerfl_a5acb20e6bf6611a2a9f26931513b29f7}{rfl::from\_named\_tuple<Person>}}(std::move(\_nt));}
\DoxyCodeLine{\ \ \ \ \};}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespacerfl_1_1capnproto_adeed5ace86b284cc00ea03de1c1d1fd8}{rfl::capnproto::read<rfl::named\_tuple\_t<Person>}}>(\_obj)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ .\mbox{\hyperlink{sycl__algorithms_8cpp_abe0cf4a907cfd4631a4d7c7647692a0a}{transform}}(from\_nt);}
\DoxyCodeLine{\}}

\end{DoxyCode}


This will force the compiler to only compile the Cap\textquotesingle{}n \doxylink{ff__network_8hpp_a935ab6746fea268e5bb60a8755bc3c1e}{Proto} parsing when the source file is compiled. 