\doxysection{eastl\+::linked\+\_\+ptr\texorpdfstring{$<$}{<} T, Deleter \texorpdfstring{$>$}{>} 模板类 参考}
\hypertarget{classeastl_1_1linked__ptr}{}\label{classeastl_1_1linked__ptr}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}


{\ttfamily \#include $<$linked\+\_\+ptr.\+h$>$}



类 eastl\+::linked\+\_\+ptr\texorpdfstring{$<$}{<} T, Deleter \texorpdfstring{$>$}{>} 继承关系图\+:
% FIG 0


eastl\+::linked\+\_\+ptr\texorpdfstring{$<$}{<} T, Deleter \texorpdfstring{$>$}{>} 的协作图\+:
% FIG 1
\doxysubsubsection*{Public 类型}
\begin{DoxyCompactItemize}
\item 
typedef T \mbox{\hyperlink{classeastl_1_1linked__ptr_a2f0908ebf7b13c2630e93f352ba69887}{element\+\_\+type}}
\item 
typedef T \texorpdfstring{$\ast$}{*}(this\+\_\+type\+::\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1linked__ptr_a771161099a69a850d199bd4079bbb548}{bool\+\_\+}}) () const
\end{DoxyCompactItemize}
\doxysubsubsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classeastl_1_1linked__ptr_ac73d310c1e6d5d8be689dbbd10de897e}{linked\+\_\+ptr}} ()
\item 
{\footnotesize template$<$typename U$>$ }\\\mbox{\hyperlink{classeastl_1_1linked__ptr_a1514af0769e38f85b99155781ddfa39e}{linked\+\_\+ptr}} (U \texorpdfstring{$\ast$}{*}p\+Value)
\item 
\mbox{\hyperlink{classeastl_1_1linked__ptr_a7c3c6f401102027653a579732ac60a73}{linked\+\_\+ptr}} (const \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}} \&linked\+Ptr)
\item 
{\footnotesize template$<$typename U, typename D$>$ }\\\mbox{\hyperlink{classeastl_1_1linked__ptr_a654f1049b77365c74bb07df4710ecc75}{linked\+\_\+ptr}} (const \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}}$<$ U, D $>$ \&linked\+Ptr)
\item 
\mbox{\hyperlink{classeastl_1_1linked__ptr_adace2b9113d6899c21dea223cc62efcd}{\texorpdfstring{$\sim$}{\string~}linked\+\_\+ptr}} ()
\item 
\mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}} \& \mbox{\hyperlink{classeastl_1_1linked__ptr_ab919ed5d9ac550078f5c31815ed3039d}{operator=}} (const \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}} \&linked\+Ptr)
\item 
{\footnotesize template$<$typename U, typename D$>$ }\\\mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}} \& \mbox{\hyperlink{classeastl_1_1linked__ptr_a2752abff39a1fe28268d0bed2db68176}{operator=}} (const \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}}$<$ U, D $>$ \&linked\+Ptr)
\item 
{\footnotesize template$<$typename U$>$ }\\\mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}} \& \mbox{\hyperlink{classeastl_1_1linked__ptr_af3dd972777429c217b028a8c15581117}{operator=}} (U \texorpdfstring{$\ast$}{*}p\+Value)
\item 
{\footnotesize template$<$typename U$>$ }\\\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classeastl_1_1linked__ptr_a0dc9108251fb8f739bf955c2c7790169}{reset}} (U \texorpdfstring{$\ast$}{*}p\+Value)
\item 
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classeastl_1_1linked__ptr_aa594f2224fba14fa7863ce22894c9680}{reset}} ()
\item 
T \& \mbox{\hyperlink{classeastl_1_1linked__ptr_acd131c70eda8dfdaec0b4d329427fa10}{operator\texorpdfstring{$\ast$}{*}}} () const
\item 
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1linked__ptr_af1e5f61987fe7eb783de0238e5f38543}{operator-\/$>$}} () const
\item 
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1linked__ptr_a7942723a00d641ed6022260bcea7820f}{get}} () const
\item 
\mbox{\hyperlink{sugar_8h_ae88a82478e3818cade3f598c25437904}{int}} \mbox{\hyperlink{classeastl_1_1linked__ptr_ae828cbcc492f87d3454f71e93c186679}{use\+\_\+count}} () const
\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classeastl_1_1linked__ptr_a5722cb4c2749c46a83e560c646d5cda5}{unique}} () const
\item 
\mbox{\hyperlink{classeastl_1_1linked__ptr_a5bde70cdcc613c40758df819c8dfa337}{operator bool\+\_\+}} () const
\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classeastl_1_1linked__ptr_aab53b72c07f6fe6ace781f5635d3ba9e}{operator!}} ()
\item 
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1linked__ptr_a7f9c644f1e2f96aa2bdb6a5d10ec7c2a}{detach}} ()
\item 
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classeastl_1_1linked__ptr_adc61de8707789f174ace5d11bf961048}{force\+\_\+delete}} ()
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected 类型}
\begin{DoxyCompactItemize}
\item 
typedef \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}}$<$ T $>$ \mbox{\hyperlink{classeastl_1_1linked__ptr_ae9f38fb44b1e79fb038298b1ba6033c8}{this\+\_\+type}}
\item 
typedef Deleter \mbox{\hyperlink{classeastl_1_1linked__ptr_a0f880517c0cefdbbaebc08a07e11385e}{deleter\+\_\+type}}
\begin{DoxyCompactList}\small\item\em \doxylink{classeastl_1_1linked__ptr_a0f880517c0cefdbbaebc08a07e11385e}{deleter\+\_\+type} \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected 成员函数}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename U, typename D$>$ }\\\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classeastl_1_1linked__ptr_afe0da5bc9ff344b74ebb18df767d82bb}{link}} (const \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}}$<$ U, D $>$ \&linked\+Ptr)
\begin{DoxyCompactList}\small\item\em The owned pointer. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Protected 属性}
\begin{DoxyCompactItemize}
\item 
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1linked__ptr_ac189cf1eb8bc78304cd035e8388e6aa2}{mp\+Value}}
\end{DoxyCompactItemize}
\doxysubsubsection*{友元}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename U, typename D$>$ }\\class \mbox{\hyperlink{classeastl_1_1linked__ptr_a8ea295ed847b48ec359360c0e28bab91}{linked\+\_\+ptr}}
\end{DoxyCompactItemize}
\doxysubsubsection*{额外继承的成员函数}
\doxysubsection*{Public 属性 继承自 \mbox{\hyperlink{structeastl_1_1linked__ptr__base}{eastl\+::linked\+\_\+ptr\+\_\+base}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structeastl_1_1linked__ptr__base}{linked\+\_\+ptr\+\_\+base}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{structeastl_1_1linked__ptr__base_a96453143d5afe24b4180efee5a17cf28}{mp\+Prev}}
\item 
\mbox{\hyperlink{structeastl_1_1linked__ptr__base}{linked\+\_\+ptr\+\_\+base}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{structeastl_1_1linked__ptr__base_ab6b5e646204d4ea13f9ed3730583111d}{mp\+Next}}
\end{DoxyCompactItemize}


\doxysubsection{详细描述}
\subsubsection*{template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$\newline
class eastl\+::linked\+\_\+ptr$<$ T, Deleter $>$}
\doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}

This class implements a \doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} template. A \doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} is like the C++ Standard Library auto\+\_\+ptr except that it allows sharing of pointers between instances of auto\+\_\+ptr via reference counting. \doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} objects can safely be copied and can safely be used in C++ Standard Library containers such as std\+::vector or std\+::list. This implementation, however, is not thread-\/safe. you would need to use a separate linked\+\_\+ptr\+\_\+mt (multi-\/threaded) to get thread safety.

\doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} is a variation of \doxylink{classeastl_1_1shared__ptr}{shared\+\_\+ptr} (a.\+k.\+a. counted\+\_\+ptr) which differs in that instead of being implemented by a shared integer stored on the heap, it is implemented by linked list stored within the \doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} object itself. The result is that no memory is explicitly allocated from the heap, though the cost of each \doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} object is 12 bytes of memory (32 bit machine) instead of 4 bytes for the case of \doxylink{classeastl_1_1shared__ptr}{shared\+\_\+ptr} (depending on the heap). 

\doxysubsection{成员类型定义说明}
\Hypertarget{classeastl_1_1linked__ptr_a771161099a69a850d199bd4079bbb548}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!bool\_@{bool\_}}
\index{bool\_@{bool\_}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{bool\_}{bool\_}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a771161099a69a850d199bd4079bbb548} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
typedef T \texorpdfstring{$\ast$}{*}(this\+\_\+type\+::\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::bool\+\_\+) () const}

Implicit operator bool Allows for using a \doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} as a boolean. Note that below we do not use operator \doxylink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool()}. The reason for this is that booleans automatically convert up to short, int, float, etc. The result is that this\+: if(linked\+Ptr == 1) would yield true (bad). \Hypertarget{classeastl_1_1linked__ptr_a0f880517c0cefdbbaebc08a07e11385e}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!deleter\_type@{deleter\_type}}
\index{deleter\_type@{deleter\_type}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{deleter\_type}{deleter\_type}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a0f880517c0cefdbbaebc08a07e11385e} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
typedef Deleter \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::deleter\+\_\+type\hspace{0.3cm}{\ttfamily [protected]}}



\doxylink{classeastl_1_1linked__ptr_a0f880517c0cefdbbaebc08a07e11385e}{deleter\+\_\+type} 

\Hypertarget{classeastl_1_1linked__ptr_a2f0908ebf7b13c2630e93f352ba69887}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!element\_type@{element\_type}}
\index{element\_type@{element\_type}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{element\_type}{element\_type}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a2f0908ebf7b13c2630e93f352ba69887} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
typedef T \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::element\+\_\+type}

\doxylink{classeastl_1_1linked__ptr_a2f0908ebf7b13c2630e93f352ba69887}{element\+\_\+type} Synonym for type T, useful for external code to reference the type in a generic way. \Hypertarget{classeastl_1_1linked__ptr_ae9f38fb44b1e79fb038298b1ba6033c8}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!this\_type@{this\_type}}
\index{this\_type@{this\_type}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{this\_type}{this\_type}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_ae9f38fb44b1e79fb038298b1ba6033c8} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
typedef \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}}$<$T$>$ \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::this\+\_\+type\hspace{0.3cm}{\ttfamily [protected]}}

\doxylink{classeastl_1_1linked__ptr_ae9f38fb44b1e79fb038298b1ba6033c8}{this\+\_\+type} This is an alias for linked\+\_\+ptr$<$\+T$>$, this class. 

\doxysubsection{构造及析构函数说明}
\Hypertarget{classeastl_1_1linked__ptr_ac73d310c1e6d5d8be689dbbd10de897e}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!linked\_ptr@{linked\_ptr}}
\index{linked\_ptr@{linked\_ptr}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{linked\_ptr()}{linked\_ptr()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_ac73d310c1e6d5d8be689dbbd10de897e} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::linked\+\_\+ptr (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} Default constructor. \Hypertarget{classeastl_1_1linked__ptr_a1514af0769e38f85b99155781ddfa39e}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!linked\_ptr@{linked\_ptr}}
\index{linked\_ptr@{linked\_ptr}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{linked\_ptr()}{linked\_ptr()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a1514af0769e38f85b99155781ddfa39e} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
template$<$typename U$>$ \\
\mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::linked\+\_\+ptr (\begin{DoxyParamCaption}\item[{U \texorpdfstring{$\ast$}{*}}]{p\+Value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}

\doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} Takes ownership of the pointer. It is OK if the input pointer is null. \Hypertarget{classeastl_1_1linked__ptr_a7c3c6f401102027653a579732ac60a73}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!linked\_ptr@{linked\_ptr}}
\index{linked\_ptr@{linked\_ptr}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{linked\_ptr()}{linked\_ptr()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a7c3c6f401102027653a579732ac60a73} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::linked\+\_\+ptr (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}}$<$ T, Deleter $>$ \&}]{linked\+Ptr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} Construction with self type. If we want a \doxylink{classeastl_1_1shared__ptr}{shared\+\_\+ptr} constructor that is templated on \doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}\uline{, then we need to make it in addition to this function, as otherwise the compiler will generate this function and things will go wrong. }函数调用图\+:
% FIG 2
\Hypertarget{classeastl_1_1linked__ptr_a654f1049b77365c74bb07df4710ecc75}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!linked\_ptr@{linked\_ptr}}
\index{linked\_ptr@{linked\_ptr}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{linked\_ptr()}{linked\_ptr()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a654f1049b77365c74bb07df4710ecc75} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
template$<$typename U, typename D$>$ \\
\mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::linked\+\_\+ptr (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}}$<$ U, D $>$ \&}]{linked\+Ptr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} Shares ownership of a pointer with another instance of \doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}. 函数调用图\+:
% FIG 3
\Hypertarget{classeastl_1_1linked__ptr_adace2b9113d6899c21dea223cc62efcd}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!````~linked\_ptr@{\texorpdfstring{$\sim$}{\string~}linked\_ptr}}
\index{````~linked\_ptr@{\texorpdfstring{$\sim$}{\string~}linked\_ptr}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{\texorpdfstring{$\sim$}{\string~}linked\_ptr()}{\string~linked\_ptr()}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_adace2b9113d6899c21dea223cc62efcd} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::\texorpdfstring{$\sim$}{\string~}\mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\texorpdfstring{$\sim$}{\string~}linked\+\_\+ptr Removes this object from the of objects using the shared pointer. If this object is the last owner of the shared pointer, the shared pointer is deleted. 函数调用图\+:
% FIG 4


\doxysubsection{成员函数说明}
\Hypertarget{classeastl_1_1linked__ptr_a7f9c644f1e2f96aa2bdb6a5d10ec7c2a}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!detach@{detach}}
\index{detach@{detach}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{detach()}{detach()}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a7f9c644f1e2f96aa2bdb6a5d10ec7c2a} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::detach (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

detach Returns ownership of the pointer to the caller. Fixes all references to the pointer by any other owners to be NULL. This function can work properly only if all entries in the list refer to type T and none refer to any other type (e.\+g. U). \Hypertarget{classeastl_1_1linked__ptr_adc61de8707789f174ace5d11bf961048}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!force\_delete@{force\_delete}}
\index{force\_delete@{force\_delete}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{force\_delete()}{force\_delete()}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_adc61de8707789f174ace5d11bf961048} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::force\+\_\+delete (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

force\+\_\+delete Forces deletion of the shared pointer. Fixes all references to the pointer by any other owners to be NULL. This function can work properly only if all entries in the list refer to type T and none refer to any other type (e.\+g. U). 函数调用图\+:
% FIG 5
\Hypertarget{classeastl_1_1linked__ptr_a7942723a00d641ed6022260bcea7820f}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!get@{get}}
\index{get@{get}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{get()}{get()}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a7942723a00d641ed6022260bcea7820f} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::get (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

get Returns the owned pointer. Note that this class does not provide an operator T() function. This is because such a thing (automatic conversion) is deemed unsafe. \Hypertarget{classeastl_1_1linked__ptr_afe0da5bc9ff344b74ebb18df767d82bb}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!link@{link}}
\index{link@{link}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{link()}{link()}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_afe0da5bc9ff344b74ebb18df767d82bb} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
template$<$typename U, typename D$>$ \\
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::link (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}}$<$ U, D $>$ \&}]{linked\+Ptr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



The owned pointer. 

函数调用图\+:
% FIG 6
\Hypertarget{classeastl_1_1linked__ptr_a5bde70cdcc613c40758df819c8dfa337}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!operator bool\_@{operator bool\_}}
\index{operator bool\_@{operator bool\_}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator bool\_()}{operator bool\_()}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a5bde70cdcc613c40758df819c8dfa337} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::operator \mbox{\hyperlink{classeastl_1_1linked__ptr_a771161099a69a850d199bd4079bbb548}{bool\+\_\+}} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

函数调用图\+:
% FIG 7
\Hypertarget{classeastl_1_1linked__ptr_aab53b72c07f6fe6ace781f5635d3ba9e}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!operator"!@{operator"!}}
\index{operator"!@{operator"!}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator"!()}{operator!()}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_aab53b72c07f6fe6ace781f5635d3ba9e} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::operator! (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

operator! This returns the opposite of operator bool; it returns true if the owned pointer is null. Some compilers require this and some don\textquotesingle{}t. \Hypertarget{classeastl_1_1linked__ptr_acd131c70eda8dfdaec0b4d329427fa10}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}}
\index{operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator\texorpdfstring{$\ast$}{*}()}{operator*()}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_acd131c70eda8dfdaec0b4d329427fa10} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
T \& \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::operator\texorpdfstring{$\ast$}{*} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

swap Exchanges the owned pointer beween two linked\+Ptr objects.

This function is disabled as it is currently deemed unsafe. The problem is that the only way to implement this function is to transfer pointers between the objects; you cannot transfer the linked list membership between the objects. Thus unless both \doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} objects were \textquotesingle{}\doxylink{classeastl_1_1linked__ptr_a5722cb4c2749c46a83e560c646d5cda5}{unique()}\textquotesingle{}, the shared pointers would be duplicated amongst containers, resulting in a crash. operator\texorpdfstring{$\ast$}{*} Returns the owner pointer dereferenced. \Hypertarget{classeastl_1_1linked__ptr_af1e5f61987fe7eb783de0238e5f38543}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!operator-\/$>$@{operator-\/$>$}}
\index{operator-\/$>$@{operator-\/$>$}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator-\/$>$()}{operator->()}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_af1e5f61987fe7eb783de0238e5f38543} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::operator-\/$>$ (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

operator-\/\texorpdfstring{$>$}{>} Allows access to the owned pointer via \doxylink{classeastl_1_1linked__ptr_af1e5f61987fe7eb783de0238e5f38543}{operator-\/$>$()} \Hypertarget{classeastl_1_1linked__ptr_ab919ed5d9ac550078f5c31815ed3039d}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!operator=@{operator=}}
\index{operator=@{operator=}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_ab919ed5d9ac550078f5c31815ed3039d} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}} \& \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}}$<$ T, Deleter $>$ \&}]{linked\+Ptr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

operator= If we want a \doxylink{classeastl_1_1shared__ptr}{shared\+\_\+ptr} operator= that is templated on \doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}\uline{, then we need to make it in addition to this function, as otherwise the compiler will generate this function and things will go wrong. }函数调用图\+:
% FIG 8
\Hypertarget{classeastl_1_1linked__ptr_a2752abff39a1fe28268d0bed2db68176}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!operator=@{operator=}}
\index{operator=@{operator=}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a2752abff39a1fe28268d0bed2db68176} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
template$<$typename U, typename D$>$ \\
\mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}} \& \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}}$<$ U, D $>$ \&}]{linked\+Ptr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

operator= Copies another \doxylink{classeastl_1_1linked__ptr}{linked\+\_\+ptr} to this object. Note that this object may already own a shared pointer with another different pointer (but still of the same type) before this call. In that case, this function removes ownership of the old pointer and takes shared ownership of the new pointer and increments its reference count. 函数调用图\+:
% FIG 9
\Hypertarget{classeastl_1_1linked__ptr_af3dd972777429c217b028a8c15581117}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!operator=@{operator=}}
\index{operator=@{operator=}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_af3dd972777429c217b028a8c15581117} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
template$<$typename U$>$ \\
\mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}} \& \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::operator= (\begin{DoxyParamCaption}\item[{U \texorpdfstring{$\ast$}{*}}]{p\+Value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

operator= Assigns a new pointer. If the new pointer is equivalent to the current pointer, nothing is done. Otherwise the current pointer is unlinked and possibly destroyed. The new pointer can be NULL. 函数调用图\+:
% FIG 10
\Hypertarget{classeastl_1_1linked__ptr_aa594f2224fba14fa7863ce22894c9680}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!reset@{reset}}
\index{reset@{reset}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_aa594f2224fba14fa7863ce22894c9680} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::reset (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

reset Resets the container with NULL. If the current pointer is non-\/\+NULL, it is unlinked and possibly destroyed. 函数调用图\+:
% FIG 11
\Hypertarget{classeastl_1_1linked__ptr_a0dc9108251fb8f739bf955c2c7790169}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!reset@{reset}}
\index{reset@{reset}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a0dc9108251fb8f739bf955c2c7790169} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
template$<$typename U$>$ \\
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::reset (\begin{DoxyParamCaption}\item[{U \texorpdfstring{$\ast$}{*}}]{p\+Value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

reset Releases the owned pointer and takes ownership of the passed in pointer. If the passed in pointer is the same as the owned pointer, nothing is done. The passed in pointer can be NULL, in which case the use count is set to 1. 函数调用图\+:
% FIG 12
\Hypertarget{classeastl_1_1linked__ptr_a5722cb4c2749c46a83e560c646d5cda5}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!unique@{unique}}
\index{unique@{unique}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a5722cb4c2749c46a83e560c646d5cda5} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::unique (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

unique Returns true if the use count of the owned pointer is one. The return value is true if the owned pointer is null. \Hypertarget{classeastl_1_1linked__ptr_ae828cbcc492f87d3454f71e93c186679}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!use\_count@{use\_count}}
\index{use\_count@{use\_count}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{use\_count()}{use\_count()}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_ae828cbcc492f87d3454f71e93c186679} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{sugar_8h_ae88a82478e3818cade3f598c25437904}{int}} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::use\+\_\+count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

use\+\_\+count Returns the use count of the shared pointer. The return value is one if the owned pointer is null. This function is provided for compatibility with the proposed C++ standard and for debugging purposes. It is not intended for runtime use given that its execution time is not constant. 

\doxysubsection{友元及相关符号说明}
\Hypertarget{classeastl_1_1linked__ptr_a8ea295ed847b48ec359360c0e28bab91}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!linked\_ptr@{linked\_ptr}}
\index{linked\_ptr@{linked\_ptr}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{linked\_ptr}{linked\_ptr}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_a8ea295ed847b48ec359360c0e28bab91} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
template$<$typename U, typename D$>$ \\
friend class \mbox{\hyperlink{classeastl_1_1linked__ptr}{linked\+\_\+ptr}}\hspace{0.3cm}{\ttfamily [friend]}}



\doxysubsection{类成员变量说明}
\Hypertarget{classeastl_1_1linked__ptr_ac189cf1eb8bc78304cd035e8388e6aa2}\index{eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}!mpValue@{mpValue}}
\index{mpValue@{mpValue}!eastl::linked\_ptr$<$ T, Deleter $>$@{eastl::linked\_ptr$<$ T, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{mpValue}{mpValue}}
{\footnotesize\ttfamily \label{classeastl_1_1linked__ptr_ac189cf1eb8bc78304cd035e8388e6aa2} 
template$<$typename T, typename Deleter = smart\+\_\+ptr\+\_\+deleter$<$\+T$>$$>$ \\
T\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1linked__ptr}{eastl\+::linked\+\_\+ptr}}$<$ T, Deleter $>$\+::mp\+Value\hspace{0.3cm}{\ttfamily [protected]}}



该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
runtime/\+EASTL/include/\+EASTL/\mbox{\hyperlink{linked__ptr_8h}{linked\+\_\+ptr.\+h}}\end{DoxyCompactItemize}
