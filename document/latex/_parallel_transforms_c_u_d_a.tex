\doxysection{Parallel Transforms}
\hypertarget{_parallel_transforms_c_u_d_a}{}\label{_parallel_transforms_c_u_d_a}\index{Parallel Transforms@{Parallel Transforms}}
\doxylink{classtf_1_1cuda_flow}{tf\+::cuda\+Flow} provides template methods for transforming ranges of items to different outputs.\hypertarget{_parallel_transforms_c_u_d_a_CUDAParallelTransformsIncludeTheHeader}{}\doxysubsection{\texorpdfstring{Include the Header}{Include the Header}}\label{_parallel_transforms_c_u_d_a_CUDAParallelTransformsIncludeTheHeader}
You need to include the header file, {\ttfamily taskflow/cuda/algorithm/transform.hpp}, for creating a parallel-\/transform task.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <\mbox{\hyperlink{cuda_2algorithm_2transform_8hpp}{taskflow/cuda/algorithm/transform.hpp}}>}}

\end{DoxyCode}
\hypertarget{_parallel_transforms_c_u_d_a_cudaFlowTransformARangeOfItems}{}\doxysubsection{\texorpdfstring{Transform a Range of Items}{Transform a Range of Items}}\label{_parallel_transforms_c_u_d_a_cudaFlowTransformARangeOfItems}
Iterator-\/based parallel-\/transform applies the given transform function to a range of items and store the result in another range specified by two iterators, {\ttfamily first} and {\ttfamily last}. The task created by \doxylink{classtf_1_1cuda_flow_af89a9bda182272462a0eda2581536cd8}{tf\+::cuda\+Flow\+::transform(\+I first, I last, O output, C op)} represents a parallel execution for the following loop\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{while}\ (first\ !=\ last)\ \{}
\DoxyCodeLine{\ \ *\mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_a8390452002ecc7a0dadc5ae0dccc9b6c}{output}}++\ =\ op(*first++);}
\DoxyCodeLine{\}}

\end{DoxyCode}


The following example creates a transform kernel that transforms an input range of {\ttfamily N} items to an output range by multiplying each item by 10.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ output[i]\ =\ input[i]\ *\ 10}}
\DoxyCodeLine{cudaflow.transform(}
\DoxyCodeLine{\ \ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}},\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}\ +\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_a8390452002ecc7a0dadc5ae0dccc9b6c}{output}},\ []\ \_\_device\_\_\ (\textcolor{keywordtype}{int}\ \mbox{\hyperlink{offscreen_8c_a5fd331c99e778f04762be6d8173eb4d2}{x}})\ \{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{offscreen_8c_a5fd331c99e778f04762be6d8173eb4d2}{x}}\ *\ 10;\ \}}
\DoxyCodeLine{);\ }

\end{DoxyCode}


Each iteration is independent of each other and is assigned one kernel thread to run the callable. Since the callable runs on GPU, it must be declared with a {\ttfamily \+\_\+\+\_\+device\+\_\+\+\_\+} specifier.\hypertarget{_parallel_transforms_c_u_d_a_cudaFlowTransformTwoRangesOfItems}{}\doxysubsection{\texorpdfstring{Transform Two Ranges of Items}{Transform Two Ranges of Items}}\label{_parallel_transforms_c_u_d_a_cudaFlowTransformTwoRangesOfItems}
You can transform two ranges of items to an output range through a binary operator. The task created by \doxylink{classtf_1_1cuda_flow_abab2bfdfc86ef3a764ece4743fdede76}{tf\+::cuda\+Flow\+::transform(\+I1 first1, I1 last1, I2 first2, O output, C op)} represents a parallel execution for the following loop\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{while}\ (first1\ !=\ last1)\ \{}
\DoxyCodeLine{\ \ *\mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_a8390452002ecc7a0dadc5ae0dccc9b6c}{output}}++\ =\ op(*first1++,\ *first2++);}
\DoxyCodeLine{\}}

\end{DoxyCode}


The following example creates a transform kernel that transforms two input ranges of {\ttfamily N} items to an output range by summing each pair of items in the input ranges.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ output[i]\ =\ input1[i]\ +\ inpu2[i]}}
\DoxyCodeLine{cudaflow.transform(}
\DoxyCodeLine{\ \ input1,\ input1+\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ input2,\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_a8390452002ecc7a0dadc5ae0dccc9b6c}{output}},\ []\_\_device\_\_(\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_cwise__product_8cpp_ad2cbe4616e813eb9af81732dca777b24}{a}},\ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{offscreen_8c_a846c9667e34d56c560bb7f0ac6e173f6}{b}})\ \{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{_cwise__product_8cpp_ad2cbe4616e813eb9af81732dca777b24}{a}}+\mbox{\hyperlink{offscreen_8c_a846c9667e34d56c560bb7f0ac6e173f6}{b}};\ \}}
\DoxyCodeLine{);\ }

\end{DoxyCode}
\hypertarget{_parallel_transforms_c_u_d_a_ParallelTransformCUDAMiscellaneousItems}{}\doxysubsection{\texorpdfstring{Miscellaneous Items}{Miscellaneous Items}}\label{_parallel_transforms_c_u_d_a_ParallelTransformCUDAMiscellaneousItems}
The parallel-\/transform algorithms are also available in \doxylink{classtf_1_1cuda_flow_capturer}{tf\+::cuda\+Flow\+Capturer}. 