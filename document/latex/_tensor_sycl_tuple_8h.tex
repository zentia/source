\doxysection{external/taskflow/3rd-\/party/eigen-\/3.3.7/unsupported/\+Eigen/\+CXX11/src/\+Tensor/\+Tensor\+Sycl\+Tuple.h 文件参考}
\hypertarget{_tensor_sycl_tuple_8h}{}\label{_tensor_sycl_tuple_8h}\index{external/taskflow/3rd-\/party/eigen-\/3.3.7/unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h@{external/taskflow/3rd-\/party/eigen-\/3.3.7/unsupported/Eigen/CXX11/src/Tensor/TensorSyclTuple.h}}
\doxysubsubsection*{类}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_static_if_3_01true_00_01_t_01_4}{utility\+::tuple\+::\+Static\+If$<$ true, T $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \doxylink{structutility_1_1tuple_1_1_static_if}{Static\+If} when the condition is true \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{utility\+::tuple\+::\+Tuple$<$ Ts $>$}}
\begin{DoxyCompactList}\small\item\em is a fixed-\/size collection of heterogeneous values \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple_3_01_t_00_01_ts_8_8_8_01_4}{utility\+::tuple\+::\+Tuple$<$ T, Ts... $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \doxylink{struct_tuple}{Tuple} class when the tuple has at least one element. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder_3_010_00_01_tuple_3_01_t_00_01_ts_8_8_8_01_4_01_4}{utility\+::tuple\+::\+Elem\+Type\+Holder$<$ 0, Tuple$<$ T, Ts... $>$ $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \doxylink{structutility_1_1tuple_1_1_elem_type_holder}{Elem\+Type\+Holder} class when the number of elements inside the tuple is 1 \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_elem_type_holder_3_01k_00_01_tuple_3_01_t_00_01_ts_8_8_8_01_4_01_4}{utility\+::tuple\+::\+Elem\+Type\+Holder$<$ k, Tuple$<$ T, Ts... $>$ $>$}}
\begin{DoxyCompactList}\small\item\em specialisation of the \doxylink{structutility_1_1tuple_1_1_elem_type_holder}{Elem\+Type\+Holder} class when the number of elements inside the tuple is bigger than 1. It recursively calls itself to detect the type of each element in the tuple \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{utility\+::tuple\+::\+Index\+List$<$ Is $>$}}
\begin{DoxyCompactList}\small\item\em Creates a list of index from the elements in the tuple \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_range_builder_3_01_m_i_n_00_01_m_i_n_00_01_is_8_8_8_01_4}{utility\+::tuple\+::\+Range\+Builder$<$ MIN, MIN, Is... $>$}}
\begin{DoxyCompactList}\small\item\em base Step\+: Specialisation of the Range\+Builder when the MIN==MAX. In this case the Is... is \mbox{[}0 to sizeof...(tuple elements)) \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_range_builder}{utility\+::tuple\+::\+Range\+Builder$<$ MIN, N, Is $>$}}
\begin{DoxyCompactList}\small\item\em Collects internal details for generating index ranges \mbox{[}MIN, MAX) Declare primary template for index range builder \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structutility_1_1tuple_1_1_index_range}{utility\+::tuple\+::\+Index\+Range$<$ MIN, MAX $>$}}
\begin{DoxyCompactList}\small\item\em \doxylink{structutility_1_1tuple_1_1_index_range}{Index\+Range} that returns a \mbox{[}MIN, MAX) index range \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{命名空间}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespaceutility}{utility}}
\item 
namespace \mbox{\hyperlink{namespaceutility_1_1tuple}{utility\+::tuple}}
\end{DoxyCompactItemize}
\doxysubsubsection*{宏定义}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{_tensor_sycl_tuple_8h_a34c240717e47583447c4c179db047c69}{TERMINATE\+\_\+\+CONDS\+\_\+\+TUPLE\+\_\+\+GET}}(CVQual)
\begin{DoxyCompactList}\small\item\em Extracts the first element from the tuple. K=0 represents the first element of the tuple. The tuple cannot be empty. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{_tensor_sycl_tuple_8h_ad6b3b93b7bdda101df81e837a7e0aa8e}{RECURSIVE\+\_\+\+TUPLE\+\_\+\+GET}}(CVQual)
\begin{DoxyCompactList}\small\item\em Extracts the Kth element from the tuple. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{函数}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename... Args$>$ }\\\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args... $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_a88ee8d0837a69d3d7ad44546aa2949cb}{utility\+::tuple\+::make\+\_\+tuple}} (Args... \mbox{\hyperlink{tbbproxy_8cpp_acd08a6295eccfeb30c79985f047e4be5}{args}})
\begin{DoxyCompactList}\small\item\em Creates a tuple object, deducing the target type from the types of arguments. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ }\\static constexpr size\+\_\+t \mbox{\hyperlink{namespaceutility_1_1tuple_a3ee33aa9c095eefbb760200218a320fc}{utility\+::tuple\+::size}} (\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args... $>$ \&)
\begin{DoxyCompactList}\small\item\em Provides access to the number of elements in a tuple as a compile-\/time constant expression. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args, typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, size\+\_\+t... I$>$ }\\\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args..., \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_a3ea3f51ccd84a9e293b32d2662605569}{utility\+::tuple\+::append\+\_\+base}} (\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args... $>$ \mbox{\hyperlink{boing_8c_a87accd1af8e0aff4b818d891374f7cec}{t}}, \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \mbox{\hyperlink{_cwise__product_8cpp_ad2cbe4616e813eb9af81732dca777b24}{a}}, \mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{Index\+List}}$<$ I... $>$)
\begin{DoxyCompactList}\small\item\em unpacking the elements of the input tuple t and creating a new tuple by adding element a at the end of it. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args, typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}$>$ }\\\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args..., \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_a3d9d0e2cdff4564e5c2e37368259ccd6}{utility\+::tuple\+::append}} (\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args... $>$ \mbox{\hyperlink{boing_8c_a87accd1af8e0aff4b818d891374f7cec}{t}}, \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \mbox{\hyperlink{_cwise__product_8cpp_ad2cbe4616e813eb9af81732dca777b24}{a}})
\begin{DoxyCompactList}\small\item\em the deduction function for \doxylink{namespaceutility_1_1tuple_a3ea3f51ccd84a9e293b32d2662605569}{append\+\_\+base} that automatically generate the \doxylink{structutility_1_1tuple_1_1_index_range}{Index\+Range} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args1, typename... Args2, size\+\_\+t... I1, size\+\_\+t... I2$>$ }\\\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args1..., Args2... $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_a95967856cb33ae1ab1875861e4f3c052}{utility\+::tuple\+::append\+\_\+base}} (\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args1... $>$ t1, \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args2... $>$ t2, \mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{Index\+List}}$<$ I1... $>$, \mbox{\hyperlink{structutility_1_1tuple_1_1_index_list}{Index\+List}}$<$ I2... $>$)
\begin{DoxyCompactList}\small\item\em This is a specialisation of \doxylink{namespaceutility_1_1tuple_a3ea3f51ccd84a9e293b32d2662605569}{append\+\_\+base} when we want to concatenate tuple t2 at the end of the tuple t1. Here we unpack both tuples, generate the \doxylink{structutility_1_1tuple_1_1_index_range}{Index\+Range} for each of them and create an output tuple T that contains both elements of t1 and t2. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args1, typename... Args2$>$ }\\\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args1..., Args2... $>$ \mbox{\hyperlink{namespaceutility_1_1tuple_ab7958a5d7dca1b4cb24e16d26ade606c}{utility\+::tuple\+::append}} (\mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args1... $>$ t1, \mbox{\hyperlink{structutility_1_1tuple_1_1_tuple}{Tuple}}$<$ Args2... $>$ t2)
\begin{DoxyCompactList}\small\item\em deduction function for \doxylink{namespaceutility_1_1tuple_a3ea3f51ccd84a9e293b32d2662605569}{append\+\_\+base} when we are appending tuple t1 by tuple t2. In this case the \doxylink{structutility_1_1tuple_1_1_index_range}{Index\+Range} for both tuple are automatically generated. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{宏定义说明}
\Hypertarget{_tensor_sycl_tuple_8h_ad6b3b93b7bdda101df81e837a7e0aa8e}\index{TensorSyclTuple.h@{TensorSyclTuple.h}!RECURSIVE\_TUPLE\_GET@{RECURSIVE\_TUPLE\_GET}}
\index{RECURSIVE\_TUPLE\_GET@{RECURSIVE\_TUPLE\_GET}!TensorSyclTuple.h@{TensorSyclTuple.h}}
\doxysubsubsection{\texorpdfstring{RECURSIVE\_TUPLE\_GET}{RECURSIVE\_TUPLE\_GET}}
{\footnotesize\ttfamily \label{_tensor_sycl_tuple_8h_ad6b3b93b7bdda101df81e837a7e0aa8e} 
\#define RECURSIVE\+\_\+\+TUPLE\+\_\+\+GET(\begin{DoxyParamCaption}\item[{}]{CVQual}{}\end{DoxyParamCaption})}

{\bfseries 值\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keywordtype}{size\_t}\ k,\ \textcolor{keyword}{class\ }\mbox{\hyperlink{test__overwrite__node_8cpp_a0acb682b8260ab1c60b918599864e2e5}{T}},\ \textcolor{keyword}{class}...\ Ts>\ \(\backslash\)}
\DoxyCodeLine{\textcolor{keyword}{typename}\ StaticIf<k\ !=\ 0,\ CVQual\ \textcolor{keyword}{typename}\ ElemTypeHolder<k,\ \mbox{\hyperlink{struct_tuple}{Tuple}}<\mbox{\hyperlink{test__overwrite__node_8cpp_a0acb682b8260ab1c60b918599864e2e5}{T}},\ Ts...>\ >\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_ae8396ff85d63082521e3324820df1009}{::type}}\ \&>::type\ \(\backslash\)}
\DoxyCodeLine{get(CVQual\ \mbox{\hyperlink{struct_tuple}{Tuple<T,\ Ts...>}}\ \&\mbox{\hyperlink{boing_8c_a87accd1af8e0aff4b818d891374f7cec}{t}})\ \{\ \(\backslash\)}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ utility::tuple::get<k\ -\/\ 1>(\mbox{\hyperlink{boing_8c_a87accd1af8e0aff4b818d891374f7cec}{t}}.tail);\ \(\backslash\)}
\DoxyCodeLine{\}}

\end{DoxyCode}


Extracts the Kth element from the tuple. 

get 
\begin{DoxyTemplParams}{模板参数}
{\em K} & is an integer value in \mbox{[}0,sizeof...(Types)). \\
\hline
{\em T} & is the (sizeof...(Types) -\/(K+1)) element in the tuple \\
\hline
{\em Ts...} & are the type of the elements in the tuple. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em t} & is the tuple whose contents to extract \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
typename Elem\+Type\+Holder\texorpdfstring{$<$}{<}K, \doxylink{struct_tuple}{Tuple$<$\+Ts...$>$} \texorpdfstring{$>$}{>}\doxylink{imgui__impl__opengl3__loader_8h_ae8396ff85d63082521e3324820df1009}{type} \&\texorpdfstring{$>$}{>}\doxylink{imgui__impl__opengl3__loader_8h_ae8396ff85d63082521e3324820df1009}{type} 
\end{DoxyReturn}
\Hypertarget{_tensor_sycl_tuple_8h_a34c240717e47583447c4c179db047c69}\index{TensorSyclTuple.h@{TensorSyclTuple.h}!TERMINATE\_CONDS\_TUPLE\_GET@{TERMINATE\_CONDS\_TUPLE\_GET}}
\index{TERMINATE\_CONDS\_TUPLE\_GET@{TERMINATE\_CONDS\_TUPLE\_GET}!TensorSyclTuple.h@{TensorSyclTuple.h}}
\doxysubsubsection{\texorpdfstring{TERMINATE\_CONDS\_TUPLE\_GET}{TERMINATE\_CONDS\_TUPLE\_GET}}
{\footnotesize\ttfamily \label{_tensor_sycl_tuple_8h_a34c240717e47583447c4c179db047c69} 
\#define TERMINATE\+\_\+\+CONDS\+\_\+\+TUPLE\+\_\+\+GET(\begin{DoxyParamCaption}\item[{}]{CVQual}{}\end{DoxyParamCaption})}

{\bfseries 值\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keywordtype}{size\_t}\ k,\ \textcolor{keyword}{class}...\ Ts>\ \(\backslash\)}
\DoxyCodeLine{\textcolor{keyword}{typename}\ StaticIf<k\ ==\ 0,\ CVQual\ \textcolor{keyword}{typename}\ ElemTypeHolder<0,\ \mbox{\hyperlink{struct_tuple}{Tuple}}<Ts...>\ >\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_ae8396ff85d63082521e3324820df1009}{::type}}\ \&>::type\ \(\backslash\)}
\DoxyCodeLine{get(CVQual\ \mbox{\hyperlink{struct_tuple}{Tuple<Ts...>}}\ \&\mbox{\hyperlink{boing_8c_a87accd1af8e0aff4b818d891374f7cec}{t}})\ \{\ \(\backslash\)}
\DoxyCodeLine{\ \ static\_assert(\textcolor{keyword}{sizeof}...(Ts)!=0,\ \textcolor{stringliteral}{"{}The\ requseted\ value\ is\ bigger\ than\ the\ size\ of\ the\ tuple"{}});\ \(\backslash\)}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{boing_8c_a87accd1af8e0aff4b818d891374f7cec}{t}}.head;\ \(\backslash\)}
\DoxyCodeLine{\}}

\end{DoxyCode}


Extracts the first element from the tuple. K=0 represents the first element of the tuple. The tuple cannot be empty. 

get 
\begin{DoxyTemplParams}{模板参数}
{\em Ts...} & are the type of the elements in the tuple. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em t} & is the tuple whose contents to extract \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
typename Elem\+Type\+Holder\texorpdfstring{$<$}{<}0, \doxylink{struct_tuple}{Tuple$<$\+Ts...$>$} \texorpdfstring{$>$}{>}\doxylink{imgui__impl__opengl3__loader_8h_ae8396ff85d63082521e3324820df1009}{type} \&\texorpdfstring{$>$}{>}\doxylink{imgui__impl__opengl3__loader_8h_ae8396ff85d63082521e3324820df1009}{type} 
\end{DoxyReturn}
