\chapter{source}
\hypertarget{index}{}\label{index}\index{source@{source}}
This is the API documentation of the \href{https://github.com/microsoft/mimalloc}{\texttt{ mimalloc}} allocator (pronounced "{}me-\/malloc"{}) -- a general purpose allocator with excellent \href{bench.html}{\texttt{ performance}} characteristics. Initially developed by Daan Leijen for the run-\/time systems of the \href{https://github.com/koka-lang/koka}{\texttt{ Koka}} and \href{https://github.com/leanprover/lean}{\texttt{ Lean}} languages.

It is a drop-\/in replacement for {\ttfamily malloc} and can be used in other programs without code changes, for example, on Unix you can use it as\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{>\ LD\_PRELOAD=/usr/\mbox{\hyperlink{base_8h_adfa139c9a1902753b3696794759b2c48ac1111bd512b29e821b120b86446026b8}{bin}}/libmimalloc.so\ \ myprogram}

\end{DoxyCode}


Notable aspects of the design include\+:
\begin{DoxyItemize}
\item {\bfseries{small and consistent}}\+: the library is about 8k LOC using simple and consistent data structures. This makes it very suitable to integrate and adapt in other projects. For runtime systems it provides hooks for a monotonic {\itshape heartbeat} and deferred freeing (for bounded worst-\/case times with reference counting). Partly due to its simplicity, mimalloc has been ported to many systems (Windows, mac\+OS, Linux, WASM, various BSD\textquotesingle{}s, Haiku, MUSL, etc) and has excellent support for dynamic overriding. At the same time, it is an industrial strength allocator that runs (very) large scale distributed services on thousands of machines with excellent worst case latencies.
\item {\bfseries{free list sharding}}\+: instead of one big free list (per size class) we have many smaller lists per "{}mimalloc page"{} which reduces fragmentation and increases locality -- things that are allocated close in time get allocated close in memory. (A mimalloc page contains blocks of one size class and is usually 64KiB on a 64-\/bit system).
\item {\bfseries{free list multi-\/sharding}}\+: the big idea! Not only do we shard the free list per mimalloc page, but for each page we have multiple free lists. In particular, there is one list for thread-\/local {\ttfamily free} operations, and another one for concurrent {\ttfamily free} operations. Free-\/ing from another thread can now be a single CAS without needing sophisticated coordination between threads. Since there will be thousands of separate free lists, contention is naturally distributed over the heap, and the chance of contending on a single location will be low -- this is quite similar to randomized algorithms like skip lists where adding a random oracle removes the need for a more complex algorithm.
\item {\bfseries{eager page purging}}\+: when a "{}page"{} becomes empty (with increased chance due to free list sharding) the memory is marked to the OS as unused (reset or decommitted) reducing (real) memory pressure and fragmentation, especially in long running programs.
\item {\bfseries{secure}}\+: {\itshape mimalloc} can be built in secure mode, adding guard pages, randomized allocation, encrypted free lists, etc. to protect against various heap vulnerabilities. The performance penalty is usually around 10\% on average over our benchmarks.
\item {\bfseries{first-\/class heaps}}\+: efficiently create and use multiple heaps to allocate across different regions. A heap can be destroyed at once instead of deallocating each object separately.
\item {\bfseries{bounded}}\+: it does not suffer from {\itshape blowup} \mbox{[}1\mbox{]}, has bounded worst-\/case allocation times ({\itshape wcat}) (upto OS primitives), bounded space overhead (\texorpdfstring{$\sim$}{\string~}0.2\% meta-\/data, with low internal fragmentation), and has no internal points of contention using only atomic operations.
\item {\bfseries{fast}}\+: In our benchmarks (see \doxysectlink{bench}{below}{0}), {\itshape mimalloc} outperforms other leading allocators ({\itshape jemalloc}, {\itshape tcmalloc}, {\itshape Hoard}, etc), and often uses less memory. A nice property is that it does consistently well over a wide range of benchmarks. There is also good huge OS page support for larger server programs.
\end{DoxyItemize}

You can read more on the design of {\itshape mimalloc} in the \href{https://www.microsoft.com/en-us/research/publication/mimalloc-free-list-sharding-in-action}{\texttt{ technical report}} which also has detailed benchmark results.

Further information\+:


\begin{DoxyItemize}
\item \doxysectlink{build}{Building}{0}
\item \doxysectlink{using}{Using the library}{0}
\item \doxysectlink{environment}{Environment Options}{0}
\item \doxysectlink{overrides}{Overriding Malloc}{0}
\item \doxysectlink{bench}{Performance}{0}
\item \doxylink{group__malloc}{Basic Allocation}
\item \doxylink{group__extended}{Extended Functions}
\item \doxylink{group__aligned}{Aligned Allocation}
\item \doxylink{group__heap}{Heap Allocation}
\item \doxylink{group__typed}{Typed Macros}
\item \doxylink{group__analysis}{Heap Introspection}
\item \doxylink{group__options}{Runtime Options}
\item \doxylink{group__posix}{Posix}
\item \doxylink{group__cpp}{C++ wrappers} 
\end{DoxyItemize}