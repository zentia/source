\doxysection{Parallel Find}
\hypertarget{_parallel_find}{}\label{_parallel_find}\index{Parallel Find@{Parallel Find}}
Taskflow provides template functions for constructing tasks to perform parallel iterations over ranges of items.\hypertarget{_parallel_find_ParallelFindIncludeTheHeader}{}\doxysubsection{\texorpdfstring{Include the Header}{Include the Header}}\label{_parallel_find_ParallelFindIncludeTheHeader}
You need to include the header file, {\ttfamily taskflow/algorithm/find.hpp}, for using parallel-\/find algorithms.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <\mbox{\hyperlink{algorithm_2find_8hpp}{taskflow/algorithm/find.hpp}}>}}

\end{DoxyCode}
\hypertarget{_parallel_find_WhatIsAFindAlgorithm}{}\doxysubsection{\texorpdfstring{What is a Find Algorithm?}{What is a Find Algorithm?}}\label{_parallel_find_WhatIsAFindAlgorithm}
\doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} find algorithm allows you to find an element in a range {\ttfamily \mbox{[}first, last)} that satisfies a specific criteria. The algorithm returns an iterator to the first found element in the range or returns {\ttfamily last} if there is no such iterator. Taskflow provides the following parallel-\/find algorithms\+:


\begin{DoxyItemize}
\item \doxylink{classtf_1_1_flow_builder_a46a96f5889e6ac87b1ff8d6313b5f471}{tf\+::\+Taskflow\+::find\+\_\+if(\+B first, E last, T\& result, UOP predicate, P part)}
\item \doxylink{classtf_1_1_flow_builder_a95fa2719fa7bbe7d171cf474ddb06726}{tf\+::\+Taskflow\+::find\+\_\+if\+\_\+not(\+B first, E last, T\& result, UOP predicate, P part)}
\item \doxylink{classtf_1_1_flow_builder_a6bf43eeaa81900084a472be1d36d46a6}{tf\+::\+Taskflow\+::min\+\_\+element(\+B first, E last, T\& result, C comp, P part)}
\item \doxylink{classtf_1_1_flow_builder_a6be5d7f053a868647c3b9e0d9cdf6b68}{tf\+::\+Taskflow\+::max\+\_\+element(\+B first, E last, T\& result, C comp, P part)}
\end{DoxyItemize}\hypertarget{_parallel_find_CreateAParallelFindIfTask}{}\doxysubsection{\texorpdfstring{Create a Parallel Find-\/\+If Task}{Create a Parallel Find-\/\+If Task}}\label{_parallel_find_CreateAParallelFindIfTask}
\doxylink{classtf_1_1_flow_builder_a46a96f5889e6ac87b1ff8d6313b5f471}{tf\+::\+Taskflow\+::find\+\_\+if} performs parallel iterations to find the first element in the range {\ttfamily \mbox{[}first, last)} that makes the given predicate return {\ttfamily true}. It resembles a parallel implementation of the following loop\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ InputIt,\ \textcolor{keyword}{typename}\ UnaryPredicate>}
\DoxyCodeLine{InputIt\ find\_if(InputIt\ first,\ InputIt\ last,\ UnaryPredicate\ predicate)\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}(;\ first\ !=\ last;\ ++first)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}(predicate(*first))\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordflow}{return}\ first;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespacetbb_1_1internal_a18405c9631e7064d3af5662f30a84dd2}{last}};}
\DoxyCodeLine{\}}

\end{DoxyCode}


The example below creates a task to find the element that is equal to 22 from an input range of 10 elements. The result will be stored in the forth argument passed by reference\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<int>\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}\ =\ \{1,\ 9,\ 22,\ 3,\ -\/6,\ 13,\ 12,\ 0,\ 9,\ 11\};}
\DoxyCodeLine{std::vector<int>::iterator\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}};}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.find\_if(}
\DoxyCodeLine{\ \ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}.begin(),\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}.end(),\ [](\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}})\{\ return\ i\ ==\ 22;\ \},\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}}
\DoxyCodeLine{);}
\DoxyCodeLine{\mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.run(\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}});}
\DoxyCodeLine{assert(*\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}\ ==\ 22);}

\end{DoxyCode}
\hypertarget{_parallel_find_ParallelFindCaptureIteratorsByReference}{}\doxysubsection{\texorpdfstring{Capture Iterators by Reference}{Capture Iterators by Reference}}\label{_parallel_find_ParallelFindCaptureIteratorsByReference}
You can pass iterators by reference using @std\+\_\+ref to marshal parameters update between dependent tasks. This is especially useful when the range iterators are not known at the time of creating a find-\/if task, but need initialization from another task.


\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<int>\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}};}
\DoxyCodeLine{std::vector<int>::iterator\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}},\ first,\ last;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ task\ to\ set\ up\ the\ range\ iterators}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ \mbox{\hyperlink{structinit}{init}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([\&]()\{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}\ =\ \{1,\ 9,\ 22,\ 3,\ -\/6,\ 13,\ 12,\ 0,\ 9,\ 11\};}
\DoxyCodeLine{\ \ first\ =\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}.begin(),}
\DoxyCodeLine{\ \ last\ \ =\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}.end();}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ task\ to\ perform\ parallel\ find}}
\DoxyCodeLine{tf::Task\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.find\_if(}
\DoxyCodeLine{\ \ std::ref(first),\ std::ref(last),\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}},\ [](\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}})\{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}\ ==\ 22;\ \}}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{boing_8c_a2858154e2009b0e6e616f313177762bc}{init}}.precede(\mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}});}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.\mbox{\hyperlink{classtf_1_1_executor_a519777f5783981d534e9e53b99712069}{run}}(\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}});}
\DoxyCodeLine{assert(*\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}\ ==\ 22);}

\end{DoxyCode}


In the above example, when {\ttfamily init} finishes, {\ttfamily input} has been initialized to 10 elements with {\ttfamily first} and {\ttfamily last} pointing to the data range of {\ttfamily input}. The find-\/if task will then work on this initialized range as a result of passing iterators by reference.\hypertarget{_parallel_find_CreateAParallelFindIfNotTask}{}\doxysubsection{\texorpdfstring{Create a Parallel Find-\/\+If-\/\+Not Task}{Create a Parallel Find-\/\+If-\/\+Not Task}}\label{_parallel_find_CreateAParallelFindIfNotTask}
\doxylink{classtf_1_1_flow_builder_a95fa2719fa7bbe7d171cf474ddb06726}{tf\+::\+Taskflow\+::find\+\_\+if\+\_\+not} performs parallel iterations to find the first element in the range {\ttfamily \mbox{[}first, last)} that makes the given predicate return {\ttfamily false}. It resembles a parallel implementation of the following loop\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ InputIt,\ \textcolor{keyword}{typename}\ UnaryPredicate>}
\DoxyCodeLine{InputIt\ find\_if(InputIt\ first,\ InputIt\ last,\ UnaryPredicate\ predicate)\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}(;\ first\ !=\ last;\ ++first)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}(!predicate(*first))\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordflow}{return}\ first;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespacetbb_1_1internal_a18405c9631e7064d3af5662f30a84dd2}{last}};}
\DoxyCodeLine{\}}

\end{DoxyCode}


The example below creates a task to find the element that is {\itshape NOT} equal to 22 from an input range of 10 elements. The result will be stored in the forth argument passed by reference\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<int>\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}\ =\ \{1,\ 1,\ 22,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1,\ 1\};}
\DoxyCodeLine{std::vector<int>::iterator\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}};}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.find\_if\_not(}
\DoxyCodeLine{\ \ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}.begin(),\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}.end(),\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}},\ [](\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}})\{\ return\ i\ ==\ 1;\ \}}
\DoxyCodeLine{);}
\DoxyCodeLine{\mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.run(\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}});}
\DoxyCodeLine{assert(*\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}\ ==\ 22);}

\end{DoxyCode}


Similar to \doxysectlink{_parallel_find_ParallelFindCaptureIteratorsByReference}{Capture Iterators by Reference}{1}, iterators of \doxylink{classtf_1_1_flow_builder_a95fa2719fa7bbe7d171cf474ddb06726}{tf\+::\+Taskflow\+::find\+\_\+if\+\_\+not} are templated to allow passing iterators by reference using @std\+\_\+ref. This is especially useful when the range iterators are not known at the time of creating a find-\/if-\/not task, but need initialization from another task.\hypertarget{_parallel_find_ParallelFindMinMaxElement}{}\doxysubsection{\texorpdfstring{Find the Smallest and the Largest Elements}{Find the Smallest and the Largest Elements}}\label{_parallel_find_ParallelFindMinMaxElement}
\doxylink{classtf_1_1_flow_builder_a6bf43eeaa81900084a472be1d36d46a6}{tf\+::\+Taskflow\+::min\+\_\+element} finds the smallest element in a range {\ttfamily \mbox{[}first, last)} using the given comparison function object. The example below finds the smallest element, i.\+e., -\/1, from an input range of 10 elements and stores the iterator to that smallest element in {\ttfamily result\+:} 


\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<int>\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}\ =\ \{1,\ 1,\ 1,\ 1,\ 1,\ -\/1,\ 1,\ 1,\ 1,\ 1\};}
\DoxyCodeLine{std::vector<int>::iterator\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}};}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.min\_element(}
\DoxyCodeLine{\ \ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}.begin(),\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}.end(),\ std::less<int>(),\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}}
\DoxyCodeLine{);}
\DoxyCodeLine{\mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.run(\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}).wait();}
\DoxyCodeLine{assert(*\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}\ ==\ -\/1);}

\end{DoxyCode}


Similarly, \doxylink{classtf_1_1_flow_builder_a6be5d7f053a868647c3b9e0d9cdf6b68}{tf\+::\+Taskflow\+::max\+\_\+element} finds the largest element in a range {\ttfamily \mbox{[}first, last)} using the given comparison function object. The example below finds the largest element, i.\+e., 2, from an input range of 10 elements and stores the iterator to that largest element in {\ttfamily result\+:} 


\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<int>\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}\ =\ \{1,\ 1,\ 1,\ 1,\ 1,\ 2,\ 1,\ 1,\ 1,\ 1\};}
\DoxyCodeLine{std::vector<int>::iterator\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}};}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.max\_element(}
\DoxyCodeLine{\ \ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}.begin(),\ \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_ab7e6955a695fad0be513586926040b1a}{input}}.end(),\ std::less<int>(),\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}}
\DoxyCodeLine{);}
\DoxyCodeLine{\mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.run(\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}).wait();}
\DoxyCodeLine{assert(*\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}}\ ==\ 2);}

\end{DoxyCode}


\begin{DoxyAttention}{注意}
When using \doxylink{classtf_1_1_flow_builder_a6be5d7f053a868647c3b9e0d9cdf6b68}{tf\+::\+Taskflow\+::max\+\_\+element} to find the large element, we will still need to use std\+::less as our comparison function. Details can be referred to \href{https://en.cppreference.com/w/cpp/algorithm/max_element}{\texttt{ std\+::max\+\_\+element}}.
\end{DoxyAttention}
\hypertarget{_parallel_find_ParallelFindConfigureAPartitioner}{}\doxysubsection{\texorpdfstring{Configure a Partitioner}{Configure a Partitioner}}\label{_parallel_find_ParallelFindConfigureAPartitioner}
You can configure a partitioner for parallel-\/find tasks (\doxylink{classtf_1_1_flow_builder_a46a96f5889e6ac87b1ff8d6313b5f471}{tf\+::\+Taskflow\+::find\+\_\+if}, \doxylink{classtf_1_1_flow_builder_a95fa2719fa7bbe7d171cf474ddb06726}{tf\+::\+Taskflow\+::find\+\_\+if\+\_\+not}, \doxylink{classtf_1_1_flow_builder_a6bf43eeaa81900084a472be1d36d46a6}{tf\+::\+Taskflow\+::min\+\_\+element}, \doxylink{classtf_1_1_flow_builder_a6be5d7f053a868647c3b9e0d9cdf6b68}{tf\+::\+Taskflow\+::max\+\_\+element}) to run with different scheduling methods, such as guided partitioning, dynamic partitioning, and static partitioning. The following example creates two parallel-\/find tasks using two different partitioners, one with the static partitioning algorithm and another one with the guided partitioning algorithm\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<int>\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}(1024,\ -\/1);}
\DoxyCodeLine{std::vector<int>::iterator\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ create\ two\ partitioners\ with\ a\ chunk\ size\ of\ 10}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_static_partitioner}{tf::StaticPartitioner}}\ static\_partitioner(10);}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_guided_partitioner}{tf::GuidedPartitioner}}\ guided\_partitioner(10);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ create\ a\ parallel-\/find\ task\ with\ a\ static\ partitioner}}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.find\_if(}
\DoxyCodeLine{\ \ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}.begin(),\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}.end(),\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}},\ [\&](\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}})\ \{\ return\ i\ ==\ -\/1;\ \},\ static\_partitioner}
\DoxyCodeLine{);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ create\ a\ parallel-\/find\ task\ with\ a\ guided\ partitioner}}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.find\_if(}
\DoxyCodeLine{\ \ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}.begin(),\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}.end(),\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aa7f56a70231ed8bc64f97aa7c37fcb19}{result}},\ [\&](\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}})\ \{\ return\ i\ ==\ -\/1;\ \},\ guided\_partitioner}
\DoxyCodeLine{);}

\end{DoxyCode}


\begin{DoxyAttention}{注意}
By default, parallel-\/find tasks use \doxylink{namespacetf_ace2c5adcd5039483eebb6dbdbb6f33e3}{tf\+::\+Default\+Partitioner} if no partitioner is specified. 
\end{DoxyAttention}
