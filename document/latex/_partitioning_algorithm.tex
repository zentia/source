\doxysection{Partitioning Algorithm}
\hypertarget{_partitioning_algorithm}{}\label{_partitioning_algorithm}\index{Partitioning Algorithm@{Partitioning Algorithm}}
\doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} partitioning algorithm allows applications to optimize parallel algorithms using different scheduling methods, such as static partitioning, dynamic partitioning, and guided partitioning.\hypertarget{_partitioning_algorithm_DefineAPartitionerForParallelAlgorithms}{}\doxysubsection{\texorpdfstring{Define a Partitioner for Parallel Algorithms}{Define a Partitioner for Parallel Algorithms}}\label{_partitioning_algorithm_DefineAPartitionerForParallelAlgorithms}
\doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} partitioner defines how to partition and distribute iterations to different workers when running parallel algorithms in Taskflow, such as \doxylink{classtf_1_1_flow_builder_aae3edfa278baa75b08414e083c14c836}{tf\+::\+Taskflow\+::for\+\_\+each} and \doxylink{classtf_1_1_flow_builder_a97be7ceef6fa4276e3b074c10c13b826}{tf\+::\+Taskflow\+::transform}. The following example shows how to create parallel-\/iteration tasks with different execution policies\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<int>\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}\ =\ \{1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8,\ 9,\ 10\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ create\ different\ partitioners}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_guided_partitioner}{tf::GuidedPartitioner}}\ guided\_partitioner;}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_static_partitioner}{tf::StaticPartitioner}}\ static\_partitioner;}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_random_partitioner}{tf::RandomPartitioner}}\ random\_partitioner;}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_dynamic_partitioner}{tf::DynamicPartitioner}}\ dynamic\_partitioner;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ create\ four\ parallel-\/iteration\ tasks\ from\ the\ four\ execution\ policies}}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.for\_each(\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}.begin(),\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}.end(),\ [](\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}})\{\},\ guided\_partitioner);}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.for\_each(\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}.begin(),\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}.end(),\ [](\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}})\{\},\ static\_partitioner);}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.for\_each(\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}.begin(),\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}.end(),\ [](\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}})\{\},\ random\_partitioner);}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.for\_each(\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}.begin(),\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a02796e583e939f923a255e43d2c3b177}{data}}.end(),\ [](\textcolor{keywordtype}{int}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}})\{\},\ dynamic\_partitioner);}

\end{DoxyCode}


Each partitioner has a specific algorithm to partition iterations into a set of {\itshape chunks} and distribute chunks to workers. \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} chunk is the basic unit of work that will be run by a worker during the execution of parallel iterations. The following figure illustrates the scheduling diagram for three major partitioners, \doxylink{classtf_1_1_static_partitioner}{tf\+::\+Static\+Partitioner}, \doxylink{classtf_1_1_dynamic_partitioner}{tf\+::\+Dynamic\+Partitioner}, and \doxylink{classtf_1_1_guided_partitioner}{tf\+::\+Guided\+Partitioner}\+:



Depending on applications, partitioning algorithms can impact the performance a lot. For example, if a parallel-\/iteration workload contains a regular work unit per iteration, \doxylink{classtf_1_1_static_partitioner}{tf\+::\+Static\+Partitioner} may deliver the best performance. On the other hand, if the work unit per iteration is irregular and unbalanced, \doxylink{classtf_1_1_guided_partitioner}{tf\+::\+Guided\+Partitioner} or \doxylink{classtf_1_1_dynamic_partitioner}{tf\+::\+Dynamic\+Partitioner} can outperform \doxylink{classtf_1_1_static_partitioner}{tf\+::\+Static\+Partitioner}.

\begin{DoxyAttention}{注意}
By default, all parallel algorithms in Taskflow use \doxylink{namespacetf_ace2c5adcd5039483eebb6dbdbb6f33e3}{tf\+::\+Default\+Partitioner}, which is based on guided scheduling via \doxylink{classtf_1_1_guided_partitioner}{tf\+::\+Guided\+Partitioner}.
\end{DoxyAttention}
\hypertarget{_partitioning_algorithm_DefineAStaticPartitioner}{}\doxysubsection{\texorpdfstring{Define a Static Partitioner}{Define a Static Partitioner}}\label{_partitioning_algorithm_DefineAStaticPartitioner}
\doxylink{class_static}{Static} partitioner splits iterations into {\ttfamily iter\+\_\+size/chunk\+\_\+size} chunks and distribute chunks to workers in order. If no chunk size is given ({\ttfamily chunk\+\_\+size} is 0), Taskflow will partition iterations into chunks that are approximately equal in size. The following code creates a static partitioner with chunk size equal to 100\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_static_partitioner}{tf::StaticPartitioner}}\ static\_partitioner(100);}

\end{DoxyCode}
\hypertarget{_partitioning_algorithm_DefineADynamicPartitioner}{}\doxysubsection{\texorpdfstring{Define a Dynamic Partitioner}{Define a Dynamic Partitioner}}\label{_partitioning_algorithm_DefineADynamicPartitioner}
Dynamic partitioner splits iterations into {\ttfamily iter\+\_\+size/chunk\+\_\+size} chunks and distribute chunks to workers without any specific order. If no chunk size is given ({\ttfamily chunk\+\_\+size} is 0), Taskflow will use 1 for the minimum size of a partition. The following code creates a dynamic partitioner with chunk size equal to 2\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_dynamic_partitioner}{tf::DynamicPartitioner}}\ dynamic\_partitioner(2);}

\end{DoxyCode}
\hypertarget{_partitioning_algorithm_DefineAGuidedPartitioner}{}\doxysubsection{\texorpdfstring{Define a Guided Partitioner}{Define a Guided Partitioner}}\label{_partitioning_algorithm_DefineAGuidedPartitioner}
Guided partitioner dynamically decides the chunk size. The size of a chunk is proportional to the number of unassigned iterations divided by the number of the threads, and the size will gradually decrease to the specified chunk size (default 1). The last chunk may be smaller than the specified chunk size. If no chunk size is given ({\ttfamily chunk\+\_\+size} is 0), Taskflow will use 1 for the minimum size of a partition. The following code creates a guided partitioner with chunk size equal to 10\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_guided_partitioner}{tf::GuidedPartitioner}}\ guided\_partitioner(10);}

\end{DoxyCode}


In most situations, guided partitioner can achieve decent performance due to adaptive parallelism, especially for those with irregular and unbalanced workload per iteration. As a result, guided partitioner is used as the default partitioner for our parallel algorithms.\hypertarget{_partitioning_algorithm_DefineAClosureWrapperForAPartitioner}{}\doxysubsection{\texorpdfstring{Define a Closure Wrapper for a Partitioner}{Define a Closure Wrapper for a Partitioner}}\label{_partitioning_algorithm_DefineAClosureWrapperForAPartitioner}
In addition to partition size, applications can specify a {\itshape closure wrapper} for a partitioner. \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} closure wrapper allows the application to wrapper a partitioned task, i.\+e., closure, with a custom function object that performs additional tasks. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::atomic<int>\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a78e23769680a273f948d4bd3e946fcae}{count}}\ =\ 0;}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_taskflow}{tf::Taskflow}}\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}};}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.for\_each\_index(0,\ 100,\ 1,\ }
\DoxyCodeLine{\ \ []()\{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{printf_8h_aee3ed3a831f25f07e7be3919fff2203a}{printf}}(\textcolor{stringliteral}{"{}\%d\(\backslash\)n"{}},\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}});\ }
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1_static_partitioner}{tf::StaticPartitioner}}(0,\ [](\textcolor{keyword}{auto}\&\&\ closure)\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ do\ something\ before\ invoking\ the\ partitioned\ task}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ ...}}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ invoke\ the\ partitioned\ task}}
\DoxyCodeLine{\ \ \ \ closure();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ do\ something\ else\ after\ invoking\ the\ partitioned\ task}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ ...}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{);}
\DoxyCodeLine{\mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.\mbox{\hyperlink{classtf_1_1_executor_a519777f5783981d534e9e53b99712069}{run}}(\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}).wait();}

\end{DoxyCode}


Each partitioner uses a default closure wrapper (\doxylink{structtf_1_1_default_closure_wrapper}{tf\+::\+Default\+Closure\+Wrapper}) that does nothing but simply invokes the given closure to perform the ordinary partitioned task.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }\mbox{\hyperlink{structtf_1_1_default_closure_wrapper}{DefaultClosureWrapper}}\ \{}
\DoxyCodeLine{\ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ C>}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{void}\ operator()(\mbox{\hyperlink{test__buffer__node_8cpp_ac4cf4b2ab929bd23951a8676eeac086b}{C}}\&\&\ closure)\textcolor{keyword}{\ const\ }\{\ std::forward<C>(closure)();\ \}}
\DoxyCodeLine{\};}

\end{DoxyCode}
 