\doxysection{Release 2.2.0 (2019/06/15)}
\hypertarget{release-2-2-0}{}\label{release-2-2-0}\index{Release 2.2.0 (2019/06/15)@{Release 2.2.0 (2019/06/15)}}
Cpp-\/\+Taskflow 2.\+2.\+0 is the 3rd release in the 2.\+x line! This release includes several new changes such as tf\+::\+Executor\+Observer\+Interface, \doxylink{classtf_1_1_executor}{tf\+::\+Executor}, isolation of taskflow graph and executor, benchmarks, and so forth. In particular, this release improve the performance of the work stealing scheduler.\hypertarget{release-2-2-0_release-2-2-0_download}{}\doxysubsection{\texorpdfstring{Download}{Download}}\label{release-2-2-0_release-2-2-0_download}
Cpp-\/\+Taskflow 2.\+2.\+0 can be downloaded from \href{https://github.com/cpp-taskflow/cpp-taskflow/releases/tag/v2.2.0}{\texttt{ here}}.\hypertarget{release-2-2-0_release-2-2-0_new_features}{}\doxysubsection{\texorpdfstring{New Features}{New Features}}\label{release-2-2-0_release-2-2-0_new_features}
\begin{DoxyItemize}
\item \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} new executor class to isolate the execution module from a taskflow \item \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} new observer interface to inspect the activities of an executor \item \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} decomposable taskflow construction interface \item \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} new work-\/stealing algorithm to improve the performance\end{DoxyItemize}
\hypertarget{release-2-2-0_release-2-2-0_breaks_and_deprecated_features}{}\doxysubsection{\texorpdfstring{Breaks and Deprecated Features}{Breaks and Deprecated Features}}\label{release-2-2-0_release-2-2-0_breaks_and_deprecated_features}
In this release, we isolated the executor interface from \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow}, and merge tf\+::\+Framework with \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow}. This change largely improved the modularity and composability of Cpp-\/\+Taskflow in creating clean task dependency graphs and execution flows. Performance is also better. While this introduced some breaks in \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow}, we have managed to make it as less painful as possible for users to adapt to the new change.

Previously, \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow} is a hero class that manages both a task dependency graph and the execution of all graphs including frameworks. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ before\ v2.2.0,\ tf::Taskflow\ manages\ both\ graph\ and\ execution}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_taskflow}{tf::Taskflow}}\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}(4);\ \ \textcolor{comment}{//\ create\ a\ taskflow\ object\ with\ 4\ threads}}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}task\ A\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.wait\_for\_all();\ \ \ \textcolor{comment}{//\ dispatch\ the\ present\ graph}}
\DoxyCodeLine{}
\DoxyCodeLine{tf::Framework\ framework;\ \ \ \textcolor{comment}{//\ create\ a\ framework\ object}}
\DoxyCodeLine{framework.emplace([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}task\ B\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.run(framework);\ \ \ \textcolor{comment}{//\ run\ the\ framework\ once}}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.wait\_for\_all();\ \ \ \textcolor{comment}{//\ wait\ until\ the\ framework\ finishes}}

\end{DoxyCode}


However, this design is awkward in many aspects. For instance, calling {\ttfamily wait\+\_\+for\+\_\+all} dispatches the present graph and the graph vanishes when the execution completes. To reuse a graph, users have to create another special graph called framework and mix its execution with the one in a taskflow object. Given the user feedback and lessons we have learned so far, we decided to isolate the executor interface out of \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow} and merge tf\+::\+Framework with \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow}. All execution methods such as {\ttfamily dispatch} and {\ttfamily wait\+\_\+for\+\_\+all} have been moved from \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow} to \doxylink{classtf_1_1_executor}{tf\+::\+Executor}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ starting\ from\ v2.2.0,\ tf::Executor\ manages\ the\ execution\ of\ graphs}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_taskflow}{tf::Taskflow}}\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}};\ \ \ \ \ \ \textcolor{comment}{//\ create\ a\ taskflow\ to\ build\ dependent\ tasks}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}task\ A\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ \mbox{\hyperlink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}task\ B\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{\mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}.precede(\mbox{\hyperlink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B}});}
\DoxyCodeLine{}
\DoxyCodeLine{tf::Executor\ \mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}(4);\ \ \ \textcolor{comment}{//\ create\ an\ executor\ of\ 4\ threads}}
\DoxyCodeLine{\mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.\mbox{\hyperlink{classtf_1_1_executor_a519777f5783981d534e9e53b99712069}{run}}(\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}});\ \ \ \ \ \textcolor{comment}{//\ run\ the\ taskflow\ once}}
\DoxyCodeLine{\mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.\mbox{\hyperlink{classtf_1_1_executor_a519777f5783981d534e9e53b99712069}{run}}(\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}},\ 2);\ \ \textcolor{comment}{//\ run\ the\ taskflow\ twice}}
\DoxyCodeLine{\mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}}.\mbox{\hyperlink{classtf_1_1_executor_ab9aa252f70e9a40020a1e5a89d485b85}{wait\_for\_all}}();\ \ \ \ \textcolor{comment}{//\ wait\ for\ the\ three\ runs\ to\ finish}}

\end{DoxyCode}


The new design has a clean separation between a task dependency graph builder \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow} and the execution of graphs \doxylink{classtf_1_1_executor}{tf\+::\+Executor}. Users are fully responsible for the lifetime of a taskflow, and need to ensure a taskflow is alive during its execution. Besides, all task constructs remain unchanged in \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow}. In most situations, you will just need to add an executor to your program to run your taskflow graphs.

Again, we apologize this breaking change! I hope you can understand what we did is to make Cpp-\/\+Taskflow provide good performance scaling and user experience. 