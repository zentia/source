\doxysection{GPU Tasking (cuda\+Flow\+Capturer)}
\hypertarget{_g_p_u_taskingcuda_flow_capturer}{}\label{_g_p_u_taskingcuda_flow_capturer}\index{GPU Tasking (\%cudaFlowCapturer)@{GPU Tasking (\%cudaFlowCapturer)}}
You can create a cuda\+Flow through {\itshape stream capture}, which allows you to implicitly capture a CUDA graph using stream-\/based interface. Compared to explicit CUDA Graph construction (\doxylink{classtf_1_1cuda_flow}{tf\+::cuda\+Flow}), implicit CUDA Graph capturing (\doxylink{classtf_1_1cuda_flow_capturer}{tf\+::cuda\+Flow\+Capturer}) is more flexible in building GPU task graphs.\hypertarget{_g_p_u_taskingcuda_flow_capturer_GPUTaskingcudaFlowCapturerIncludeTheHeader}{}\doxysubsection{\texorpdfstring{Include the Header}{Include the Header}}\label{_g_p_u_taskingcuda_flow_capturer_GPUTaskingcudaFlowCapturerIncludeTheHeader}
You need to include the header file, {\ttfamily taskflow/cuda/cudaflow.hpp}, for capturing a GPU task graph using \doxylink{classtf_1_1cuda_flow_capturer}{tf\+::cuda\+Flow\+Capturer}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <\mbox{\hyperlink{cudaflow_8hpp}{taskflow/cuda/cudaflow.hpp}}>}}

\end{DoxyCode}
\hypertarget{_g_p_u_taskingcuda_flow_capturer_Capture_a_cudaFlow}{}\doxysubsection{\texorpdfstring{Capture a cuda\+Flow}{Capture a cuda\+Flow}}\label{_g_p_u_taskingcuda_flow_capturer_Capture_a_cudaFlow}
When your program has no access to direct kernel calls but can only invoke them through a stream-\/based interface (e.\+g., @cu\+BLAS and @cu\+DNN library functions), you can use \doxylink{classtf_1_1cuda_flow_capturer}{tf\+::cuda\+Flow\+Capturer} to capture the hidden GPU operations into a CUDA graph. \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} cuda\+Flow\+Capturer is similar to a cuda\+Flow except it constructs a GPU task graph through {\itshape stream capture}. You use the method \doxylink{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}{tf\+::cuda\+Flow\+Capturer\+::on} to capture a sequence of {\itshape asynchronous} GPU operations through the given stream. The following example creates a CUDA graph that captures two kernel tasks, {\ttfamily task\+\_\+1} ({\ttfamily my\+\_\+kernel\+\_\+1}) and {\ttfamily task\+\_\+2} ({\ttfamily my\+\_\+kernel\+\_\+2}) , where {\ttfamily task\+\_\+1} runs before {\ttfamily task\+\_\+2}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ create\ a\ cudaFlow\ capturer\ to\ run\ a\ CUDA\ graph\ using\ stream\ capturing}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{tf::cudaFlowCapturer}}\ capturer;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ capture\ my\_kernel\_1\ through\ a\ stream\ managed\ by\ capturer}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ task\_1\ =\ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}{on}}([\&](cudaStream\_t\ stream)\{\ }
\DoxyCodeLine{\ \ my\_kernel\_1<<<grid\_1,\ block\_1,\ shm\_size\_1,\ stream>>>(my\_parameters\_1);}
\DoxyCodeLine{\}).\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{name}}(\textcolor{stringliteral}{"{}my\_kernel\_1"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ capture\ my\_kernel\_2\ through\ a\ stream\ managed\ by\ capturer}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ task\_2\ =\ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}{on}}([\&](cudaStream\_t\ stream)\{\ }
\DoxyCodeLine{\ \ my\_kernel\_2<<<grid\_2,\ block\_2,\ shm\_size\_2,\ stream>>>(my\_parameters\_2);}
\DoxyCodeLine{\}).\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{name}}(\textcolor{stringliteral}{"{}my\_kernel\_2"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ my\_kernel\_1\ runs\ before\ my\_kernel\_2}}
\DoxyCodeLine{task\_1.\mbox{\hyperlink{classtf_1_1cuda_task_abdd68287ec4dff4216af34d1db44d1b4}{precede}}(task\_2);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ offload\ captured\ GPU\ tasks\ using\ the\ CUDA\ Graph\ execution\ model}}
\DoxyCodeLine{\mbox{\hyperlink{namespacetf_af19c9b301dc0b0fe2a51a960fa427e83}{tf::cudaStream}}\ stream;}
\DoxyCodeLine{capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a952596fd7c46acee4c2459d8fe39da28}{run}}(stream);}
\DoxyCodeLine{stream.\mbox{\hyperlink{classtf_1_1cuda_stream_base_a08857ff2874cd5378e578822e2e96dd0}{synchronize}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ dump\ the\ cudaFlow\ to\ a\ DOT\ format\ through\ std::cout}}
\DoxyCodeLine{capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a90d1265bcc27647906bed6e6876c9aa7}{dump}}(std::cout)}

\end{DoxyCode}


\begin{DoxyWarning}{警告}
Inside \doxylink{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}{tf\+::cuda\+Flow\+Capturer\+::on}, you should {\itshape NOT} modify the properties of the stream argument but only use it to capture {\itshape asynchronous} GPU operations (e.\+g., {\ttfamily kernel}, {\ttfamily cuda\+Memcpy\+Async}). The stream argument is internal to the capturer use only.
\end{DoxyWarning}
\hypertarget{_g_p_u_taskingcuda_flow_capturer_CommonCaptureMethods}{}\doxysubsection{\texorpdfstring{Common Capture Methods}{Common Capture Methods}}\label{_g_p_u_taskingcuda_flow_capturer_CommonCaptureMethods}
\doxylink{classtf_1_1cuda_flow_capturer}{tf\+::cuda\+Flow\+Capturer} defines a set of methods for capturing common GPU operations, such as \doxylink{classtf_1_1cuda_flow_capturer_a6f06c7f6954d8d67ad89f0eddfe285e9}{tf\+::cuda\+Flow\+Capturer\+::kernel}, \doxylink{classtf_1_1cuda_flow_capturer_ae84d097cdae9e2e8ce108dea760483ed}{tf\+::cuda\+Flow\+Capturer\+::memcpy}, \doxylink{classtf_1_1cuda_flow_capturer_a0d38965b380f940bf6cfc6667a281052}{tf\+::cuda\+Flow\+Capturer\+::memset}, and so on. For example, the following code snippet uses these pre-\/defined methods to construct a GPU task graph of one host-\/to-\/device copy, kernel, and one device-\/to-\/host copy, in this order of their dependencies.


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{tf::cudaFlowCapturer}}\ capturer;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ copy\ data\ from\ host\_data\ to\ gpu\_data}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ h2d\ =\ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ae84d097cdae9e2e8ce108dea760483ed}{memcpy}}(gpu\_data,\ host\_data,\ \mbox{\hyperlink{structbytes}{bytes}})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .name(\textcolor{stringliteral}{"{}h2d"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ capture\ my\_kernel\ to\ do\ computation\ on\ gpu\_data}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ kernel\ =\ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a6f06c7f6954d8d67ad89f0eddfe285e9}{kernel}}(grid,\ \mbox{\hyperlink{mimalloc_8h_af7f922b73e3acdb4a430b72f1a1334a5}{block}},\ shm\_size,\ kernel,\ kernel\_args);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .name(\textcolor{stringliteral}{"{}my\_kernel"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ copy\ data\ from\ gpu\_data\ to\ host\_data}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ d2h\ =\ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ae84d097cdae9e2e8ce108dea760483ed}{memcpy}}(host\_data,\ gpu\_data,\ \mbox{\hyperlink{structbytes}{bytes}})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .name(\textcolor{stringliteral}{"{}d2h"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ build\ task\ dependencies}}
\DoxyCodeLine{h2d.\mbox{\hyperlink{classtf_1_1cuda_task_abdd68287ec4dff4216af34d1db44d1b4}{precede}}(kernel);}
\DoxyCodeLine{kernel.\mbox{\hyperlink{classtf_1_1cuda_task_abdd68287ec4dff4216af34d1db44d1b4}{precede}}(d2h);}

\end{DoxyCode}
\hypertarget{_g_p_u_taskingcuda_flow_capturer_CreateACapturerOnASpecificGPU}{}\doxysubsection{\texorpdfstring{Create a Capturer on a Specific GPU}{Create a Capturer on a Specific GPU}}\label{_g_p_u_taskingcuda_flow_capturer_CreateACapturerOnASpecificGPU}
You can run a cuda\+Flow capturer on a specific GPU by switching to the context of that GPU using \doxylink{classtf_1_1cuda_scoped_device}{tf\+::cuda\+Scoped\+Device}, following the CUDA convention of multi-\/\+GPU programming. The example below creates a cuda\+Flow capturer and runs it on GPU {\ttfamily 2}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ create\ an\ RAII-\/styled\ switcher\ to\ the\ context\ of\ GPU\ 2}}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1cuda_scoped_device}{tf::cudaScopedDevice}}\ \mbox{\hyperlink{classcontext}{context}}(2);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ create\ a\ cudaFlow\ capturer\ under\ GPU\ 2}}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{tf::cudaFlowCapturer}}\ capturer;}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ ...}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ create\ a\ stream\ under\ GPU\ 2\ and\ offload\ the\ capturer\ to\ that\ GPU}}
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacetf_af19c9b301dc0b0fe2a51a960fa427e83}{tf::cudaStream}}\ stream;}
\DoxyCodeLine{\ \ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a952596fd7c46acee4c2459d8fe39da28}{run}}(stream);}
\DoxyCodeLine{\ \ stream.\mbox{\hyperlink{classtf_1_1cuda_stream_base_a08857ff2874cd5378e578822e2e96dd0}{synchronize}}();}
\DoxyCodeLine{\}}

\end{DoxyCode}


\doxylink{classtf_1_1cuda_scoped_device}{tf\+::cuda\+Scoped\+Device} is an RAII-\/styled wrapper to perform {\itshape scoped} switch to the given GPU context. When the scope is destroyed, it switches back to the original context.

\begin{DoxyAttention}{注意}
By default, a cuda\+Flow capturer runs on the current GPU associated with the caller, which is typically {\ttfamily 0}.
\end{DoxyAttention}
\hypertarget{_g_p_u_taskingcuda_flow_capturer_CreateACapturerWithinAcudaFlow}{}\doxysubsection{\texorpdfstring{Create a Capturer from a cuda\+Flow}{Create a Capturer from a cuda\+Flow}}\label{_g_p_u_taskingcuda_flow_capturer_CreateACapturerWithinAcudaFlow}
Within a parent cuda\+Flow, you can capture a cuda\+Flow to form a subflow that eventually becomes a {\itshape child} node in the underlying CUDA task graph. The following example defines a captured flow {\ttfamily task2} of two dependent tasks, {\ttfamily task2\+\_\+1} and {\ttfamily task2\+\_\+2}, and {\ttfamily task2} runs after {\ttfamily task1}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_flow}{tf::cudaFlow}}\ cudaflow;}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ task1\ =\ cudaflow.\mbox{\hyperlink{classtf_1_1cuda_graph_base_a1473a15a6023fbc25e1f029f2ff84aec}{kernel}}(grid,\ \mbox{\hyperlink{mimalloc_8h_af7f922b73e3acdb4a430b72f1a1334a5}{block}},\ shm,\ my\_kernel,\ \mbox{\hyperlink{tbbproxy_8cpp_acd08a6295eccfeb30c79985f047e4be5}{args}}...)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .name(\textcolor{stringliteral}{"{}kernel"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ task2\ forms\ a\ subflow\ as\ a\ child\ node\ in\ the\ underlying\ CUDA\ graph}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ task2\ =\ cudaflow.\mbox{\hyperlink{classtf_1_1cuda_flow_a89c389fff64a16e5dd8c60875d3b514d}{capture}}([\&](\mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{tf::cudaFlowCapturer}}\&\ capturer)\{}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ capture\ kernel\_1\ using\ the\ given\ stream}}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ task2\_1\ =\ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}{on}}([\&](cudaStream\_t\ stream)\{\ \ }
\DoxyCodeLine{\ \ \ \ kernel\_2<<<grid1,\ block1,\ shm\_size1,\ stream>>>(args1...);}
\DoxyCodeLine{\ \ \}).\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{name}}(\textcolor{stringliteral}{"{}kernel\_1"{}});\ \ }
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ capture\ kernel\_2\ using\ the\ given\ stream}}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ task2\_2\ =\ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}{on}}([\&](cudaStream\_t\ stream)\{\ \ }
\DoxyCodeLine{\ \ \ \ kernel\_2<<<grid2,\ block2,\ shm\_size2,\ stream>>>(args2...);}
\DoxyCodeLine{\ \ \}).\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{name}}(\textcolor{stringliteral}{"{}kernel\_2"{}});\ \ \ }
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ kernel\_1\ runs\ before\ kernel\_2}}
\DoxyCodeLine{\ \ task2\_1.\mbox{\hyperlink{classtf_1_1cuda_task_abdd68287ec4dff4216af34d1db44d1b4}{precede}}(task2\_2);}
\DoxyCodeLine{\}).\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{name}}(\textcolor{stringliteral}{"{}capturer"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{task1.\mbox{\hyperlink{classtf_1_1cuda_task_abdd68287ec4dff4216af34d1db44d1b4}{precede}}(task2);}

\end{DoxyCode}
\hypertarget{_g_p_u_taskingcuda_flow_capturer_OffloadAcudaFlowCapturer}{}\doxysubsection{\texorpdfstring{Offload a cuda\+Flow Capturer}{Offload a cuda\+Flow Capturer}}\label{_g_p_u_taskingcuda_flow_capturer_OffloadAcudaFlowCapturer}
When you offload a cuda\+Flow capturer using \doxylink{classtf_1_1cuda_flow_capturer_a952596fd7c46acee4c2459d8fe39da28}{tf\+::cuda\+Flow\+Capturer\+::run}, the runtime transforms that capturer (i.\+e., application GPU task graph) into a native CUDA graph and an executable instance both optimized for maximum kernel concurrency. Depending on the optimization algorithm, the application GPU task graph may be different from the actual executable graph submitted to the CUDA runtime.


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacetf_af19c9b301dc0b0fe2a51a960fa427e83}{tf::cudaStream}}\ stream;}
\DoxyCodeLine{\textcolor{comment}{//\ launch\ a\ cudaflow\ capturer\ asynchronously\ through\ a\ stream}}
\DoxyCodeLine{capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a952596fd7c46acee4c2459d8fe39da28}{run}}(stream);}
\DoxyCodeLine{\textcolor{comment}{//\ wait\ for\ the\ cudaflow\ to\ finish}}
\DoxyCodeLine{stream.\mbox{\hyperlink{classtf_1_1cuda_stream_base_a08857ff2874cd5378e578822e2e96dd0}{synchronize}}();}

\end{DoxyCode}
\hypertarget{_g_p_u_taskingcuda_flow_capturer_UpdateAcudaFlowCapturer}{}\doxysubsection{\texorpdfstring{Update a cuda\+Flow Capturer}{Update a cuda\+Flow Capturer}}\label{_g_p_u_taskingcuda_flow_capturer_UpdateAcudaFlowCapturer}
Between successive offloads (i.\+e., executions of a cuda\+Flow capturer), you can update the captured task with a different set of parameters. Every task-\/creation method in \doxylink{classtf_1_1cuda_flow_capturer}{tf\+::cuda\+Flow\+Capturer} has an overload to update the parameters of a created task by that method. The following example creates a kernel task and updates its parameter between successive runs\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespacetf_af19c9b301dc0b0fe2a51a960fa427e83}{tf::cudaStream}}\ stream;}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{tf::cudaFlowCapturer}}\ cf;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ create\ a\ kernel\ task}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}\ =\ cf.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a6f06c7f6954d8d67ad89f0eddfe285e9}{kernel}}(grid1,\ block1,\ shm1,\ kernel,\ kernel\_args\_1);}
\DoxyCodeLine{cf.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a952596fd7c46acee4c2459d8fe39da28}{run}}(stream);}
\DoxyCodeLine{stream.\mbox{\hyperlink{classtf_1_1cuda_stream_base_a08857ff2874cd5378e578822e2e96dd0}{synchronize}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ update\ the\ created\ kernel\ task\ with\ different\ parameters}}
\DoxyCodeLine{cf.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a6f06c7f6954d8d67ad89f0eddfe285e9}{kernel}}(\mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}},\ grid2,\ block2,\ shm2,\ kernel,\ kernel\_args\_2);}
\DoxyCodeLine{cf.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a952596fd7c46acee4c2459d8fe39da28}{run}}(stream);}
\DoxyCodeLine{stream.\mbox{\hyperlink{classtf_1_1cuda_stream_base_a08857ff2874cd5378e578822e2e96dd0}{synchronize}}();}

\end{DoxyCode}


When you run a updated cuda\+Flow capturer, Taskflow will try to update the underlying executable with the newly captured graph first. If that update is unsuccessful, Taskflow will destroy the executable graph and re-\/instantiate a new one from the newly captured graph.\hypertarget{_g_p_u_taskingcuda_flow_capturer_IntegrateCudaFlowCapturerIntoTaskflow}{}\doxysubsection{\texorpdfstring{Integrate a cuda\+Flow Capturer into Taskflow}{Integrate a cuda\+Flow Capturer into Taskflow}}\label{_g_p_u_taskingcuda_flow_capturer_IntegrateCudaFlowCapturerIntoTaskflow}
You can create a task to enclose a cuda\+Flow capturer and run it from a worker thread. The usage of the capturer remains the same except that the capturer is run by a worker thread from a taskflow task. The following example runs a cuda\+Flow capturer from a static task\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_executor}{tf::Executor}}\ \mbox{\hyperlink{thread__pool_8cpp_a543e564a8407bbeac15cb2d929fec755}{executor}};}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_taskflow}{tf::Taskflow}}\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}};}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([]()\{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ create\ a\ cudaFlow\ capturer\ inside\ a\ static\ task}}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{tf::cudaFlowCapturer}}\ capturer;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ ...\ capture\ a\ GPU\ task\ graph}}
\DoxyCodeLine{\ \ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a6f06c7f6954d8d67ad89f0eddfe285e9}{kernel}}(...);}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\ \ \textcolor{comment}{//\ run\ the\ capturer\ through\ a\ stream}}
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacetf_af19c9b301dc0b0fe2a51a960fa427e83}{tf::cudaStream}}\ stream;}
\DoxyCodeLine{\ \ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a952596fd7c46acee4c2459d8fe39da28}{run}}(stream);}
\DoxyCodeLine{\ \ stream.\mbox{\hyperlink{classtf_1_1cuda_stream_base_a08857ff2874cd5378e578822e2e96dd0}{synchronize}}();}
\DoxyCodeLine{\});}

\end{DoxyCode}
 