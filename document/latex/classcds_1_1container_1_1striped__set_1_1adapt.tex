\doxysection{cds\+::container\+::striped\+\_\+set\+::adapt\texorpdfstring{$<$}{<} Container, Options \texorpdfstring{$>$}{>} 模板类 参考}
\hypertarget{classcds_1_1container_1_1striped__set_1_1adapt}{}\label{classcds_1_1container_1_1striped__set_1_1adapt}\index{cds::container::striped\_set::adapt$<$ Container, Options $>$@{cds::container::striped\_set::adapt$<$ Container, Options $>$}}


Default adapter for intrusive striped/refinable hash set  




{\ttfamily \#include $<$adapter.\+h$>$}

\doxysubsubsection*{Public 类型}
\begin{DoxyCompactItemize}
\item 
typedef Container \mbox{\hyperlink{classcds_1_1container_1_1striped__set_1_1adapt_a30978a526c21debf20879b4e0e552759}{type}}
\begin{DoxyCompactList}\small\item\em adapted container type \end{DoxyCompactList}\item 
typedef type\+::value\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1striped__set_1_1adapt_a4ea11d6383e70cf10d92d1957931120d}{value\+\_\+type}}
\begin{DoxyCompactList}\small\item\em value type stored in the container \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}
\subsubsection*{template$<$typename Container, typename... Options$>$\newline
class cds\+::container\+::striped\+\_\+set\+::adapt$<$ Container, Options $>$}
Default adapter for intrusive striped/refinable hash set 

\begin{DoxyVerb}By default, the metafunction does not make any transformation for container type \p Container.
\p Container should provide interface suitable for the hash set.

The \p Options template argument contains option pack
that will be passed to \p cds::intrusive::StripedSet.
\end{DoxyVerb}


{\bfseries{Bucket interface}} \begin{DoxyVerb}The result of metafunction is a container (a bucket) that should support the following interface:

Public typedefs that the bucket should provide:
    - \p value_type - the type of the item in the bucket
    - \p iterator - bucket's item iterator
    - \p const_iterator - bucket's item constant iterator
    - \p default_resizing_policy - default resizing policy preferable for the container.
        By default, the library defines cds::container::striped_set::load_factor_resizing<4> for sequential containers like
        boost::intrusive::list,  and cds::container::striped_set::no_resizing for ordered container like boost::intrusive::set.

<b>Insert value \p val of type \p Q</b>
\code template <typename Func> bool insert( value_type& val, Func f ) ; \endcode
    Inserts \p val into the container and, if inserting is successful, calls functor \p f
    with \p val.

    The functor signature is:
    \code
    struct functor {
        void operator()( value_type& item );
    };
    \endcode
    where \p item is the item inserted.

    The user-defined functor \p f is called only if the inserting is success.
    <hr>

<b>Updates the item in the container</b>
\code template <typename Func> std::pair<bool, bool> update( value_type& val, Func f, bool bAllowInsert = true ) \endcode
    The operation performs inserting or changing data.

    If the \p val key not found in the container, then \p val is inserted iff \p bAllowInsert is \p true.
    Otherwise, the functor \p f is called with the item found.

    The \p Func functor has the following interface:
    \code
        void func( bool bNew, value_type& item, value_type& val );
    \endcode
    or like a functor:
    \code
        struct functor {
            void operator()( bool bNew, value_type& item, value_type& val );
        };
    \endcode

    where arguments are:
    - \p bNew - \p true if the item has been inserted, \p false otherwise
    - \p item - container's item
    - \p val - argument \p val passed into the \p update() function

    If \p val has been inserted (i.e. <tt>bNew == true</tt>) then \p item and \p val
    are the same element: <tt>&item == &val</tt>. Otherwise, they are different.

    The functor can change non-key fields of the \p item.

    Returns <tt> std::pair<bool, bool> </tt> where \p first is true if operation is successful,
    \p second is true if new item has been added or \p false if the item with \p val key
    already exists.
    <hr>

<b>Unlink an item</b>
\code bool unlink( value_type& val ) \endcode
    Unlink \p val from the container if \p val belongs to it.
    <hr>

<b>Erase \p key</b>
\code template <typename Q, typename Func> bool erase( Q const& key, Func f ) \endcode
    The function searches an item with key \p key, calls \p f functor
    and erases the item. If \p key is not found, the functor is not called.

    The functor \p Func interface is:
    \code
    struct functor {
        void operator()(value_type& val);
    };
    \endcode

    The type \p Q can differ from \ref value_type of items storing in the container.
    Therefore, the \p value_type should be comparable with type \p Q.

    Return \p true if key is found and deleted, \p false otherwise
    <hr>


<b>Find the key \p val </b>
\code
template <typename Q, typename Func> bool find( Q& val, Func f )
template <typename Q, typename Compare, typename Func> bool find( Q& val, Compare cmp, Func f )
\endcode
    The function searches the item with key equal to \p val and calls the functor \p f for item found.
    The interface of \p Func functor is:
    \code
    struct functor {
        void operator()( value_type& item, Q& val );
    };
    \endcode
    where \p item is the item found, \p val is the <tt>find</tt> function argument.

    The functor can change non-key fields of \p item.
    The \p val argument may be non-const since it can be used as \p f functor destination i.e., the functor
    can modify both arguments.

    The type \p Q can differ from \ref value_type of items storing in the container.
    Therefore, the \p value_type should be comparable with type \p Q.

    The first form uses default \p compare function used for key ordering.
    The second form allows to point specific \p Compare functor \p cmp
    that can compare \p value_typwe and \p Q type. The interface of \p Compare is the same as \p std::less.

    The function returns \p true if \p val is found, \p false otherwise.
    <hr>

<b>Clears the container</b>
\code
void clear()
template <typename Disposer> void clear( Disposer disposer )
\endcode
Second form calls \p disposer for each item in the container before clearing.
<hr>

<b>Get size of bucket</b>
\code size_t size() const \endcode
This function may be required by some resizing policy
<hr>

<b>Iterators</b>
\code
iterator begin();
const_iterator begin() const;
iterator end();
const_iterator end() const;
\endcode
<hr>

<b>Move item when resizing</b>
\code void move_item( adapted_container& from, iterator it ) \endcode
    This helper function is invented for the set resizing when the item
    pointed by \p it iterator is copied from old bucket \p from to a new bucket
    pointed by \p this.
<hr>
\end{DoxyVerb}
 

\doxysubsection{成员类型定义说明}
\Hypertarget{classcds_1_1container_1_1striped__set_1_1adapt_a30978a526c21debf20879b4e0e552759}\index{cds::container::striped\_set::adapt$<$ Container, Options $>$@{cds::container::striped\_set::adapt$<$ Container, Options $>$}!type@{type}}
\index{type@{type}!cds::container::striped\_set::adapt$<$ Container, Options $>$@{cds::container::striped\_set::adapt$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{type}{type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1striped__set_1_1adapt_a30978a526c21debf20879b4e0e552759} 
template$<$typename Container, typename... Options$>$ \\
typedef Container \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1adapt}{cds\+::intrusive\+::striped\+\_\+set\+::adapt}}$<$ Container, Options $>$\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_ae8396ff85d63082521e3324820df1009}{\+::type}}}



adapted container type 

\Hypertarget{classcds_1_1container_1_1striped__set_1_1adapt_a4ea11d6383e70cf10d92d1957931120d}\index{cds::container::striped\_set::adapt$<$ Container, Options $>$@{cds::container::striped\_set::adapt$<$ Container, Options $>$}!value\_type@{value\_type}}
\index{value\_type@{value\_type}!cds::container::striped\_set::adapt$<$ Container, Options $>$@{cds::container::striped\_set::adapt$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{value\_type}{value\_type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1striped__set_1_1adapt_a4ea11d6383e70cf10d92d1957931120d} 
template$<$typename Container, typename... Options$>$ \\
typedef type\+::value\+\_\+type \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1adapt}{cds\+::intrusive\+::striped\+\_\+set\+::adapt}}$<$ Container, Options $>$\+::value\+\_\+type}



value type stored in the container 



该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
external/libcds/cds/intrusive/striped\+\_\+set/\mbox{\hyperlink{intrusive_2striped__set_2adapter_8h}{adapter.\+h}}\end{DoxyCompactItemize}
