\doxysection{luisa\+::shared\+\_\+array\texorpdfstring{$<$}{<} T, Allocator, Deleter \texorpdfstring{$>$}{>} 模板类 参考}
\hypertarget{classluisa_1_1shared__array}{}\label{classluisa_1_1shared__array}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}


{\ttfamily \#include $<$shared\+\_\+array.\+h$>$}

\doxysubsubsection*{Public 类型}
\begin{DoxyCompactItemize}
\item 
typedef T \mbox{\hyperlink{classluisa_1_1shared__array_aaa38462b10f9fe454c1c08be27513ee9}{element\+\_\+type}}
\begin{DoxyCompactList}\small\item\em The allocator used to manage new/delete of mp\+Ref\+Count. \end{DoxyCompactList}\item 
typedef T \texorpdfstring{$\ast$}{*}(this\+\_\+type\+::\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classluisa_1_1shared__array_a86c8434cf75f90d4ea79f6ed2e013fa4}{bool\+\_\+}}) () const
\end{DoxyCompactItemize}
\doxysubsubsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classluisa_1_1shared__array_a1af96afc69d8edcb85e5fdc06391ca10}{shared\+\_\+array}} (T \texorpdfstring{$\ast$}{*}p\+Array=\mbox{\hyperlink{eabase_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}}, const \mbox{\hyperlink{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}{allocator\+\_\+type}} \&\mbox{\hyperlink{structluisa_1_1allocator}{allocator}}=\mbox{\hyperlink{shared__array_8h_a7f79c827abd03db4d011e51e597891ab}{EASTL\+\_\+\+SHARED\+\_\+\+ARRAY\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR}})
\item 
\mbox{\hyperlink{classluisa_1_1shared__array_a75a004d4437cce6a619e5504818fc566}{shared\+\_\+array}} (const \mbox{\hyperlink{classeastl_1_1shared__array}{shared\+\_\+array}} \&shared\+Array)
\item 
\mbox{\hyperlink{classluisa_1_1shared__array_a489abc97dc4458e5724e5e95a511063b}{\texorpdfstring{$\sim$}{\string~}shared\+\_\+array}} ()
\item 
\mbox{\hyperlink{classeastl_1_1shared__array}{shared\+\_\+array}} \& \mbox{\hyperlink{classluisa_1_1shared__array_a0996bcd75b174e7c710606ff07de831a}{operator=}} (const \mbox{\hyperlink{classeastl_1_1shared__array}{shared\+\_\+array}} \&shared\+Array)
\item 
\mbox{\hyperlink{classeastl_1_1shared__array}{shared\+\_\+array}} \& \mbox{\hyperlink{classluisa_1_1shared__array_a38c58a7f7bdb283508a64f3c10ac07de}{operator=}} (T \texorpdfstring{$\ast$}{*}p\+Value)
\item 
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classluisa_1_1shared__array_ad89618537040cf15e4b08dc92366e951}{reset}} (T \texorpdfstring{$\ast$}{*}p\+Array=\mbox{\hyperlink{eabase_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}})
\item 
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classluisa_1_1shared__array_aae9deb779abcda6ee88d5afa3bbeef06}{swap}} (\mbox{\hyperlink{classluisa_1_1shared__array_ac6e6c335bf964732dcc61039ab26ec82}{this\+\_\+type}} \&shared\+Array)
\item 
T \& \mbox{\hyperlink{classluisa_1_1shared__array_a794cbb1cbd84b3d9f5814aa6fee42500}{operator\mbox{[}$\,$\mbox{]}}} (ptrdiff\+\_\+t i) const
\item 
T \& \mbox{\hyperlink{classluisa_1_1shared__array_a913492165451f95661e08ca3e00ccaa5}{operator\texorpdfstring{$\ast$}{*}}} () const
\item 
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classluisa_1_1shared__array_ab55fdc4f0b708d22cff512ad891bebc1}{operator-\/$>$}} () const \mbox{\hyperlink{config_8h_a9f2560a8b4ca5ee60cc60934601d3bef}{EA\+\_\+\+NOEXCEPT}}
\item 
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classluisa_1_1shared__array_a86eb024aeac592b372e84e2b073eee52}{get}} () const \mbox{\hyperlink{config_8h_a9f2560a8b4ca5ee60cc60934601d3bef}{EA\+\_\+\+NOEXCEPT}}
\item 
\mbox{\hyperlink{sugar_8h_ae88a82478e3818cade3f598c25437904}{int}} \mbox{\hyperlink{classluisa_1_1shared__array_a8c2087afe6c59a34c651aa667e836f13}{use\+\_\+count}} () const
\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classluisa_1_1shared__array_a2be2706f0a925cb88a7aa9af0ac2c8cd}{unique}} () const
\item 
\mbox{\hyperlink{classluisa_1_1shared__array_a98422d9caf62ef552677c0a1137f3d8a}{operator bool\+\_\+}} () const \mbox{\hyperlink{config_8h_a9f2560a8b4ca5ee60cc60934601d3bef}{EA\+\_\+\+NOEXCEPT}}
\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classluisa_1_1shared__array_a0172a7a4378369cd6942dbe714d7e349}{operator!}} () const \mbox{\hyperlink{config_8h_a9f2560a8b4ca5ee60cc60934601d3bef}{EA\+\_\+\+NOEXCEPT}}
\item 
const \mbox{\hyperlink{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}{allocator\+\_\+type}} \& \mbox{\hyperlink{classluisa_1_1shared__array_ade0a01ff88ba6d8f3fe40a8291630014}{get\+\_\+allocator}} () const \mbox{\hyperlink{config_8h_a9f2560a8b4ca5ee60cc60934601d3bef}{EA\+\_\+\+NOEXCEPT}}
\item 
\mbox{\hyperlink{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}{allocator\+\_\+type}} \& \mbox{\hyperlink{classluisa_1_1shared__array_afa4ede7e8152b1fc65e223f1b7e42c7b}{get\+\_\+allocator}} () \mbox{\hyperlink{config_8h_a9f2560a8b4ca5ee60cc60934601d3bef}{EA\+\_\+\+NOEXCEPT}}
\item 
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classluisa_1_1shared__array_a1f223b516c809e8d0f18ff1d4faa6ae6}{set\+\_\+allocator}} (const \mbox{\hyperlink{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}{allocator\+\_\+type}} \&\mbox{\hyperlink{structluisa_1_1allocator}{allocator}})
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected 类型}
\begin{DoxyCompactItemize}
\item 
typedef \mbox{\hyperlink{classeastl_1_1shared__array}{shared\+\_\+array}}$<$ T $>$ \mbox{\hyperlink{classluisa_1_1shared__array_ac6e6c335bf964732dcc61039ab26ec82}{this\+\_\+type}}
\item 
typedef Allocator \mbox{\hyperlink{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}{allocator\+\_\+type}}
\begin{DoxyCompactList}\small\item\em allocator\+\_\+type \end{DoxyCompactList}\item 
typedef Deleter \mbox{\hyperlink{classluisa_1_1shared__array_ab9086f5c66ff283de5e3037512621177}{deleter\+\_\+type}}
\begin{DoxyCompactList}\small\item\em deleter\+\_\+type \end{DoxyCompactList}\item 
typedef \mbox{\hyperlink{sugar_8h_ae88a82478e3818cade3f598c25437904}{int}} \mbox{\hyperlink{classluisa_1_1shared__array_a410b1c69ebcb69058078d3837359b53d}{ref\+\_\+count}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected 属性}
\begin{DoxyCompactItemize}
\item 
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classluisa_1_1shared__array_aa09650b3e983afce6a07da719acf37a9}{mp\+Array}}
\item 
\mbox{\hyperlink{classluisa_1_1shared__array_a410b1c69ebcb69058078d3837359b53d}{ref\+\_\+count}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classluisa_1_1shared__array_a7528c82b811f438eb89d62979ad6e14e}{mp\+Ref\+Count}}
\begin{DoxyCompactList}\small\item\em The owned pointer. Points to an array of T. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}{allocator\+\_\+type}} \mbox{\hyperlink{classluisa_1_1shared__array_a73899a7f2b46b68cc788c95934a5edf4}{m\+Allocator}}
\begin{DoxyCompactList}\small\item\em Reference count for owned pointer. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}
\subsubsection*{template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$\newline
class luisa\+::shared\+\_\+array$<$ T, Allocator, Deleter $>$}
class \doxylink{classluisa_1_1shared__array}{shared\+\_\+array} A \doxylink{classluisa_1_1shared__array}{shared\+\_\+array} is the same as \doxylink{classluisa_1_1shared__ptr}{shared\+\_\+ptr} but for arrays. 

\doxysubsection{成员类型定义说明}
\Hypertarget{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!allocator\_type@{allocator\_type}}
\index{allocator\_type@{allocator\_type}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{allocator\_type}{allocator\_type}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
typedef Allocator \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::allocator\+\_\+type\hspace{0.3cm}{\ttfamily [protected]}}



allocator\+\_\+type 

\Hypertarget{classluisa_1_1shared__array_a86c8434cf75f90d4ea79f6ed2e013fa4}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!bool\_@{bool\_}}
\index{bool\_@{bool\_}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{bool\_}{bool\_}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a86c8434cf75f90d4ea79f6ed2e013fa4} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
typedef T \texorpdfstring{$\ast$}{*}(this\+\_\+type\+::\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::bool\+\_\+) () const}

Implicit operator bool Allows for using a scoped\+\_\+ptr as a boolean. Example usage\+: shared\+\_\+array$<$int$>$ ptr = new \doxylink{sugar_8h_ae88a82478e3818cade3f598c25437904}{int(3)}; \doxylink{sugar_8h_a89d24c74d8a8669b882cd54e44029c98}{if(ptr)} ++\texorpdfstring{$\ast$}{*}ptr;

Note that below we do not use operator \doxylink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool()}. The reason for this is that booleans automatically convert up to short, int, float, etc. The result is that this\+: if(shared\+Array == 1) would yield true (bad). \Hypertarget{classluisa_1_1shared__array_ab9086f5c66ff283de5e3037512621177}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!deleter\_type@{deleter\_type}}
\index{deleter\_type@{deleter\_type}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{deleter\_type}{deleter\_type}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_ab9086f5c66ff283de5e3037512621177} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
typedef Deleter \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::deleter\+\_\+type\hspace{0.3cm}{\ttfamily [protected]}}



deleter\+\_\+type 

\Hypertarget{classluisa_1_1shared__array_aaa38462b10f9fe454c1c08be27513ee9}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!element\_type@{element\_type}}
\index{element\_type@{element\_type}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{element\_type}{element\_type}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_aaa38462b10f9fe454c1c08be27513ee9} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
typedef T \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::element\+\_\+type}



The allocator used to manage new/delete of mp\+Ref\+Count. 

\Hypertarget{classluisa_1_1shared__array_a410b1c69ebcb69058078d3837359b53d}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!ref\_count@{ref\_count}}
\index{ref\_count@{ref\_count}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{ref\_count}{ref\_count}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a410b1c69ebcb69058078d3837359b53d} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
typedef \mbox{\hyperlink{sugar_8h_ae88a82478e3818cade3f598c25437904}{int}} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::ref\+\_\+count\hspace{0.3cm}{\ttfamily [protected]}}

ref\+\_\+count An internal reference count type. Must be convertable to int so that the public use\+\_\+count function can work. \Hypertarget{classluisa_1_1shared__array_ac6e6c335bf964732dcc61039ab26ec82}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!this\_type@{this\_type}}
\index{this\_type@{this\_type}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{this\_type}{this\_type}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_ac6e6c335bf964732dcc61039ab26ec82} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
typedef \mbox{\hyperlink{classeastl_1_1shared__array}{shared\+\_\+array}}$<$T$>$ \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::this\+\_\+type\hspace{0.3cm}{\ttfamily [protected]}}

this\+\_\+type This is an alias for shared\+\_\+array$<$\+T$>$, this class. 

\doxysubsection{构造及析构函数说明}
\Hypertarget{classluisa_1_1shared__array_a1af96afc69d8edcb85e5fdc06391ca10}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!shared\_array@{shared\_array}}
\index{shared\_array@{shared\_array}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{shared\_array()}{shared\_array()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a1af96afc69d8edcb85e5fdc06391ca10} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::shared\+\_\+array (\begin{DoxyParamCaption}\item[{T \texorpdfstring{$\ast$}{*}}]{p\+Array}{ = {\ttfamily \mbox{\hyperlink{eabase_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}}}, }\item[{const \mbox{\hyperlink{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}{allocator\+\_\+type}} \&}]{allocator}{ = {\ttfamily \mbox{\hyperlink{shared__array_8h_a7f79c827abd03db4d011e51e597891ab}{EASTL\+\_\+\+SHARED\+\_\+\+ARRAY\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR}}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}

\doxylink{classluisa_1_1shared__array}{shared\+\_\+array} Takes ownership of the pointer and sets the reference count to the pointer to 1. It is OK if the input pointer is null. The shared reference count is allocated on the heap via operator new. If an exception occurs during the allocation of the shared reference count, the owned pointer is deleted and the exception is rethrown. A null pointer is given a reference count of 1. \Hypertarget{classluisa_1_1shared__array_a75a004d4437cce6a619e5504818fc566}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!shared\_array@{shared\_array}}
\index{shared\_array@{shared\_array}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{shared\_array()}{shared\_array()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a75a004d4437cce6a619e5504818fc566} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::shared\+\_\+array (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classeastl_1_1shared__array}{shared\+\_\+array}}$<$ T, Allocator, Deleter $>$ \&}]{shared\+Array}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\doxylink{classluisa_1_1shared__array}{shared\+\_\+array} Shares ownership of a pointer with another instance of \doxylink{classluisa_1_1shared__array}{shared\+\_\+array}. This function increments the shared reference count on the pointer. If we want a \doxylink{classluisa_1_1shared__array}{shared\+\_\+array} constructor that is templated on \doxylink{classluisa_1_1shared__array}{shared\+\_\+array}\uline{, then we need to make it in addition to this function, as otherwise the compiler will generate this function and things will go wrong. }\Hypertarget{classluisa_1_1shared__array_a489abc97dc4458e5724e5e95a511063b}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!````~shared\_array@{\texorpdfstring{$\sim$}{\string~}shared\_array}}
\index{````~shared\_array@{\texorpdfstring{$\sim$}{\string~}shared\_array}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{\texorpdfstring{$\sim$}{\string~}shared\_array()}{\string~shared\_array()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a489abc97dc4458e5724e5e95a511063b} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::\texorpdfstring{$\sim$}{\string~}\mbox{\hyperlink{classeastl_1_1shared__array}{shared\+\_\+array}} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\texorpdfstring{$\sim$}{\string~}shared\+\_\+array Decrements the reference count for the owned pointer. If the reference count goes to zero, the owned pointer is deleted and the shared reference count is deleted. 

\doxysubsection{成员函数说明}
\Hypertarget{classluisa_1_1shared__array_a86eb024aeac592b372e84e2b073eee52}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!get@{get}}
\index{get@{get}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{get()}{get()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a86eb024aeac592b372e84e2b073eee52} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::get (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

get Returns the owned pointer. Note that this class does not provide an operator T() function. This is because such a thing (automatic conversion) is deemed unsafe. Example usage\+: struct X\{ void Do\+Something(); \}; shared\+\_\+array$<$int$>$ ptr = new X; X\texorpdfstring{$\ast$}{*} pX = ptr.\+get(); p\+X-\/\texorpdfstring{$>$}{>}Do\+Something(); \Hypertarget{classluisa_1_1shared__array_ade0a01ff88ba6d8f3fe40a8291630014}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_ade0a01ff88ba6d8f3fe40a8291630014} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
const \mbox{\hyperlink{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}{allocator\+\_\+type}} \& \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

get\+\_\+allocator Returns the memory allocator associated with this class. \Hypertarget{classluisa_1_1shared__array_afa4ede7e8152b1fc65e223f1b7e42c7b}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!get\_allocator@{get\_allocator}}
\index{get\_allocator@{get\_allocator}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{get\_allocator()}{get\_allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_afa4ede7e8152b1fc65e223f1b7e42c7b} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}{allocator\+\_\+type}} \& \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::get\+\_\+allocator (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{classluisa_1_1shared__array_a98422d9caf62ef552677c0a1137f3d8a}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!operator bool\_@{operator bool\_}}
\index{operator bool\_@{operator bool\_}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator bool\_()}{operator bool\_()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a98422d9caf62ef552677c0a1137f3d8a} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::operator bool\+\_\+ (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{classluisa_1_1shared__array_a0172a7a4378369cd6942dbe714d7e349}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!operator"!@{operator"!}}
\index{operator"!@{operator"!}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator"!()}{operator!()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a0172a7a4378369cd6942dbe714d7e349} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::operator! (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

operator! This returns the opposite of operator bool; it returns true if the owned pointer is null. Some compilers require this and some don\textquotesingle{}t. shared\+\_\+array$<$int$>$ ptr = new \doxylink{sugar_8h_ae88a82478e3818cade3f598c25437904}{int(3)}; if(!ptr) assert(false); \Hypertarget{classluisa_1_1shared__array_a913492165451f95661e08ca3e00ccaa5}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}}
\index{operator\texorpdfstring{$\ast$}{*}@{operator\texorpdfstring{$\ast$}{*}}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator\texorpdfstring{$\ast$}{*}()}{operator*()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a913492165451f95661e08ca3e00ccaa5} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
T \& \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::operator\texorpdfstring{$\ast$}{*} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

operator\texorpdfstring{$\ast$}{*} Returns the owner pointer dereferenced. Example usage\+: shared\+\_\+array$<$int$>$ ptr = new \doxylink{sugar_8h_ae88a82478e3818cade3f598c25437904}{int(3)}; int x = \texorpdfstring{$\ast$}{*}ptr; \Hypertarget{classluisa_1_1shared__array_ab55fdc4f0b708d22cff512ad891bebc1}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!operator-\/$>$@{operator-\/$>$}}
\index{operator-\/$>$@{operator-\/$>$}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator-\/$>$()}{operator->()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_ab55fdc4f0b708d22cff512ad891bebc1} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
T \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::operator-\/$>$ (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

operator-\/\texorpdfstring{$>$}{>} Allows access to the owned pointer via operator-\/$>$() Example usage\+: struct X\{ void Do\+Something(); \}; shared\+\_\+array$<$int$>$ ptr = new X; ptr-\/\texorpdfstring{$>$}{>}Do\+Something(); \Hypertarget{classluisa_1_1shared__array_a0996bcd75b174e7c710606ff07de831a}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!operator=@{operator=}}
\index{operator=@{operator=}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a0996bcd75b174e7c710606ff07de831a} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classeastl_1_1shared__array}{shared\+\_\+array}} \& \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classeastl_1_1shared__array}{shared\+\_\+array}}$<$ T, Allocator, Deleter $>$ \&}]{shared\+Array}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

operator= Copies another \doxylink{classluisa_1_1shared__array}{shared\+\_\+array} to this object. Note that this object may already own a shared pointer with another different pointer (but still of the same type) before this call. In that case, this function releases the old pointer, decrementing its reference count and deleting it if zero, takes shared ownership of the new pointer and increments its reference count. If we want a \doxylink{classluisa_1_1shared__array}{shared\+\_\+array} operator= that is templated on \doxylink{classluisa_1_1shared__array}{shared\+\_\+array}\uline{, then we need to make it in addition to this function, as otherwise the compiler will generate this function and things will go wrong. }\Hypertarget{classluisa_1_1shared__array_a38c58a7f7bdb283508a64f3c10ac07de}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!operator=@{operator=}}
\index{operator=@{operator=}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a38c58a7f7bdb283508a64f3c10ac07de} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classeastl_1_1shared__array}{shared\+\_\+array}} \& \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::operator= (\begin{DoxyParamCaption}\item[{T \texorpdfstring{$\ast$}{*}}]{p\+Value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

operator= Assigns a new pointer, while decrementing the reference count on the current pointer. The new pointer can be NULL and the current pointer can NULL. If the new pointer is equivalent to the current pointer, then nothing is done. \Hypertarget{classluisa_1_1shared__array_a794cbb1cbd84b3d9f5814aa6fee42500}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a794cbb1cbd84b3d9f5814aa6fee42500} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
T \& \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{ptrdiff\+\_\+t}]{i}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

operator\mbox{[}\mbox{]} Returns a reference to the specified item in the owned pointer array. Example usage\+: shared\+\_\+array$<$int$>$ ptr = new int\mbox{[}6\mbox{]}; int x = ptr\mbox{[}2\mbox{]}; \Hypertarget{classluisa_1_1shared__array_ad89618537040cf15e4b08dc92366e951}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!reset@{reset}}
\index{reset@{reset}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_ad89618537040cf15e4b08dc92366e951} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::reset (\begin{DoxyParamCaption}\item[{T \texorpdfstring{$\ast$}{*}}]{p\+Array}{ = {\ttfamily \mbox{\hyperlink{eabase_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

reset Releases the owned pointer and takes ownership of the passed in pointer. If the passed in pointer is the same as the owned pointer, nothing is done. The passed in pointer can be null, in which case the use count is set to 1. \Hypertarget{classluisa_1_1shared__array_a1f223b516c809e8d0f18ff1d4faa6ae6}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!set\_allocator@{set\_allocator}}
\index{set\_allocator@{set\_allocator}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{set\_allocator()}{set\_allocator()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a1f223b516c809e8d0f18ff1d4faa6ae6} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::set\+\_\+allocator (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}{allocator\+\_\+type}} \&}]{allocator}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

set\+\_\+allocator Sets the memory allocator associated with this class. \Hypertarget{classluisa_1_1shared__array_aae9deb779abcda6ee88d5afa3bbeef06}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!swap@{swap}}
\index{swap@{swap}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_aae9deb779abcda6ee88d5afa3bbeef06} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{mimalloc_8h_a9d6d8aef94ac19034a5f163606f84830}{void}} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classluisa_1_1shared__array_ac6e6c335bf964732dcc61039ab26ec82}{this\+\_\+type}} \&}]{shared\+Array}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

swap Exchanges the owned pointer beween two \doxylink{classluisa_1_1shared__array}{shared\+\_\+array} objects. \Hypertarget{classluisa_1_1shared__array_a2be2706f0a925cb88a7aa9af0ac2c8cd}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!unique@{unique}}
\index{unique@{unique}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a2be2706f0a925cb88a7aa9af0ac2c8cd} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::unique (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

unique Returns true if the reference count on the owned pointer is one. The return value is true if the owned pointer is null. \Hypertarget{classluisa_1_1shared__array_a8c2087afe6c59a34c651aa667e836f13}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!use\_count@{use\_count}}
\index{use\_count@{use\_count}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{use\_count()}{use\_count()}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a8c2087afe6c59a34c651aa667e836f13} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{sugar_8h_ae88a82478e3818cade3f598c25437904}{int}} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::use\+\_\+count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

use\+\_\+count Returns the reference count on the owned pointer. The return value is one if the owned pointer is null. 

\doxysubsection{类成员变量说明}
\Hypertarget{classluisa_1_1shared__array_a73899a7f2b46b68cc788c95934a5edf4}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!mAllocator@{mAllocator}}
\index{mAllocator@{mAllocator}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{mAllocator}{mAllocator}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a73899a7f2b46b68cc788c95934a5edf4} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classluisa_1_1shared__array_a5a0cbbbc8b308fecae79920a30a72a30}{allocator\+\_\+type}} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::m\+Allocator\hspace{0.3cm}{\ttfamily [protected]}}



Reference count for owned pointer. 

\Hypertarget{classluisa_1_1shared__array_aa09650b3e983afce6a07da719acf37a9}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!mpArray@{mpArray}}
\index{mpArray@{mpArray}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{mpArray}{mpArray}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_aa09650b3e983afce6a07da719acf37a9} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
T\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::mp\+Array\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classluisa_1_1shared__array_a7528c82b811f438eb89d62979ad6e14e}\index{luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}!mpRefCount@{mpRefCount}}
\index{mpRefCount@{mpRefCount}!luisa::shared\_array$<$ T, Allocator, Deleter $>$@{luisa::shared\_array$<$ T, Allocator, Deleter $>$}}
\doxysubsubsection{\texorpdfstring{mpRefCount}{mpRefCount}}
{\footnotesize\ttfamily \label{classluisa_1_1shared__array_a7528c82b811f438eb89d62979ad6e14e} 
template$<$typename T, typename Allocator = EASTLAllocator\+Type, typename Deleter = smart\+\_\+array\+\_\+deleter$<$\+T$>$$>$ \\
\mbox{\hyperlink{classluisa_1_1shared__array_a410b1c69ebcb69058078d3837359b53d}{ref\+\_\+count}}\texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classeastl_1_1shared__array}{eastl\+::shared\+\_\+array}}$<$ T, Allocator, Deleter $>$\+::mp\+Ref\+Count\hspace{0.3cm}{\ttfamily [protected]}}



The owned pointer. Points to an array of T. 



该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
runtime/\+EASTL/include/\+EASTL/\mbox{\hyperlink{shared__array_8h}{shared\+\_\+array.\+h}}\end{DoxyCompactItemize}
