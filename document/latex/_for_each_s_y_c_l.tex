\doxysection{Parallel Iterations}
\hypertarget{_for_each_s_y_c_l}{}\label{_for_each_s_y_c_l}\index{Parallel Iterations@{Parallel Iterations}}
\doxylink{classtf_1_1sycl_flow}{tf\+::sycl\+Flow} provides two template methods, \doxylink{classtf_1_1sycl_flow_a30c3f7a279d1f88b6052f7ded1ee381a}{tf\+::sycl\+Flow\+::for\+\_\+each} and \doxylink{classtf_1_1sycl_flow_a25e8aa7d7efbd05ef11353317174574a}{tf\+::sycl\+Flow\+::for\+\_\+each\+\_\+index}, for creating tasks to perform parallel iterations over a range of items.\hypertarget{_for_each_s_y_c_l_ForEachSYCLIndexBasedParallelFor}{}\doxysubsection{\texorpdfstring{Index-\/based Parallel Iterations}{Index-\/based Parallel Iterations}}\label{_for_each_s_y_c_l_ForEachSYCLIndexBasedParallelFor}
Index-\/based parallel-\/for performs parallel iterations over a range {\ttfamily \mbox{[}first, last)} with the given {\ttfamily step} size. These indices must be {\itshape integral} type. The task created by \doxylink{classtf_1_1sycl_flow_a25e8aa7d7efbd05ef11353317174574a}{tf\+::sycl\+Flow\+::for\+\_\+each\+\_\+index(\+I first, I last, I step, C\&\& callable)} represents a kernel of parallel execution for the following loop\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ positive\ step:\ first,\ first+step,\ first+2*step,\ ...}}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}=first;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}<last;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}+=step)\ \{}
\DoxyCodeLine{\ \ callable(\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}});}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{comment}{//\ negative\ step:\ first,\ first-\/step,\ first-\/2*step,\ ...}}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}=first;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}>last;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}+=step)\ \{}
\DoxyCodeLine{\ \ callable(\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}});}
\DoxyCodeLine{\}}

\end{DoxyCode}


Each iteration {\ttfamily i} is independent of each other and is assigned one kernel thread to run the callable. The following example creates a kernel that assigns each element of {\ttfamily gpu\+\_\+data} to 1 over the range {\ttfamily }\mbox{[}0, 100) with step size 1.


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace\_on([\&](\mbox{\hyperlink{classtf_1_1sycl_flow}{tf::syclFlow}}\&\ sf)\{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ ...\ create\ other\ gpu\ tasks}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ assigns\ each\ element\ in\ gpu\_data\ to\ 1\ over\ the\ range\ [0,\ 100)\ with\ step\ size\ 1}}
\DoxyCodeLine{\ \ sf.for\_each\_index(0,\ 100,\ 1,\ [gpu\_data]\ (\textcolor{keywordtype}{int}\ idx)\ \{}
\DoxyCodeLine{\ \ \ \ gpu\_data[idx]\ =\ 1;}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{\},\ \mbox{\hyperlink{tensor__benchmarks__sycl_8cc_a3cf6b70d081116fb8e9b0f56a2d69a50}{sycl\_queue}});}

\end{DoxyCode}
\hypertarget{_for_each_s_y_c_l_ForEachSYCLIteratorBasedParallelIterations}{}\doxysubsection{\texorpdfstring{Iterator-\/based Parallel Iterations}{Iterator-\/based Parallel Iterations}}\label{_for_each_s_y_c_l_ForEachSYCLIteratorBasedParallelIterations}
Iterator-\/based parallel-\/for performs parallel iterations over a range specified by two STL-\/styled iterators, {\ttfamily first} and {\ttfamily last}. The task created by \doxylink{classtf_1_1sycl_flow_a30c3f7a279d1f88b6052f7ded1ee381a}{tf\+::sycl\+Flow\+::for\+\_\+each(\+I first, I last, C\&\& callable)} represents a parallel execution of the following loop\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}=first;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}<last;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}++)\ \{}
\DoxyCodeLine{\ \ callable(*\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}});}
\DoxyCodeLine{\}}

\end{DoxyCode}


The two iterators, {\ttfamily first} and {\ttfamily last}, are typically two raw pointers to the first element and the next to the last element in the range in GPU memory space. The following example creates a {\ttfamily for\+\_\+each} kernel that assigns each element in {\ttfamily gpu\+\_\+data} to 1 over the range {\ttfamily \mbox{[}gpu\+\_\+data, gpu\+\_\+data + 1000)}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace\_on([\&](\mbox{\hyperlink{classtf_1_1sycl_flow}{tf::syclFlow}}\&\ cf)\{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ ...\ create\ gpu\ tasks}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ assigns\ each\ element\ to\ 1\ over\ the\ range\ [gpu\_data,\ gpu\_data\ +\ 1000)}}
\DoxyCodeLine{\ \ cf.\mbox{\hyperlink{classtf_1_1sycl_flow_a30c3f7a279d1f88b6052f7ded1ee381a}{for\_each}}(gpu\_data,\ gpu\_data\ +\ 1000,\ []\ (\textcolor{keywordtype}{int}\&\ item)\ \{}
\DoxyCodeLine{\ \ \ \ item\ =\ 1;}
\DoxyCodeLine{\ \ \});\ }
\DoxyCodeLine{\},\ \mbox{\hyperlink{tensor__benchmarks__sycl_8cc_a3cf6b70d081116fb8e9b0f56a2d69a50}{sycl\_queue}});}

\end{DoxyCode}


Each iteration is independent of each other and is assigned one kernel thread to run the callable. 