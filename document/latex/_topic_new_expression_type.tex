\doxysubsection{Adding a new expression type}
\hypertarget{_topic_new_expression_type}{}\label{_topic_new_expression_type}\index{Adding a new expression type@{Adding a new expression type}}
\begin{DoxyWarning}{警告}
Disclaimer\+: this page is tailored to very advanced users who are not afraid of dealing with some Eigen\textquotesingle{}s internal aspects. In most cases, a custom expression can be avoided by either using custom \doxylink{class_eigen_1_1_matrix_base_a2de0adad84adee3cac297432876dd67c}{unary} or \doxylink{class_eigen_1_1_matrix_base_a798e9a244bd6dc3ea5444f3576080ec2}{binary} functors, while extremely complex matrix manipulations can be achieved by a nullary functors as described in the \doxylink{TopicCustomizing_NullaryExpr}{previous page}.
\end{DoxyWarning}
This page describes with the help of an example how to implement a new light-\/weight expression type in Eigen. This consists of three parts\+: the expression type itself, a traits class containing compile-\/time information about the expression, and the evaluator class which is used to evaluate the expression to a matrix.

{\bfseries{TO}} {\bfseries{DO\+:}} Write a page explaining the design, with details on vectorization etc., and refer to that page here.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_new_expression_type_TopicSetting}{}\doxysubsubsection{\texorpdfstring{The setting}{The setting}}\label{_topic_new_expression_type_TopicSetting}
\doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} circulant matrix is a matrix where each column is the same as the column to the left, except that it is cyclically shifted downwards. For example, here is a 4-\/by-\/4 circulant matrix\+:      \[ \begin{bmatrix} 
    1 & 8 & 4 & 2 \\ 
    2 & 1 & 8 & 4 \\
    4 & 2 & 1 & 8 \\
    8 & 4 & 2 & 1
\end{bmatrix} \] \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} circulant matrix is uniquely determined by its first column. We wish to write a function {\ttfamily make\+Circulant} which, given the first column, returns an expression representing the circulant matrix.

For simplicity, we restrict the {\ttfamily make\+Circulant} function to dense matrices. It may make sense to also allow arrays, or sparse matrices, but we will not do so here. We also do not want to support vectorization.\hypertarget{_topic_new_expression_type_TopicPreamble}{}\doxysubsubsection{\texorpdfstring{Getting started}{Getting started}}\label{_topic_new_expression_type_TopicPreamble}
We will present the file implementing the {\ttfamily make\+Circulant} function part by part. We start by including the appropriate header files and forward declaring the expression class, which we will call {\ttfamily Circulant}. The {\ttfamily make\+Circulant} function will return an object of this type. The class {\ttfamily Circulant} is in fact a class template; the template argument {\ttfamily Arg\+Type} refers to the type of the vector passed to the {\ttfamily make\+Circulant} function.


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
\hypertarget{_topic_new_expression_type_TopicTraits}{}\doxysubsubsection{\texorpdfstring{The traits class}{The traits class}}\label{_topic_new_expression_type_TopicTraits}
For every expression class {\ttfamily X}, there should be a traits class {\ttfamily Traits$<$\+X$>$} in the {\ttfamily \doxylink{namespace_eigen_1_1internal}{Eigen\+::internal}} namespace containing information about {\ttfamily X} known as compile time.

As explained in \doxysectlink{_topic_new_expression_type_TopicSetting}{The setting}{1}, we designed the {\ttfamily Circulant} expression class to refer to dense matrices. The entries of the circulant matrix have the same type as the entries of the vector passed to the {\ttfamily make\+Circulant} function. The type used to index the entries is also the same. Again for simplicity, we will only return column-\/major matrices. Finally, the circulant matrix is a square matrix (number of rows equals number of columns), and the number of rows equals the number of rows of the column vector passed to the {\ttfamily make\+Circulant} function. If this is a dynamic-\/size vector, then the size of the circulant matrix is not known at compile-\/time.

This leads to the following code\+:


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
\hypertarget{_topic_new_expression_type_TopicExpression}{}\doxysubsubsection{\texorpdfstring{The expression class}{The expression class}}\label{_topic_new_expression_type_TopicExpression}
The next step is to define the expression class itself. In our case, we want to inherit from {\ttfamily \doxylink{class_eigen_1_1_matrix_base}{Matrix\+Base}} in order to expose the interface for dense matrices. In the constructor, we check that we are passed a column vector (see \doxylink{TopicAssertions}{Assertions}) and we store the vector from which we are going to build the circulant matrix in the member variable {\ttfamily m\+\_\+arg}. Finally, the expression class should compute the size of the corresponding circulant matrix. As explained above, this is a square matrix with as many columns as the vector used to construct the matrix.

{\bfseries{TO}} {\bfseries{DO\+:}} What about the {\ttfamily Nested} typedef? It seems to be necessary; is this only temporary?


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
\hypertarget{_topic_new_expression_type_TopicEvaluator}{}\doxysubsubsection{\texorpdfstring{The evaluator}{The evaluator}}\label{_topic_new_expression_type_TopicEvaluator}
The last big fragment implements the evaluator for the {\ttfamily Circulant} expression. The evaluator computes the entries of the circulant matrix; this is done in the {\ttfamily }.coeff() member function. The entries are computed by finding the corresponding entry of the vector from which the circulant matrix is constructed. Getting this entry may actually be non-\/trivial when the circulant matrix is constructed from a vector which is given by a complicated expression, so we use the evaluator which corresponds to the vector.

The {\ttfamily Coeff\+Read\+Cost} constant records the cost of computing an entry of the circulant matrix; we ignore the index computation and say that this is the same as the cost of computing an entry of the vector from which the circulant matrix is constructed.

In the constructor, we save the evaluator for the column vector which defined the circulant matrix. We also save the size of that vector; remember that we can query an expression object to find the size but not the evaluator.


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
\hypertarget{_topic_new_expression_type_TopicEntry}{}\doxysubsubsection{\texorpdfstring{The entry point}{The entry point}}\label{_topic_new_expression_type_TopicEntry}
After all this, the {\ttfamily make\+Circulant} function is very simple. It simply creates an expression object and returns it.


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
\hypertarget{_topic_new_expression_type_TopicMain}{}\doxysubsubsection{\texorpdfstring{A simple main function for testing}{A simple main function for testing}}\label{_topic_new_expression_type_TopicMain}
Finally, a short {\ttfamily main} function that shows how the {\ttfamily make\+Circulant} function can be called.


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}


If all the fragments are combined, the following output is produced, showing that the program works as expected\+:


\begin{DoxyCodeInclude}{0}

\end{DoxyCodeInclude}
 