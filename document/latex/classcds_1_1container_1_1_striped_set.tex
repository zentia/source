\doxysection{cds\+::container\+::Striped\+Set\texorpdfstring{$<$}{<} Container, Options \texorpdfstring{$>$}{>} 模板类 参考}
\hypertarget{classcds_1_1container_1_1_striped_set}{}\label{classcds_1_1container_1_1_striped_set}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}


Striped hash set  




{\ttfamily \#include $<$striped\+\_\+set.\+h$>$}



类 cds\+::container\+::Striped\+Set\texorpdfstring{$<$}{<} Container, Options \texorpdfstring{$>$}{>} 继承关系图\+:
% FIG 0


cds\+::container\+::Striped\+Set\texorpdfstring{$<$}{<} Container, Options \texorpdfstring{$>$}{>} 的协作图\+:
% FIG 1
\doxysubsubsection*{Public 类型}
\begin{DoxyCompactItemize}
\item 
typedef Container \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_ab78f765a66999a851520edd05688f688}{underlying\+\_\+container\+\_\+type}}
\begin{DoxyCompactList}\small\item\em original intrusive container type for the bucket \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::bucket\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_acd05847a606289e2125e22c390836e2d}{bucket\+\_\+type}}
\begin{DoxyCompactList}\small\item\em container type adapted for hash set \end{DoxyCompactList}\item 
typedef bucket\+\_\+type\+::value\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\+\_\+type}}
\begin{DoxyCompactList}\small\item\em value type stored in the set \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::hash \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_ab3b1488d09e53e4fdadf2581db30b311}{hash}}
\begin{DoxyCompactList}\small\item\em \doxylink{struct_hash}{Hash} functor \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::item\+\_\+counter \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_aff8e128e84f4a17ae60a837867556050}{item\+\_\+counter}}
\begin{DoxyCompactList}\small\item\em Item counter \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::resizing\+\_\+policy \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a132347759ae9e7929c5dc75a53890687}{resizing\+\_\+policy}}
\begin{DoxyCompactList}\small\item\em Resizing policy \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::allocator\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_ae456575fca3f9634a4cbc25504d01a2a}{allocator\+\_\+type}}
\begin{DoxyCompactList}\small\item\em allocator type specified in options. \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::mutex\+\_\+policy \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a52867de81f8ae19c2bc1d261694470ec}{mutex\+\_\+policy}}
\begin{DoxyCompactList}\small\item\em Mutex policy \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a5b62b8c4af0730a78837e3c8a29994c2}{Striped\+Set}} ()
\begin{DoxyCompactList}\small\item\em Default ctor. The initial capacity is 16. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a319c779ca7127d5fc03ade9a521a0338}{Striped\+Set}} (size\+\_\+t n\+Capacity)
\begin{DoxyCompactList}\small\item\em Ctor with initial capacity specified \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a481f34c5eb75bfb09aa7eca7f91c6e13}{Striped\+Set}} (size\+\_\+t n\+Capacity, \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a132347759ae9e7929c5dc75a53890687}{resizing\+\_\+policy}} const \&resizing\+Policy)
\begin{DoxyCompactList}\small\item\em Ctor with resizing policy (copy semantics) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a0a2289fff041c278598a6fe5e447ceb7}{Striped\+Set}} (size\+\_\+t n\+Capacity, \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a132347759ae9e7929c5dc75a53890687}{resizing\+\_\+policy}} \&\&resizing\+Policy)
\begin{DoxyCompactList}\small\item\em Ctor with resizing policy (move semantics) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a0eee4ba35c6a33a03d12ad436cefc832}{\texorpdfstring{$\sim$}{\string~}\+Striped\+Set}} ()
\begin{DoxyCompactList}\small\item\em Destructor destroys internal data \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_aff8843b99b6f85ad37e9b4e4d920f523}{insert}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&val)
\begin{DoxyCompactList}\small\item\em Inserts new node \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Func$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a6516d09d6a558712c1827bf57bd65b53}{insert}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&val, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em Inserts new node \end{DoxyCompactList}\item 
{\footnotesize template$<$typename... Args$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a7ad9d39e24e0e1104be28f212e22fedc}{emplace}} (Args \&\&... \mbox{\hyperlink{tbbproxy_8cpp_acd08a6295eccfeb30c79985f047e4be5}{args}})
\begin{DoxyCompactList}\small\item\em Inserts data of type {\ttfamily value\+\_\+type} constructed with {\ttfamily std\+::forward$<$\+Args$>$(args)...} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Func$>$ }\\std\+::pair$<$ \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} $>$ \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_ae7015cd2952dd86da2b035b34be624fd}{update}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&val, Func \mbox{\hyperlink{structfunc}{func}}, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} b\+Allow\+Insert=\mbox{\hyperlink{yyjson_8h_a41f9c5fb8b08eb5dc3edce4dcb37fee7}{true}})
\begin{DoxyCompactList}\small\item\em Updates the node \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_ad89f2115ab187e2105c91dd933cb82d7}{erase}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}})
\begin{DoxyCompactList}\small\item\em Delete {\ttfamily key} from the set \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Less, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+erase\+\_\+with $>$\+::type$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a93bbd4712424855500108292e10935f7}{erase\+\_\+with}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Less pred)
\begin{DoxyCompactList}\small\item\em Deletes the item from the set using {\ttfamily pred} predicate for searching \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Func$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a0c3e75924c53c72d92082b484975af7a}{erase}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em Delete {\ttfamily key} from the set \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Less, typename Func, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+erase\+\_\+with $>$\+::type$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_af161c84a97d8357664c37720bdf77879}{erase\+\_\+with}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Less pred, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em Deletes the item from the set using {\ttfamily pred} predicate for searching \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Func$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a203525441d38698012f814d8408f6d36}{find}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} \&val, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em \doxylink{struct_find}{Find} the key {\ttfamily val} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Less, typename Func, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+find\+\_\+with $>$\+::type$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a7aaecb8e05cd335c57507c1a69ea3078}{find\+\_\+with}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} \&val, Less pred, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em \doxylink{struct_find}{Find} the key {\ttfamily val} using {\ttfamily pred} predicate \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Func$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_acb9099506c1034b3a5f437db5e73c1d0}{find}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&val, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em \doxylink{struct_find}{Find} the key {\ttfamily val} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Less, typename Func, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+find\+\_\+with $>$\+::type$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a6a062a1d56946e140c120856be09b04a}{find\+\_\+with}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&val, Less pred, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em \doxylink{struct_find}{Find} the key {\ttfamily val} using {\ttfamily pred} predicate \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_aa0dfbf9bd83bc92c1d7611532811c523}{contains}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}})
\begin{DoxyCompactList}\small\item\em Checks whether the set contains {\ttfamily key} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Less, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+find\+\_\+with $>$\+::type$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a4581ada4d40d30156be2138d96209008}{contains}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Less pred)
\begin{DoxyCompactList}\small\item\em Checks whether the map contains {\ttfamily key} using {\ttfamily pred} predicate for searching \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a4bdfcbca5e48b3d517b9e450a06e9be1}{clear}} ()
\begin{DoxyCompactList}\small\item\em Clears the set \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a1e30b916dabbf37f56dd07915e5102f2}{empty}} () const
\begin{DoxyCompactList}\small\item\em Checks if the set is empty \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a57316947488c56167c0a0b39907e90ec}{size}} () const
\begin{DoxyCompactList}\small\item\em Returns item count in the set \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a4e88c75874196bc4a034da5a5ac2806c}{bucket\+\_\+count}} () const
\begin{DoxyCompactList}\small\item\em Returns the size of hash table \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_ac40ae86014cc00810a3999531bd90f82}{lock\+\_\+count}} () const
\begin{DoxyCompactList}\small\item\em Returns lock array size \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a132347759ae9e7929c5dc75a53890687}{resizing\+\_\+policy}} \& \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a9dd67e51632fa6661b0c242f6963b85d}{get\+\_\+resizing\+\_\+policy}} ()
\begin{DoxyCompactList}\small\item\em Returns resizing policy object \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a132347759ae9e7929c5dc75a53890687}{resizing\+\_\+policy}} const \& \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a0e5a5482b98e8971be6bbbe242904ec5}{get\+\_\+resizing\+\_\+policy}} () const
\begin{DoxyCompactList}\small\item\em Returns resizing policy (const version) \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{额外继承的成员函数}
\doxysubsection*{Protected 类型 继承自 \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set}{cds\+::intrusive\+::\+Striped\+Set$<$ Container, Options... $>$}}}
\begin{DoxyCompactItemize}
\item 
typedef Container \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a30062f90ac31fe161c7cd4539fcaaf13}{underlying\+\_\+container\+\_\+type}}
\begin{DoxyCompactList}\small\item\em original intrusive container type for the bucket \end{DoxyCompactList}\item 
typedef \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1adapt}{cds\+::intrusive\+::striped\+\_\+set\+::adapt}}$<$ \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a30062f90ac31fe161c7cd4539fcaaf13}{underlying\+\_\+container\+\_\+type}}, Options... $>$\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_ae8396ff85d63082521e3324820df1009}{\+::type}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a64586b7a2b21c90196c2116ef594ec04}{bucket\+\_\+type}}
\begin{DoxyCompactList}\small\item\em container type adapted for hash set \end{DoxyCompactList}\item 
typedef bucket\+\_\+type\+::value\+\_\+type \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a999c16c7efc7a140c386cf8089d43f7b}{value\+\_\+type}}
\begin{DoxyCompactList}\small\item\em value type stored in the set \end{DoxyCompactList}\item 
typedef options\+::hash \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a3b11af7149d2edcdcf89875dd82f29c3}{hash}}
\begin{DoxyCompactList}\small\item\em \doxylink{struct_hash}{Hash} functor \end{DoxyCompactList}\item 
typedef options\+::item\+\_\+counter \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_abc27916ad8566742257adde4f5b0d36c}{item\+\_\+counter}}
\begin{DoxyCompactList}\small\item\em Item counter \end{DoxyCompactList}\item 
typedef \mbox{\hyperlink{structcds_1_1opt_1_1select__default}{cds\+::opt\+::select\+\_\+default}}$<$ typenameoptions\+::resizing\+\_\+policy, typenamebucket\+\_\+type\+::default\+\_\+resizing\+\_\+policy $>$\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_ae8396ff85d63082521e3324820df1009}{\+::type}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a3c8cacda66c49872225f89568559aa29}{resizing\+\_\+policy}}
\begin{DoxyCompactList}\small\item\em Resizing policy \end{DoxyCompactList}\item 
typedef options\+::allocator \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a47cdc2d40853a651780c1a2afe7309ed}{allocator\+\_\+type}}
\begin{DoxyCompactList}\small\item\em allocator type specified in options. \end{DoxyCompactList}\item 
typedef options\+::mutex\+\_\+policy \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_af672d590a91e09833aa27621f7e35c26}{mutex\+\_\+policy}}
\begin{DoxyCompactList}\small\item\em Mutex policy \end{DoxyCompactList}\item 
typedef \mbox{\hyperlink{classcds_1_1details_1_1_allocator}{cds\+::details\+::\+Allocator}}$<$ \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a64586b7a2b21c90196c2116ef594ec04}{bucket\+\_\+type}}, \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a47cdc2d40853a651780c1a2afe7309ed}{allocator\+\_\+type}} $>$ \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_ad7217f5fc38b03f908957969c227dc28}{bucket\+\_\+allocator}}
\begin{DoxyCompactList}\small\item\em bucket allocator type based on \doxylink{classcds_1_1intrusive_1_1_striped_set_a47cdc2d40853a651780c1a2afe7309ed}{allocator\+\_\+type} \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected 成员函数 继承自 \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set}{cds\+::intrusive\+::\+Striped\+Set$<$ Container, Options... $>$}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a8c4b97b427950b0b119e6314337611a6}{Striped\+Set}} ()
\begin{DoxyCompactList}\small\item\em Default ctor. The initial capacity is 16. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a1a8ca33aa2ce383440759a0cf0a177e1}{Striped\+Set}} (size\+\_\+t n\+Capacity)
\begin{DoxyCompactList}\small\item\em Ctor with initial capacity specified \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a335e83b344ba93844182d4e1ff1708dc}{Striped\+Set}} (size\+\_\+t n\+Capacity, \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a3c8cacda66c49872225f89568559aa29}{resizing\+\_\+policy}} const \&resizing\+Policy)
\begin{DoxyCompactList}\small\item\em Ctor with resizing policy (copy semantics) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a3e1c130844fc77ceda65e8822f20b478}{Striped\+Set}} (size\+\_\+t n\+Capacity, \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a3c8cacda66c49872225f89568559aa29}{resizing\+\_\+policy}} \&\&resizing\+Policy)
\begin{DoxyCompactList}\small\item\em Ctor with resizing policy (move semantics) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a723409ba0e656ba3bbd54d41356ec710}{\texorpdfstring{$\sim$}{\string~}\+Striped\+Set}} ()
\begin{DoxyCompactList}\small\item\em Destructor destroys internal data \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a9596e3aea5464a77437d6d8cdfc288f5}{insert}} (\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a999c16c7efc7a140c386cf8089d43f7b}{value\+\_\+type}} \&val)
\begin{DoxyCompactList}\small\item\em Inserts new node \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a4e8e96d52afa3d2c265c269af1a1ba3c}{insert}} (\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a999c16c7efc7a140c386cf8089d43f7b}{value\+\_\+type}} \&val, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em Inserts new node \end{DoxyCompactList}\item 
std\+::pair$<$ \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} $>$ \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_ac4bb544e5a5053bf54d1b145e0be2057}{update}} (\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a999c16c7efc7a140c386cf8089d43f7b}{value\+\_\+type}} \&val, Func \mbox{\hyperlink{structfunc}{func}}, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} b\+Allow\+Insert=\mbox{\hyperlink{yyjson_8h_a41f9c5fb8b08eb5dc3edce4dcb37fee7}{true}})
\begin{DoxyCompactList}\small\item\em Updates the node \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_adbc4dd64160d03646b1f7c163f95369e}{unlink}} (\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a999c16c7efc7a140c386cf8089d43f7b}{value\+\_\+type}} \&val)
\begin{DoxyCompactList}\small\item\em Unlink the item {\ttfamily val} from the set \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a999c16c7efc7a140c386cf8089d43f7b}{value\+\_\+type}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_abfd7128735b9282d6f830f81232c77f5}{erase}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&val)
\begin{DoxyCompactList}\small\item\em Deletes the item from the set \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a999c16c7efc7a140c386cf8089d43f7b}{value\+\_\+type}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a57ff92590e106996553af1ba9424048f}{erase}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&val, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em Deletes the item from the set \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a999c16c7efc7a140c386cf8089d43f7b}{value\+\_\+type}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a9dc892d90499638ee0cf14ecccfc1723}{erase\+\_\+with}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&val, Less pred)
\begin{DoxyCompactList}\small\item\em Deletes the item from the set using {\ttfamily pred} predicate for searching \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a999c16c7efc7a140c386cf8089d43f7b}{value\+\_\+type}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a8b1642d21a2abdef18258539bf7e1fdc}{erase\+\_\+with}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&val, Less pred, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em Deletes the item from the set using {\ttfamily pred} predicate for searching \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_af54fb6ea73d499f07611f75973244685}{find}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} \&val, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em \doxylink{struct_find}{Find} the key {\ttfamily val} \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a1d1c82507b338a1f5e835117652f48d2}{find}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&val, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em \doxylink{struct_find}{Find} the key {\ttfamily val} \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_af47d38de7746c0701b794c02d7cc79bd}{find\+\_\+with}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} \&val, Less pred, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em \doxylink{struct_find}{Find} the key {\ttfamily val} using {\ttfamily pred} predicate \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a4947957c41d99bd6d75ce5b04a975bf5}{find\+\_\+with}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&val, Less pred, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em \doxylink{struct_find}{Find} the key {\ttfamily val} using {\ttfamily pred} predicate \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a5e681eacb6163d341cacf39607e1471c}{contains}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}})
\begin{DoxyCompactList}\small\item\em Checks whether the set contains {\ttfamily key} \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_aeec51f0495dce5375e33dbdad5129488}{contains}} (\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Less pred)
\begin{DoxyCompactList}\small\item\em Checks whether the set contains {\ttfamily key} using {\ttfamily pred} predicate for searching \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a8c5b7ec995eb6c9ab0de511b4848c356}{clear}} ()
\begin{DoxyCompactList}\small\item\em Clears the set \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a922615dc212b034f6946253747c92567}{clear\+\_\+and\+\_\+dispose}} (Disposer disposer)
\begin{DoxyCompactList}\small\item\em Clears the set and calls {\ttfamily disposer} for each item \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_aed8b6d36e50fd1acd07479381a33742c}{empty}} () const
\begin{DoxyCompactList}\small\item\em Checks if the set is empty \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a49c092c8ee3f7068d59f5f1aed4321a9}{size}} () const
\begin{DoxyCompactList}\small\item\em Returns item count in the set \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_ab98e2fa3c84dc5f9b370970ce16ba3fe}{bucket\+\_\+count}} () const
\begin{DoxyCompactList}\small\item\em Returns the size of hash table \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a60bc8a0b0ff0c96f164d83dcf2e9bbe0}{lock\+\_\+count}} () const
\begin{DoxyCompactList}\small\item\em Returns lock array size \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a3c8cacda66c49872225f89568559aa29}{resizing\+\_\+policy}} \& \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a406fe935c8ea68d5af3f7502e9435624}{get\+\_\+resizing\+\_\+policy}} ()
\begin{DoxyCompactList}\small\item\em Returns resizing policy object \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a3c8cacda66c49872225f89568559aa29}{resizing\+\_\+policy}} const \& \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a8cc7f1e8c66478d0fc7972d27ab1bb4b}{get\+\_\+resizing\+\_\+policy}} () const
\begin{DoxyCompactList}\small\item\em Returns resizing policy (const version) \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected 属性 继承自 \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set}{cds\+::intrusive\+::\+Striped\+Set$<$ Container, Options... $>$}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a64586b7a2b21c90196c2116ef594ec04}{bucket\+\_\+type}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_aa37baad9eed29bf24f0ddf890e0d01e8}{m\+\_\+\+Buckets}}
\begin{DoxyCompactList}\small\item\em Bucket table \end{DoxyCompactList}\item 
atomics\+::atomic$<$ size\+\_\+t $>$ \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a2dafe2df57e9f2b43293ea825982b473}{m\+\_\+n\+Bucket\+Mask}}
\begin{DoxyCompactList}\small\item\em Bucket table size -\/ 1. m\+\_\+n\+Bucket\+Mask + 1 should be power of two. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_abc27916ad8566742257adde4f5b0d36c}{item\+\_\+counter}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a1657b63e8f07fd22c313304f2d3ca0c5}{m\+\_\+\+Item\+Counter}}
\begin{DoxyCompactList}\small\item\em Item counter \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a3b11af7149d2edcdcf89875dd82f29c3}{hash}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a13b44bfb69b63d39d2a966b416736716}{m\+\_\+\+Hash}}
\begin{DoxyCompactList}\small\item\em \doxylink{struct_hash}{Hash} functor \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_af672d590a91e09833aa27621f7e35c26}{mutex\+\_\+policy}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a104ff1225ca65268f90dd235698e6f36}{m\+\_\+\+Mutex\+Policy}}
\begin{DoxyCompactList}\small\item\em Mutex policy \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_a3c8cacda66c49872225f89568559aa29}{resizing\+\_\+policy}} \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_ab6a40adaba75040b3646fab1ad4bc133}{m\+\_\+\+Resizing\+Policy}}
\begin{DoxyCompactList}\small\item\em Resizing policy \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{静态 Protected 属性 继承自 \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set}{cds\+::intrusive\+::\+Striped\+Set$<$ Container, Options... $>$}}}
\begin{DoxyCompactItemize}
\item 
static const size\+\_\+t \mbox{\hyperlink{classcds_1_1intrusive_1_1_striped_set_acd3aab8a3065331de1f6ad410fa94d7f}{c\+\_\+n\+Minimal\+Capacity}}
\begin{DoxyCompactList}\small\item\em \doxylink{class_minimal}{Minimal} capacity \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}
\subsubsection*{template$<$class Container, typename... Options$>$\newline
class cds\+::container\+::\+Striped\+Set$<$ Container, Options $>$}
Striped hash set 

Source
\begin{DoxyItemize}
\item \mbox{[}2008\mbox{]} Maurice Herlihy, Nir Shavit "{}\+The Art of Multiprocessor Programming"{}
\end{DoxyItemize}

Lock striping is very simple technique. The set consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When set is resized, bucket table capacity will be doubled but lock array will not. The lock {\ttfamily i} protects each bucket {\ttfamily j}, where {\ttfamily  j = i mod L }, where {\ttfamily L} -\/ the size of lock array.

Template arguments\+:
\begin{DoxyItemize}
\item {\ttfamily Container} -\/ the container class that is used as bucket table entry. The {\ttfamily Container} class should support an uniform interface described below.
\item {\ttfamily Options} -\/ options
\end{DoxyItemize}

The {\ttfamily Striped\+Set} class does not exactly dictate the type of container that should be used as a {\ttfamily Container} bucket. Instead, the class supports different container type for the bucket, for exampe, {\ttfamily std\+::list}, {\ttfamily std\+::set} and others.

Remember that {\ttfamily Striped\+Set} class algorithm ensures sequential blocking access to its bucket through the mutex type you specify among {\ttfamily Options} template arguments.

The {\ttfamily Options} are\+:
\begin{DoxyItemize}
\item {\ttfamily \doxylink{structcds_1_1opt_1_1mutex__policy}{opt\+::mutex\+\_\+policy}} -\/ concurrent access policy. Available policies\+: {\ttfamily \doxylink{classcds_1_1intrusive_1_1striped__set_1_1striping}{intrusive\+::striped\+\_\+set\+::striping}}, {\ttfamily \doxylink{classcds_1_1intrusive_1_1striped__set_1_1refinable}{intrusive\+::striped\+\_\+set\+::refinable}}. Default is {\ttfamily striped\+\_\+set\+::striping}.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1hash}{opt\+::hash}} -\/ hash functor. Default option value see {\ttfamily opt\+::v\+::hash\+\_\+selector$<$opt\+::none$>$ } which selects default hash functor for your compiler.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1compare}{opt\+::compare}} -\/ key comparison functor. No default functor is provided. If the option is not specified, the {\ttfamily opt\+::less} is used.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1less}{opt\+::less}} -\/ specifies binary predicate used for key comparison. Default is {\ttfamily std\+::less$<$\+T$>$}.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1item__counter}{opt\+::item\+\_\+counter}} -\/ item counter type. Default is {\ttfamily \doxylink{classcds_1_1atomicity_1_1item__counter}{atomicity\+::item\+\_\+counter}} since some operation on the counter is performed without locks. Note that item counting is an essential part of the set algorithm, so dummy counter like as {\ttfamily \doxylink{classcds_1_1atomicity_1_1empty__item__counter}{atomicity\+::empty\+\_\+item\+\_\+counter}} is not suitable.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1allocator}{opt\+::allocator}} -\/ the allocator type using for memory allocation of bucket table and lock array. Default is \doxylink{external_2libcds_2cds_2user__setup_2allocator_8h_ad5fb7e3cbe8cf24295f0ea3c165a2d82}{CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR}.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1resizing__policy}{opt\+::resizing\+\_\+policy}} -\/ the resizing policy that is a functor that decides when to resize the hash set. Default option value depends on bucket container type\+: for sequential containers like {\ttfamily std\+::list}, {\ttfamily std\+::vector} the resizing policy is {\ttfamily \doxylink{namespacecds_1_1container_1_1striped__set_a2934a868ebde410fca08353b1da5973e}{striped\+\_\+set\+::load\+\_\+factor\+\_\+resizing$<$4$>$} }; for other type of containers like {\ttfamily std\+::set}, {\ttfamily std\+::unordered\+\_\+set} the resizing policy is {\ttfamily \doxylink{namespacecds_1_1container_1_1striped__set_a1a6926eacdbf9fb4fc264d6d85d353c2}{striped\+\_\+set\+::no\+\_\+resizing}}. See \doxylink{group__cds__striped__resizing__policy}{available resizing policy}. Note that the choose of resizing policy depends of {\ttfamily Container} type\+: for sequential containers like {\ttfamily std\+::list}, {\ttfamily std\+::vector} and so on, right choosing of the policy can significantly improve performance. For other, non-\/sequential types of {\ttfamily Container} (like a {\ttfamily std\+::set}) the resizing policy is not so important.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1copy__policy}{opt\+::copy\+\_\+policy}} -\/ the copy policy which is used to copy items from the old set to the new one when resizing. The policy can be optionally used in adapted bucket container for performance reasons of resizing. The detail of copy algorithm depends on type of bucket container and explains below.
\end{DoxyItemize}

{\ttfamily opt\+::compare} or {\ttfamily opt\+::less} options are used in some {\ttfamily Container} class for searching an item. {\ttfamily opt\+::compare} option has the highest priority\+: if {\ttfamily opt\+::compare} is specified, {\ttfamily opt\+::less} is not used.

You can pass other option that would be passed to {\ttfamily adapt} metafunction, see below.

{\bfseries{Internal details}} \begin{DoxyVerb}The \p %StripedSet class cannot utilize the \p Container container specified directly, but only its adapted variant which
supports an unified interface. Internally, the adaptation is made via striped_set::adapt metafunction that wraps bucket container
and provides the unified bucket interface suitable for \p %StripedSet. Such adaptation is completely transparent for you -
you don't need to call \p adapt metafunction directly, \p %StripedSet class's internal machinery itself invokes appropriate
\p adapt metafunction to adjust your \p Container container class to \p %StripedSet bucket's internal interface.
All you need is to include a right header before <tt>striped_hash_set.h</tt>.

By default, <tt>striped_set::adapt<AnyContainer, Options...> </tt> metafunction does not make any wrapping to \p AnyContainer,
so, the result <tt>striped_set::adapt<AnyContainer, Options...>::type </tt> is the same as \p AnyContainer.
However, there are a lot of specializations of <tt>striped_set::adapt</tt> for well-known containers, see table below.
Any of this specialization wraps corresponding container making it suitable for the set's bucket.
Remember, you should include the proper header file for \p adapt <b>before</b> including <tt>striped_hash_set.h</tt>.
<table>
    <tr>
        <th>Container</th>
        <th>.h-file for \p adapt</th>
        <th>Example</th>
        <th>Notes</th>
    </tr>
    <tr>
        <td> \p std::list</td>
        <td><tt><cds/container/striped_set/std_list.h></tt></td>
        <td>\code
            #include <cds/container/striped_set/std_list.h>
            #include <cds/container/striped_hash_set.h>
            typedef cds::container::StripedSet<
                std::list<T>,
                cds::opt::less< std::less<T> >
            > striped_set;
        \endcode
        </td>
        <td>
            The list is ordered.
            Template argument pack \p Options <b>must</b> contain cds::opt::less or cds::opt::compare for type \p T stored in the list
        </td>
    </tr>
    <tr>
        <td> \p std::vector</td>
        <td><tt><cds/container/striped_set/std_vector.h></tt></td>
        <td>\code
            #include <cds/container/striped_set/std_vector.h>
            #include <cds/container/striped_hash_set.h>
            typedef cds::container::StripedSet<
                std::vector<T>,
                cds::opt::less< std::less<T> >
            > striped_set;
        \endcode
        </td>
        <td>
            The vector is ordered.
            Template argument pack \p Options <b>must</b> contain \p cds::opt::less or \p cds::opt::compare for type \p T stored in the list
        </td>
    </tr>
    <tr>
        <td> \p std::set</td>
        <td><tt><cds/container/striped_set/std_set.h></tt></td>
        <td>\code
            #include <cds/container/striped_set/std_set.h>
            #include <cds/container/striped_hash_set.h>
            typedef cds::container::StripedSet<
                std::set< T, std::less<T> >
            > striped_set;
        \endcode
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td> \p std::unordered_set</td>
        <td><tt><cds/container/striped_set/std_hash_set.h></tt></td>
        <td>\code
            #include <cds/container/striped_set/std_hash_set.h>
            #include <cds/container/striped_hash_set.h>
            typedef cds::container::StripedSet<
                std::unordered_set<
                    T,
                    hash<T>,
                    equal<T>
                >
            > striped_set;
        \endcode
        </td>
        <td>
            You should provide two different hash function \p h1 and \p h2 - one for \p std::unordered_set and other for \p %StripedSet.
            For the best result, \p h1 and \p h2 must be orthogonal i.e. <tt> h1(X) != h2(X) </tt> for any value \p X.
        </td>
    </tr>
    <tr>
        <td> \p boost::container::slist</td>
        <td><tt><cds/container/striped_set/boost_slist.h></tt></td>
        <td>\code
            #include <cds/container/striped_set/boost_slist.h>
            #include <cds/container/striped_hash_set.h>
            typedef cds::container::StripedSet<
                boost::container::slist<T>
            > striped_set;
        \endcode
        </td>
        <td>
            The list is ordered.
            \p Options <b>must</b> contain \p cds::opt::less or \p cds::opt::compare.
        </td>
    </tr>
    <tr>
        <td> \p boost::container::list</td>
        <td><tt><cds/container/striped_set/boost_list.h></tt></td>
        <td>\code
            #include <cds/container/striped_set/boost_list.h>
            #include <cds/container/striped_hash_set.h>
            typedef cds::container::StripedSet<
                boost::container::list<T>
            > striped_set;
        \endcode
        </td>
        <td>
            The list is ordered.
            \p Options <b>must</b> contain \p cds::opt::less or \p cds::opt::compare.
        </td>
    </tr>
    <tr>
        <td> \p boost::container::vector</td>
        <td><tt><cds/container/striped_set/boost_vector.h></tt></td>
        <td>\code
            #include <cds/container/striped_set/boost_vector.h>
            #include <cds/container/striped_hash_set.h>
            typedef cds::container::StripedSet<
                boost::container::vector<T>,
                cds::opt::less< std::less<T> >
            > striped_set;
        \endcode
        </td>
        <td>
            The vector is ordered.
            Template argument pack \p Options <b>must</b> contain \p cds::opt::less or \p cds::opt::compare for type \p T stored in the vector
        </td>
    </tr>
    <tr>
        <td> \p boost::container::stable_vector</td>
        <td><tt><cds/container/striped_set/boost_stable_vector.h></tt></td>
        <td>\code
            #include <cds/container/striped_set/boost_stable_vector.h>
            #include <cds/container/striped_hash_set.h>
            typedef cds::container::StripedSet<
                boost::container::stable_vector<T>,
                cds::opt::less< std::less<T> >
            > striped_set;
        \endcode
        </td>
        <td>
            The vector is ordered.
            Template argument pack \p Options <b>must</b> contain \p cds::opt::less or \p cds::opt::compare for type \p T stored in the vector
        </td>
    </tr>
    <tr>
        <td> \p boost::container::set</td>
        <td><tt><cds/container/striped_set/boost_set.h></tt></td>
        <td>\code
            #include <cds/container/striped_set/boost_set.h>
            #include <cds/container/striped_hash_set.h>
            typedef cds::container::StripedSet<
                boost::container::set< T, std::less<T> >
            > striped_set;
        \endcode
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td> \p boost::container::flat_set</td>
        <td><tt><cds/container/striped_set/boost_flat_set.h></tt></td>
        <td>\code
            #include <cds/container/striped_set/boost_flat_set.h>
            #include <cds/container/striped_hash_set.h>
            typedef cds::container::StripedSet<
                boost::container::flat_set< T, std::less<T> >
            > striped_set;
        \endcode
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td> \p boost::unordered_set</td>
        <td><tt><cds/container/striped_set/boost_unordered_set.h></tt></td>
        <td>\code
            #include <cds/container/striped_set/boost_unordered_set.h>
            #include <cds/container/striped_hash_set.h>
            typedef cds::container::StripedSet<
                boost::unordered_set<
                    T,
                    hash<T>,
                    equal<T>
                >
            > striped_set;
        \endcode
        </td>
        <td>
            You should provide two different hash function \p h1 and \p h2 - one for \p boost::unordered_set and other for \p %StripedSet.
            For the best result, \p h1 and \p h2 must be orthogonal i.e. <tt> h1(X) != h2(X) </tt> for any value \p X.
        </td>
    </tr>
</table>

You can use another container type as set's bucket.
Suppose, you have a container class \p MyBestContainer and you want to integrate it with \p %StripedSet as bucket type.
There are two possibility:
- either your \p MyBestContainer class has native support of bucket's interface;
    in this case, you can use default <tt>striped_set::adapt</tt> metafunction;
- or your \p MyBestContainer class does not support bucket's interface, which means, that you should develop a specialization
    <tt>cds::container::striped_set::adapt<MyBestContainer> </tt> metafunction providing necessary interface.

The <tt>striped_set::adapt< Container, Options... ></tt> metafunction has two template argument:
- \p Container is the class that should be used as the bucket, for example, <tt>std::list< T ></tt>.
- \p Options pack is the options from \p %StripedSet declaration. The \p adapt metafunction can use
    any option from \p Options for its internal use. For example, a \p compare option can be passed to \p adapt
    metafunction via \p Options argument of \p %StripedSet declaration.

See striped_set::adapt metafunction for the description of interface that the bucket container must provide
to be %StripedSet compatible.
\end{DoxyVerb}


{\bfseries{Copy policy}} There are three predefined copy policy\+:
\begin{DoxyItemize}
\item {\ttfamily cds\+::container\+::striped\+\_\+set\+::copy\+\_\+item} -\/ copy item from old bucket to new one when resizing using copy ctor. It is default policy for any compiler that do not support move semantics
\item {\ttfamily cds\+::container\+::striped\+\_\+set\+::move\+\_\+item} -\/ move item from old bucket to new one when resizing using move semantics. It is default policy for any compiler that support move semantics. If compiler does not support move semantics, the move policy is the same as {\ttfamily copy\+\_\+item} 
\item {\ttfamily cds\+::container\+::striped\+\_\+set\+::swap\+\_\+item} -\/ copy item from old bucket to new one when resizing using {\ttfamily \doxylink{namespacestd_a3acbe51b6415e9284430194bf04944e1}{std\+::swap}}. Not all containers support this copy policy, see details in table below.
\end{DoxyItemize}

You can define your own copy policy specifically for your case. Note, right copy policy can significantly improve the performance of resizing.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Container }&\cellcolor{\tableheadbgcolor}\textbf{ Policies  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Container }&\cellcolor{\tableheadbgcolor}\textbf{ Policies  }\\\cline{1-2}
\endhead

\begin{DoxyItemize}
\item {\ttfamily std\+::list} 
\item {\ttfamily std\+::vector} 
\item {\ttfamily boost\+::list} 
\item {\ttfamily boost\+::vector} 
\item {\ttfamily boost\+::stable\+\_\+vector} 
\end{DoxyItemize}&
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }copy\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ std::list<T>\&\ list,\ std::list<T>::iterator\ itInsert,\ std::list<T>::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert(\ itInsert,\ *itWhat\ );}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ The\ type\ T\ stored\ in\ the\ list\ must\ be\ swappable}}
\DoxyCodeLine{\textcolor{keyword}{struct\ }swap\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ std::list<T>\&\ list,\ std::list<T>::iterator\ itInsert,\ std::list<T>::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacestd_a3acbe51b6415e9284430194bf04944e1}{std::swap}}(\ *\mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert(\ itInsert,\ \mbox{\hyperlink{test__overwrite__node_8cpp_a0acb682b8260ab1c60b918599864e2e5}{T}}()),\ *itWhat\ );}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }move\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ std::list<T>\&\ list,\ std::list<T>::iterator\ itInsert,\ std::list<T>::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert(\ itInsert,\ std::move(\ *itWhat\ ));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}
   \\\cline{1-2}

\begin{DoxyItemize}
\item {\ttfamily std\+::set} 
\item {\ttfamily std\+::unordered\+\_\+set} 
\end{DoxyItemize}&
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }copy\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ std::set<T>\&\ set,\ std::set<T>::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_a5e9b11b642840f2cea7babc61d33bf4f}{set}}.\mbox{\hyperlink{classeastl_1_1rbtree_a3f12d5cb550b4d4d63645bea5ac9a682}{insert}}(\ *itWhat\ );}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}
 {\ttfamily swap\+\_\+item} is not applicable (same as {\ttfamily copy\+\_\+item})


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }move\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ std::set<T>\&\ set,\ std::set<T>::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_a5e9b11b642840f2cea7babc61d33bf4f}{set}}.\mbox{\hyperlink{classeastl_1_1rbtree_a3f12d5cb550b4d4d63645bea5ac9a682}{insert}}(\ std::move(\ *itWhat\ ));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}
  \\\cline{1-2}

\begin{DoxyItemize}
\item {\ttfamily boost\+::container\+::slist} 
\end{DoxyItemize}&
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }copy\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ bc::slist<T>\&\ list,\ bc::slist<T>::iterator\ itInsert,\ bc::slist<T>::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert\_after(\ itInsert,\ *itWhat\ );}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ The\ type\ T\ stored\ in\ the\ list\ must\ be\ swappable}}
\DoxyCodeLine{\textcolor{keyword}{struct\ }swap\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ bc::slist<T>\&\ list,\ bc::slist<T>::iterator\ itInsert,\ bc::slist<T>::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacestd_a3acbe51b6415e9284430194bf04944e1}{std::swap}}(\ *\mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert\_after(\ itInsert,\ \mbox{\hyperlink{test__overwrite__node_8cpp_a0acb682b8260ab1c60b918599864e2e5}{T}}()),\ *itWhat\ );}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }move\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ bc::slist<T>\&\ list,\ bc::slist<T>::iterator\ itInsert,\ bc::slist<T>::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert\_after(\ itInsert,\ std::move(\ *itWhat\ ));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}
   \\\cline{1-2}
\end{longtabu}


{\bfseries{Advanced functions}} \begin{DoxyVerb}<b>libcds</b> provides some advanced functions like \p erase_with(), \p find_with(),
that cannot be supported by all underlying containers.
The table below shows whether underlying container supports those functions
(the sign "+" means "container supports the function"):

<table>
    <tr>
        <th>Container</th>
        <th>\p find_with</th>
        <th>\p erse_with</th>
    </tr>
    <tr>
        <td> \p std::list</td>
        <td>+</td>
        <td>+</td>
    </tr>
    <tr>
        <td> \p std::vector</td>
        <td>+</td>
        <td>+</td>
    </tr>
    <tr>
        <td> \p std::set</td>
        <td>-</td>
        <td>-</td>
    </tr>
    <tr>
        <td> \p std::unordered_set</td>
        <td>-</td>
        <td>-</td>
    </tr>
    <tr>
        <td> \p boost::container::slist</td>
        <td>+</td>
        <td>+</td>
    </tr>
    <tr>
        <td> \p boost::container::list</td>
        <td>+</td>
        <td>+</td>
    </tr>
    <tr>
        <td> \p boost::container::vector</td>
        <td>+</td>
        <td>+</td>
    </tr>
    <tr>
        <td> \p boost::container::stable_vector</td>
        <td>+</td>
        <td>+</td>
    </tr>
    <tr>
        <td> \p boost::container::set</td>
        <td>-</td>
        <td>-</td>
    </tr>
    <tr>
        <td> \p boost::container::flat_set</td>
        <td>-</td>
        <td>-</td>
    </tr>
    <tr>
        <td> \p boost::unordered_set</td>
        <td>-</td>
        <td>-</td>
    </tr>
</table>
\end{DoxyVerb}
 

\doxysubsection{成员类型定义说明}
\Hypertarget{classcds_1_1container_1_1_striped_set_ae456575fca3f9634a4cbc25504d01a2a}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!allocator\_type@{allocator\_type}}
\index{allocator\_type@{allocator\_type}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{allocator\_type}{allocator\_type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_ae456575fca3f9634a4cbc25504d01a2a} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::allocator\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::allocator\+\_\+type}



allocator type specified in options. 

\Hypertarget{classcds_1_1container_1_1_striped_set_acd05847a606289e2125e22c390836e2d}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!bucket\_type@{bucket\_type}}
\index{bucket\_type@{bucket\_type}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{bucket\_type}{bucket\_type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_acd05847a606289e2125e22c390836e2d} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::bucket\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::bucket\+\_\+type}



container type adapted for hash set 

\Hypertarget{classcds_1_1container_1_1_striped_set_ab3b1488d09e53e4fdadf2581db30b311}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!hash@{hash}}
\index{hash@{hash}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{hash}{hash}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_ab3b1488d09e53e4fdadf2581db30b311} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::hash \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\mbox{\hyperlink{structhash}{\+::hash}}}



\doxylink{struct_hash}{Hash} functor 

\Hypertarget{classcds_1_1container_1_1_striped_set_aff8e128e84f4a17ae60a837867556050}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!item\_counter@{item\_counter}}
\index{item\_counter@{item\_counter}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{item\_counter}{item\_counter}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_aff8e128e84f4a17ae60a837867556050} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::item\+\_\+counter \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::item\+\_\+counter}



Item counter 

\Hypertarget{classcds_1_1container_1_1_striped_set_a52867de81f8ae19c2bc1d261694470ec}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!mutex\_policy@{mutex\_policy}}
\index{mutex\_policy@{mutex\_policy}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{mutex\_policy}{mutex\_policy}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a52867de81f8ae19c2bc1d261694470ec} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::mutex\+\_\+policy \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::mutex\+\_\+policy}



Mutex policy 

\Hypertarget{classcds_1_1container_1_1_striped_set_a132347759ae9e7929c5dc75a53890687}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!resizing\_policy@{resizing\_policy}}
\index{resizing\_policy@{resizing\_policy}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{resizing\_policy}{resizing\_policy}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a132347759ae9e7929c5dc75a53890687} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::resizing\+\_\+policy \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::resizing\+\_\+policy}



Resizing policy 

\Hypertarget{classcds_1_1container_1_1_striped_set_ab78f765a66999a851520edd05688f688}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!underlying\_container\_type@{underlying\_container\_type}}
\index{underlying\_container\_type@{underlying\_container\_type}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{underlying\_container\_type}{underlying\_container\_type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_ab78f765a66999a851520edd05688f688} 
template$<$class Container, typename... Options$>$ \\
typedef Container \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::underlying\+\_\+container\+\_\+type}



original intrusive container type for the bucket 

\Hypertarget{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!value\_type@{value\_type}}
\index{value\_type@{value\_type}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{value\_type}{value\_type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189} 
template$<$class Container, typename... Options$>$ \\
typedef bucket\+\_\+type\+::value\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::value\+\_\+type}



value type stored in the set 



\doxysubsection{构造及析构函数说明}
\Hypertarget{classcds_1_1container_1_1_striped_set_a5b62b8c4af0730a78837e3c8a29994c2}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!StripedSet@{StripedSet}}
\index{StripedSet@{StripedSet}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{StripedSet()}{StripedSet()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a5b62b8c4af0730a78837e3c8a29994c2} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::\+Striped\+Set (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Default ctor. The initial capacity is 16. 

\Hypertarget{classcds_1_1container_1_1_striped_set_a319c779ca7127d5fc03ade9a521a0338}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!StripedSet@{StripedSet}}
\index{StripedSet@{StripedSet}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{StripedSet()}{StripedSet()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a319c779ca7127d5fc03ade9a521a0338} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::\+Striped\+Set (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n\+Capacity}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Ctor with initial capacity specified 


\begin{DoxyParams}{参数}
{\em n\+Capacity} & Initial size of bucket table and lock array. Must be power of two, the minimum is 16. \\
\hline
\end{DoxyParams}
\Hypertarget{classcds_1_1container_1_1_striped_set_a481f34c5eb75bfb09aa7eca7f91c6e13}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!StripedSet@{StripedSet}}
\index{StripedSet@{StripedSet}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{StripedSet()}{StripedSet()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a481f34c5eb75bfb09aa7eca7f91c6e13} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::\+Striped\+Set (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n\+Capacity}{, }\item[{\mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a132347759ae9e7929c5dc75a53890687}{resizing\+\_\+policy}} const \&}]{resizing\+Policy}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Ctor with resizing policy (copy semantics) 

This constructor initializes m\+\_\+\+Resizing\+Policy member with copy of {\ttfamily resizing\+Policy} parameter 
\begin{DoxyParams}{参数}
{\em n\+Capacity} & Initial size of bucket table and lock array. Must be power of two, the minimum is 16.  \\
\hline
{\em resizing\+Policy} & Resizing policy \\
\hline
\end{DoxyParams}
\Hypertarget{classcds_1_1container_1_1_striped_set_a0a2289fff041c278598a6fe5e447ceb7}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!StripedSet@{StripedSet}}
\index{StripedSet@{StripedSet}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{StripedSet()}{StripedSet()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a0a2289fff041c278598a6fe5e447ceb7} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::\+Striped\+Set (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n\+Capacity}{, }\item[{\mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a132347759ae9e7929c5dc75a53890687}{resizing\+\_\+policy}} \&\&}]{resizing\+Policy}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Ctor with resizing policy (move semantics) 

This constructor initializes m\+\_\+\+Resizing\+Policy member moving {\ttfamily resizing\+Policy} parameter Move semantics is used. Available only for the compilers that supports C++11 rvalue reference. 
\begin{DoxyParams}{参数}
{\em n\+Capacity} & Initial size of bucket table and lock array. Must be power of two, the minimum is 16.  \\
\hline
{\em resizing\+Policy} & Resizing policy \\
\hline
\end{DoxyParams}
\Hypertarget{classcds_1_1container_1_1_striped_set_a0eee4ba35c6a33a03d12ad436cefc832}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!````~StripedSet@{\texorpdfstring{$\sim$}{\string~}StripedSet}}
\index{````~StripedSet@{\texorpdfstring{$\sim$}{\string~}StripedSet}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{\texorpdfstring{$\sim$}{\string~}StripedSet()}{\string~StripedSet()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a0eee4ba35c6a33a03d12ad436cefc832} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::\texorpdfstring{$\sim$}{\string~}\mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{Striped\+Set}} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Destructor destroys internal data 



\doxysubsection{成员函数说明}
\Hypertarget{classcds_1_1container_1_1_striped_set_a4e88c75874196bc4a034da5a5ac2806c}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!bucket\_count@{bucket\_count}}
\index{bucket\_count@{bucket\_count}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{bucket\_count()}{bucket\_count()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a4e88c75874196bc4a034da5a5ac2806c} 
template$<$class Container, typename... Options$>$ \\
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::bucket\+\_\+count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the size of hash table 

The hash table size is non-\/constant and can be increased via resizing. \Hypertarget{classcds_1_1container_1_1_striped_set_a4bdfcbca5e48b3d517b9e450a06e9be1}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!clear@{clear}}
\index{clear@{clear}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a4bdfcbca5e48b3d517b9e450a06e9be1} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::clear (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Clears the set 

The function erases all items from the set. \Hypertarget{classcds_1_1container_1_1_striped_set_aa0dfbf9bd83bc92c1d7611532811c523}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!contains@{contains}}
\index{contains@{contains}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_aa0dfbf9bd83bc92c1d7611532811c523} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::contains (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&}]{key}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Checks whether the set contains {\ttfamily key} 

The function searches the item with key equal to {\ttfamily key} and returns {\ttfamily true} if it is found, and {\ttfamily false} otherwise.

Note the hash functor specified for class {\ttfamily Traits} template parameter should accept a parameter of type {\ttfamily Q} that can be not the same as {\ttfamily \doxylink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\+\_\+type}}. Otherwise, you may use {\ttfamily \doxylink{classcds_1_1container_1_1_striped_set_a4581ada4d40d30156be2138d96209008}{contains( Q const\&, Less pred )}} functions with explicit predicate for key comparing. \Hypertarget{classcds_1_1container_1_1_striped_set_a4581ada4d40d30156be2138d96209008}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!contains@{contains}}
\index{contains@{contains}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a4581ada4d40d30156be2138d96209008} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Less, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+find\+\_\+with $>$\+::type$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::contains (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&}]{key}{, }\item[{Less}]{pred}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Checks whether the map contains {\ttfamily key} using {\ttfamily pred} predicate for searching 

The function is similar to {\ttfamily contains( key )} but {\ttfamily pred} is used for key comparing. {\ttfamily Less} functor has the interface like {\ttfamily std\+::less}. {\ttfamily Less} must imply the same element order as the comparator used for building the map. \Hypertarget{classcds_1_1container_1_1_striped_set_a7ad9d39e24e0e1104be28f212e22fedc}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!emplace@{emplace}}
\index{emplace@{emplace}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{emplace()}{emplace()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a7ad9d39e24e0e1104be28f212e22fedc} 
template$<$class Container, typename... Options$>$ \\
template$<$typename... Args$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::emplace (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts data of type {\ttfamily value\+\_\+type} constructed with {\ttfamily std\+::forward$<$\+Args$>$(args)...} 

Returns {\ttfamily true} if inserting successful, {\ttfamily false} otherwise. \Hypertarget{classcds_1_1container_1_1_striped_set_a1e30b916dabbf37f56dd07915e5102f2}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!empty@{empty}}
\index{empty@{empty}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a1e30b916dabbf37f56dd07915e5102f2} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::empty (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Checks if the set is empty 

Emptiness is checked by item counting\+: if item count is zero then the set is empty. \Hypertarget{classcds_1_1container_1_1_striped_set_ad89f2115ab187e2105c91dd933cb82d7}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!erase@{erase}}
\index{erase@{erase}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_ad89f2115ab187e2105c91dd933cb82d7} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&}]{key}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Delete {\ttfamily key} from the set 

\label{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_erase}%
\Hypertarget{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_erase}%
 The set item comparator should be able to compare the type {\ttfamily \doxylink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\+\_\+type}} and the type {\ttfamily Q}. Return {\ttfamily true} if key is found and deleted, {\ttfamily false} otherwise \Hypertarget{classcds_1_1container_1_1_striped_set_a0c3e75924c53c72d92082b484975af7a}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!erase@{erase}}
\index{erase@{erase}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a0c3e75924c53c72d92082b484975af7a} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Func$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::erase (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&}]{key}{, }\item[{Func}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Delete {\ttfamily key} from the set 

\label{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_erase_func}%
\Hypertarget{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_erase_func}%
 The function searches an item with key {\ttfamily key}, calls {\ttfamily f} functor with item found and deletes it. If {\ttfamily key} is not found, the functor is not called.

The functor {\ttfamily Func} interface is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }functor\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(value\_type\ \textcolor{keyword}{const}\&\ val);}
\DoxyCodeLine{\};}

\end{DoxyCode}


Return {\ttfamily true} if key is found and deleted, {\ttfamily false} otherwise \Hypertarget{classcds_1_1container_1_1_striped_set_a93bbd4712424855500108292e10935f7}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!erase\_with@{erase\_with}}
\index{erase\_with@{erase\_with}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{erase\_with()}{erase\_with()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a93bbd4712424855500108292e10935f7} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Less, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+erase\+\_\+with $>$\+::type$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::erase\+\_\+with (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&}]{key}{, }\item[{Less}]{pred}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deletes the item from the set using {\ttfamily pred} predicate for searching 

The function is an analog of \doxylink{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_erase}{erase(Q const\&)} but {\ttfamily pred} is used for key comparing. {\ttfamily Less} functor has the interface like {\ttfamily std\+::less}. {\ttfamily pred} must imply the same element order as the comparator used for building the set.

\begin{DoxyNote}{注解}
This function is enabled if the compiler supports C++11 default template arguments for function template {\bfseries{and}} the underlying container supports {\ttfamily erase\+\_\+with} feature. 
\end{DoxyNote}
\Hypertarget{classcds_1_1container_1_1_striped_set_af161c84a97d8357664c37720bdf77879}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!erase\_with@{erase\_with}}
\index{erase\_with@{erase\_with}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{erase\_with()}{erase\_with()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_af161c84a97d8357664c37720bdf77879} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Less, typename Func, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+erase\+\_\+with $>$\+::type$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::erase\+\_\+with (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&}]{key}{, }\item[{Less}]{pred}{, }\item[{Func}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deletes the item from the set using {\ttfamily pred} predicate for searching 

The function is an analog of \doxylink{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_erase_func}{erase(Q const\&, Func)} but {\ttfamily pred} is used for key comparing. {\ttfamily Less} functor has the interface like {\ttfamily std\+::less}. {\ttfamily pred} must imply the same element order as the comparator used for building the set.

\begin{DoxyNote}{注解}
This function is enabled if the compiler supports C++11 default template arguments for function template {\bfseries{and}} the underlying container supports {\ttfamily erase\+\_\+with} feature. 
\end{DoxyNote}
\Hypertarget{classcds_1_1container_1_1_striped_set_a203525441d38698012f814d8408f6d36}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!find@{find}}
\index{find@{find}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a203525441d38698012f814d8408f6d36} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Func$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::find (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} \&}]{val}{, }\item[{Func}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\doxylink{struct_find}{Find} the key {\ttfamily val} 

\label{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_find_func}%
\Hypertarget{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_find_func}%
 The function searches the item with key equal to {\ttfamily val} and calls the functor {\ttfamily f} for item found. The interface of {\ttfamily Func} functor is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }functor\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ value\_type\&\ item,\ \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}\&\ val\ );}
\DoxyCodeLine{\};}

\end{DoxyCode}
 where {\ttfamily item} is the item found, {\ttfamily val} is the {\ttfamily find} function argument.

The functor can change non-\/key fields of {\ttfamily item}. The {\ttfamily val} argument is non-\/const since it can be used as {\ttfamily f} functor destination i.\+e., the functor can modify both arguments.

The type {\ttfamily Q} can differ from {\ttfamily \doxylink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\+\_\+type}} of items storing in the container. Therefore, the {\ttfamily \doxylink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\+\_\+type}} should be comparable with type {\ttfamily Q}.

The function returns {\ttfamily true} if {\ttfamily val} is found, {\ttfamily false} otherwise. \Hypertarget{classcds_1_1container_1_1_striped_set_acb9099506c1034b3a5f437db5e73c1d0}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!find@{find}}
\index{find@{find}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_acb9099506c1034b3a5f437db5e73c1d0} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Func$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::find (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&}]{val}{, }\item[{Func}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\doxylink{struct_find}{Find} the key {\ttfamily val} 

\label{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_find_cfunc}%
\Hypertarget{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_find_cfunc}%
 The function searches the item with key equal to {\ttfamily val} and calls the functor {\ttfamily f} for item found. The interface of {\ttfamily Func} functor is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }functor\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ value\_type\&\ item,\ \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}\ \textcolor{keyword}{const}\&\ val\ );}
\DoxyCodeLine{\};}

\end{DoxyCode}
 where {\ttfamily item} is the item found, {\ttfamily val} is the {\ttfamily find} function argument.

The functor can change non-\/key fields of {\ttfamily item}.

The type {\ttfamily Q} can differ from {\ttfamily \doxylink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\+\_\+type}} of items storing in the container. Therefore, the {\ttfamily \doxylink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\+\_\+type}} should be comparable with type {\ttfamily Q}.

The function returns {\ttfamily true} if {\ttfamily val} is found, {\ttfamily false} otherwise. \Hypertarget{classcds_1_1container_1_1_striped_set_a7aaecb8e05cd335c57507c1a69ea3078}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!find\_with@{find\_with}}
\index{find\_with@{find\_with}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{find\_with()}{find\_with()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a7aaecb8e05cd335c57507c1a69ea3078} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Less, typename Func, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+find\+\_\+with $>$\+::type$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::find\+\_\+with (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} \&}]{val}{, }\item[{Less}]{pred}{, }\item[{Func}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\doxylink{struct_find}{Find} the key {\ttfamily val} using {\ttfamily pred} predicate 

The function is an analog of \doxylink{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_find_func}{find(Q\&, Func)} but {\ttfamily pred} is used for key comparing {\ttfamily Less} has the interface like {\ttfamily std\+::less}. {\ttfamily pred} must imply the same element order as the comparator used for building the set.

\begin{DoxyNote}{注解}
This function is enabled if the compiler supports C++11 default template arguments for function template {\bfseries{and}} the underlying container supports {\ttfamily find\+\_\+with} feature. 
\end{DoxyNote}
\Hypertarget{classcds_1_1container_1_1_striped_set_a6a062a1d56946e140c120856be09b04a}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!find\_with@{find\_with}}
\index{find\_with@{find\_with}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{find\_with()}{find\_with()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a6a062a1d56946e140c120856be09b04a} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Less, typename Func, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+find\+\_\+with $>$\+::type$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::find\+\_\+with (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&}]{val}{, }\item[{Less}]{pred}{, }\item[{Func}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\doxylink{struct_find}{Find} the key {\ttfamily val} using {\ttfamily pred} predicate 

The function is an analog of \doxylink{classcds_1_1container_1_1_striped_set_cds_nonintrusive_StripedSet_find_cfunc}{find(Q const\&, Func)} but {\ttfamily pred} is used for key comparing {\ttfamily Less} has the interface like {\ttfamily std\+::less}. {\ttfamily pred} must imply the same element order as the comparator used for building the set.

\begin{DoxyNote}{注解}
This function is enabled if the compiler supports C++11 default template arguments for function template {\bfseries{and}} the underlying container supports {\ttfamily find\+\_\+with} feature. 
\end{DoxyNote}
\Hypertarget{classcds_1_1container_1_1_striped_set_a9dd67e51632fa6661b0c242f6963b85d}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!get\_resizing\_policy@{get\_resizing\_policy}}
\index{get\_resizing\_policy@{get\_resizing\_policy}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{get\_resizing\_policy()}{get\_resizing\_policy()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a9dd67e51632fa6661b0c242f6963b85d} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a132347759ae9e7929c5dc75a53890687}{resizing\+\_\+policy}} \& \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::get\+\_\+resizing\+\_\+policy (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns resizing policy object 

\Hypertarget{classcds_1_1container_1_1_striped_set_a0e5a5482b98e8971be6bbbe242904ec5}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!get\_resizing\_policy@{get\_resizing\_policy}}
\index{get\_resizing\_policy@{get\_resizing\_policy}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{get\_resizing\_policy()}{get\_resizing\_policy()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a0e5a5482b98e8971be6bbbe242904ec5} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a132347759ae9e7929c5dc75a53890687}{resizing\+\_\+policy}} const  \& \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::get\+\_\+resizing\+\_\+policy (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns resizing policy (const version) 

\Hypertarget{classcds_1_1container_1_1_striped_set_aff8843b99b6f85ad37e9b4e4d920f523}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!insert@{insert}}
\index{insert@{insert}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_aff8843b99b6f85ad37e9b4e4d920f523} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&}]{val}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts new node 

The function creates a node with copy of {\ttfamily val} value and then inserts the node created into the set.

The type {\ttfamily Q} should contain as minimum the complete key for the node. The object of {\ttfamily \doxylink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\+\_\+type}} should be constructible from a value of type {\ttfamily Q}. In trivial case, {\ttfamily Q} is equal to {\ttfamily \doxylink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\+\_\+type}}.

Returns {\ttfamily true} if {\ttfamily val} is inserted into the set, {\ttfamily false} otherwise. \Hypertarget{classcds_1_1container_1_1_striped_set_a6516d09d6a558712c1827bf57bd65b53}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!insert@{insert}}
\index{insert@{insert}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a6516d09d6a558712c1827bf57bd65b53} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Func$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&}]{val}{, }\item[{Func}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts new node 

The function allows to split creating of new item into two part\+:
\begin{DoxyItemize}
\item create item with key only
\item insert new item into the set
\item if inserting is success, calls {\ttfamily f} functor to initialize value-\/field of new item .
\end{DoxyItemize}

The functor signature is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void}\ \mbox{\hyperlink{benchmarks_2async__task_2async__task_8hpp_abce53bb5cc1ee70cdc013fd9b93547eb}{func}}(\ \mbox{\hyperlink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\_type}}\&\ item\ );}

\end{DoxyCode}
 where {\ttfamily item} is the item inserted.

The type {\ttfamily Q} can differ from {\ttfamily \doxylink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\+\_\+type}} of items storing in the set. Therefore, the {\ttfamily \doxylink{classcds_1_1container_1_1_striped_set_a2497aaa946640a16825e61d14a6d6189}{value\+\_\+type}} should be constructible from type {\ttfamily Q}.

The user-\/defined functor is called only if the inserting is success. \Hypertarget{classcds_1_1container_1_1_striped_set_ac40ae86014cc00810a3999531bd90f82}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!lock\_count@{lock\_count}}
\index{lock\_count@{lock\_count}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{lock\_count()}{lock\_count()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_ac40ae86014cc00810a3999531bd90f82} 
template$<$class Container, typename... Options$>$ \\
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::lock\+\_\+count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns lock array size 

\Hypertarget{classcds_1_1container_1_1_striped_set_a57316947488c56167c0a0b39907e90ec}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!size@{size}}
\index{size@{size}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_a57316947488c56167c0a0b39907e90ec} 
template$<$class Container, typename... Options$>$ \\
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_ac42c05b5701aef6bab82675cf3b55fee}{\+::size}} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns item count in the set 

\Hypertarget{classcds_1_1container_1_1_striped_set_ae7015cd2952dd86da2b035b34be624fd}\index{cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}!update@{update}}
\index{update@{update}!cds::container::StripedSet$<$ Container, Options $>$@{cds::container::StripedSet$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{update()}{update()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_set_ae7015cd2952dd86da2b035b34be624fd} 
template$<$class Container, typename... Options$>$ \\
template$<$typename \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}, typename Func$>$ \\
std\+::pair$<$ \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} $>$ \mbox{\hyperlink{classcds_1_1container_1_1_striped_set}{cds\+::container\+::\+Striped\+Set}}$<$ Container, Options $>$\+::update (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}} const \&}]{val}{, }\item[{Func}]{func}{, }\item[{\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}}]{b\+Allow\+Insert}{ = {\ttfamily \mbox{\hyperlink{yyjson_8h_a41f9c5fb8b08eb5dc3edce4dcb37fee7}{true}}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Updates the node 

The operation performs inserting or changing data with lock-\/free manner.

If {\ttfamily key} is not found in the set, then {\ttfamily key} is inserted iff {\ttfamily b\+Allow\+Insert} is {\ttfamily true}. Otherwise, the functor {\ttfamily func} is called with item found.

The functor signature is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }my\_functor\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ \textcolor{keywordtype}{bool}\ bNew,\ value\_type\&\ item,\ \textcolor{keyword}{const}\ \mbox{\hyperlink{_householder_q_r__householder_q_8cpp_a7e56035a736d269ad670f312496a0846}{Q}}\&\ val\ );}
\DoxyCodeLine{\};}

\end{DoxyCode}
 with arguments\+:
\begin{DoxyItemize}
\item {\ttfamily b\+New} -\/ {\ttfamily true} if the item has been inserted, {\ttfamily false} otherwise
\item {\ttfamily item} -\/ item of the set
\item {\ttfamily val} -\/ argument {\ttfamily val} passed into the {\ttfamily update}() function
\end{DoxyItemize}

The functor may change non-\/key fields of the {\ttfamily item}.

Returns {\ttfamily  std\+::pair$<$bool, bool$>$ } where {\ttfamily first} is true if operation is successful, {\ttfamily second} is true if new item has been added or {\ttfamily false} if the item with {\ttfamily key} already is in the map. 

该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
external/libcds/cds/container/\mbox{\hyperlink{container_2striped__set_8h}{striped\+\_\+set.\+h}}\end{DoxyCompactItemize}
