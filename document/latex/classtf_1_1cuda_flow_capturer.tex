\doxysection{tf\+::cuda\+Flow\+Capturer类 参考}
\hypertarget{classtf_1_1cuda_flow_capturer}{}\label{classtf_1_1cuda_flow_capturer}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}


class to create a cuda\+Flow graph using stream capture  




{\ttfamily \#include $<$cuda\+\_\+capturer.\+hpp$>$}

\doxysubsubsection*{类}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structtf_1_1cuda_flow_capturer_1_1_external}{External}}
\item 
struct \mbox{\hyperlink{structtf_1_1cuda_flow_capturer_1_1_internal}{Internal}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a0ddccd6faa338047921269bfe964b774}{cuda\+Flow\+Capturer}} ()=\mbox{\hyperlink{sugar_8h_a6face89e97cccad5464dd9bb9c7efd23}{default}}
\begin{DoxyCompactList}\small\item\em constructs a standalone \doxylink{classtf_1_1cuda_flow_capturer}{cuda\+Flow\+Capturer} \end{DoxyCompactList}\item 
\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a8492d77263ab2a15cce21d4bfae5b331}{\texorpdfstring{$\sim$}{\string~}cuda\+Flow\+Capturer}} ()=\mbox{\hyperlink{sugar_8h_a6face89e97cccad5464dd9bb9c7efd23}{default}}
\begin{DoxyCompactList}\small\item\em destructs the \doxylink{classtf_1_1cuda_flow_capturer}{cuda\+Flow\+Capturer} \end{DoxyCompactList}\item 
\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_abeca6931972344a97c862c1f8d3ab9bb}{cuda\+Flow\+Capturer}} (\mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{cuda\+Flow\+Capturer}} \&\&)=\mbox{\hyperlink{sugar_8h_a6face89e97cccad5464dd9bb9c7efd23}{default}}
\begin{DoxyCompactList}\small\item\em default move constructor \end{DoxyCompactList}\item 
\mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{cuda\+Flow\+Capturer}} \& \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a6ca58c46c76224c26810c8487e8747bc}{operator=}} (\mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{cuda\+Flow\+Capturer}} \&\&)=\mbox{\hyperlink{sugar_8h_a6face89e97cccad5464dd9bb9c7efd23}{default}}
\begin{DoxyCompactList}\small\item\em default move assignment operator \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a3413a20a7c8229365e1ee9fb5af4af1e}{empty}} () const
\begin{DoxyCompactList}\small\item\em queries the emptiness of the graph \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_aeb826786f1580bae1335d94ffbeb7e02}{num\+\_\+tasks}} () const
\begin{DoxyCompactList}\small\item\em queries the number of tasks \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a06f1176b6a5590832f0e09a049f8a622}{clear}} ()
\begin{DoxyCompactList}\small\item\em clear this cuda\+Flow capturer \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a90d1265bcc27647906bed6e6876c9aa7}{dump}} (std\+::ostream \&os) const
\begin{DoxyCompactList}\small\item\em dumps the cuda\+Flow graph into a DOT format through an output stream \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a979fe2a7bf2c361c050c0742108197c7}{dump\+\_\+native\+\_\+graph}} (std\+::ostream \&os) const
\begin{DoxyCompactList}\small\item\em dumps the native captured graph into a DOT format through an output stream \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}, std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+invocable\+\_\+r\+\_\+v$<$ \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}}, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}, cuda\+Stream\+\_\+t $>$, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$ \texorpdfstring{$\ast$}{*} = nullptr$>$ }\\\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}{on}} (\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} \&\&callable)
\begin{DoxyCompactList}\small\item\em captures a sequential CUDA operations from the given callable \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}, std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+invocable\+\_\+r\+\_\+v$<$ \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}}, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}, cuda\+Stream\+\_\+t $>$, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$ \texorpdfstring{$\ast$}{*} = nullptr$>$ }\\\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a5215d459df3a0d7bccac1a1f2ce9d1ee}{on}} (\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} \&\&callable)
\begin{DoxyCompactList}\small\item\em updates a capture task to another sequential CUDA operations \end{DoxyCompactList}\item 
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a593335760ea517cea597237137ef9333}{noop}} ()
\begin{DoxyCompactList}\small\item\em captures a no-\/operation task \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a168a968d7f5833700fcc14a210ad39bc}{noop}} (\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}})
\begin{DoxyCompactList}\small\item\em updates a task to a no-\/operation task \end{DoxyCompactList}\item 
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ae84d097cdae9e2e8ce108dea760483ed}{memcpy}} (\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{shortpath_8cpp_a720827d53e80d32b23f708768099d331}{dst}}, const \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{shortpath_8cpp_a8648ffe7342bea77e2698690589da3c1}{src}}, size\+\_\+t \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a78e23769680a273f948d4bd3e946fcae}{count}})
\begin{DoxyCompactList}\small\item\em copies data between host and device asynchronously through a stream \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a20db64e086bf8182b350eaf5d8807af9}{memcpy}} (\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{shortpath_8cpp_a720827d53e80d32b23f708768099d331}{dst}}, const \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{shortpath_8cpp_a8648ffe7342bea77e2698690589da3c1}{src}}, size\+\_\+t \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_a78e23769680a273f948d4bd3e946fcae}{count}})
\begin{DoxyCompactList}\small\item\em updates a capture task to a memcpy operation \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, std\+::enable\+\_\+if\+\_\+t$<$!std\+::is\+\_\+same\+\_\+v$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$ \texorpdfstring{$\ast$}{*} = nullptr$>$ }\\\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ab70f12050e78b588f5c23d874aa4e538}{copy}} (\mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \texorpdfstring{$\ast$}{*}tgt, const \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{shortpath_8cpp_a8648ffe7342bea77e2698690589da3c1}{src}}, size\+\_\+t num)
\begin{DoxyCompactList}\small\item\em captures a copy task of typed data \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, std\+::enable\+\_\+if\+\_\+t$<$!std\+::is\+\_\+same\+\_\+v$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$ \texorpdfstring{$\ast$}{*} = nullptr$>$ }\\\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a605f9dfd1363e10d08cbdab29f59a52e}{copy}} (\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}, \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \texorpdfstring{$\ast$}{*}tgt, const \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{shortpath_8cpp_a8648ffe7342bea77e2698690589da3c1}{src}}, size\+\_\+t num)
\begin{DoxyCompactList}\small\item\em updates a capture task to a copy operation \end{DoxyCompactList}\item 
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a0d38965b380f940bf6cfc6667a281052}{memset}} (\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{yyjson_8h_a26c622783fa717b24fe0bbd3e060f74a}{ptr}}, \mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} \mbox{\hyperlink{_cwise__arg_8cpp_a49bb5a0db288a22a099643d44c5abbd6}{v}}, size\+\_\+t \mbox{\hyperlink{_bi_c_g_s_t_a_b__simple_8cpp_a5150192f625f4d7970d61169b9567f39}{n}})
\begin{DoxyCompactList}\small\item\em initializes or sets GPU memory to the given value byte by byte \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a4a7c4dd81f5e00e8a4c733417bca3205}{memset}} (\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{yyjson_8h_a26c622783fa717b24fe0bbd3e060f74a}{ptr}}, \mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_abe8e049f756b5ba547bda825af81b645}{value}}, size\+\_\+t \mbox{\hyperlink{_bi_c_g_s_t_a_b__simple_8cpp_a5150192f625f4d7970d61169b9567f39}{n}})
\begin{DoxyCompactList}\small\item\em updates a capture task to a memset operation \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{test__flow__graph_8cpp_a1c83625ec20fd09ecaf0e5b37c75f6f8}{F}}, typename... ArgsT$>$ }\\\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a6f06c7f6954d8d67ad89f0eddfe285e9}{kernel}} (dim3 \mbox{\hyperlink{offscreen_8c_a8cf17d727651616de6f2b79ef32170cd}{g}}, dim3 \mbox{\hyperlink{offscreen_8c_a846c9667e34d56c560bb7f0ac6e173f6}{b}}, size\+\_\+t \mbox{\hyperlink{main-override_8cpp_a1384e7608274313a9433fa573868557b}{s}}, \mbox{\hyperlink{test__flow__graph_8cpp_a1c83625ec20fd09ecaf0e5b37c75f6f8}{F}} \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}}, ArgsT \&\&... \mbox{\hyperlink{tbbproxy_8cpp_acd08a6295eccfeb30c79985f047e4be5}{args}})
\begin{DoxyCompactList}\small\item\em captures a kernel \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{test__flow__graph_8cpp_a1c83625ec20fd09ecaf0e5b37c75f6f8}{F}}, typename... ArgsT$>$ }\\\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a850c7c028e1535db1deaecd819d82efb}{kernel}} (\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}, dim3 \mbox{\hyperlink{offscreen_8c_a8cf17d727651616de6f2b79ef32170cd}{g}}, dim3 \mbox{\hyperlink{offscreen_8c_a846c9667e34d56c560bb7f0ac6e173f6}{b}}, size\+\_\+t \mbox{\hyperlink{main-override_8cpp_a1384e7608274313a9433fa573868557b}{s}}, \mbox{\hyperlink{test__flow__graph_8cpp_a1c83625ec20fd09ecaf0e5b37c75f6f8}{F}} \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}}, ArgsT \&\&... \mbox{\hyperlink{tbbproxy_8cpp_acd08a6295eccfeb30c79985f047e4be5}{args}})
\begin{DoxyCompactList}\small\item\em updates a capture task to a kernel operation \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ }\\\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ac944c7d20056e0633ef84f1a25b52296}{single\+\_\+task}} (\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} \mbox{\hyperlink{bench_vec_add_8cpp_a41689956983587b085f9da3e48f31d99}{c}})
\begin{DoxyCompactList}\small\item\em capturers a kernel to runs the given callable with only one thread \end{DoxyCompactList}\item 
{\footnotesize template$<$typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ }\\\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a2f7e439c336aa43781c3ef1ef0d71154}{single\+\_\+task}} (\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} \mbox{\hyperlink{bench_vec_add_8cpp_a41689956983587b085f9da3e48f31d99}{c}})
\begin{DoxyCompactList}\small\item\em updates a capture task to a single-\/threaded kernel \end{DoxyCompactList}\item 
{\footnotesize template$<$typename I, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ }\\\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a0b2f1bcd59f0b42e0f823818348b4ae7}{for\+\_\+each}} (I first, I last, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} callable)
\begin{DoxyCompactList}\small\item\em captures a kernel that applies a callable to each dereferenced element of the data array \end{DoxyCompactList}\item 
{\footnotesize template$<$typename I, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ }\\\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a17471b99db619c5a6b4645b3dffebe20}{for\+\_\+each}} (\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}, I first, I last, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} callable)
\begin{DoxyCompactList}\small\item\em updates a capture task to a for-\/each kernel task \end{DoxyCompactList}\item 
{\footnotesize template$<$typename I, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ }\\\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_aeb877f42ee3a627c40f1c9c84e31ba3c}{for\+\_\+each\+\_\+index}} (I first, I last, I step, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} callable)
\begin{DoxyCompactList}\small\item\em captures a kernel that applies a callable to each index in the range with the step size \end{DoxyCompactList}\item 
{\footnotesize template$<$typename I, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ }\\\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a05ca5fb4d005f1ff05fd1e4312fcd357}{for\+\_\+each\+\_\+index}} (\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}, I first, I last, I step, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} callable)
\begin{DoxyCompactList}\small\item\em updates a capture task to a for-\/each-\/index kernel task \end{DoxyCompactList}\item 
{\footnotesize template$<$typename I, typename O, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ }\\\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a99d9a86a7240ebf0767441e4ec2e14c4}{transform}} (I first, I last, O \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_a8390452002ecc7a0dadc5ae0dccc9b6c}{output}}, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} op)
\begin{DoxyCompactList}\small\item\em captures a kernel that transforms an input range to an output range \end{DoxyCompactList}\item 
{\footnotesize template$<$typename I, typename O, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ }\\\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_afa62195f91702a6f5cbdad6fefb97e4c}{transform}} (\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}, I first, I last, O \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_a8390452002ecc7a0dadc5ae0dccc9b6c}{output}}, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} op)
\begin{DoxyCompactList}\small\item\em updates a capture task to a transform kernel task \end{DoxyCompactList}\item 
{\footnotesize template$<$typename I1, typename I2, typename O, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ }\\\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ac2f527e57e8fe447b9f13ba51e9b9c48}{transform}} (I1 first1, I1 last1, I2 first2, O \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_a8390452002ecc7a0dadc5ae0dccc9b6c}{output}}, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} op)
\begin{DoxyCompactList}\small\item\em captures a kernel that transforms two input ranges to an output range \end{DoxyCompactList}\item 
{\footnotesize template$<$typename I1, typename I2, typename O, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ }\\\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a568dcdd226d7e466e2ee106fcdde5db9}{transform}} (\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}, I1 first1, I1 last1, I2 first2, O \mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_a8390452002ecc7a0dadc5ae0dccc9b6c}{output}}, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} op)
\begin{DoxyCompactList}\small\item\em updates a capture task to a transform kernel task \end{DoxyCompactList}\item 
{\footnotesize template$<$typename OPT, typename... ArgsT$>$ }\\\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a218391ee8f5f13a602e6c3606e4e0c10}{make\+\_\+optimizer}} (ArgsT \&\&... \mbox{\hyperlink{tbbproxy_8cpp_acd08a6295eccfeb30c79985f047e4be5}{args}})
\begin{DoxyCompactList}\small\item\em selects a different optimization algorithm \end{DoxyCompactList}\item 
cuda\+Graph\+\_\+t \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a31f29772f4713848c1b0ff1a66a3dcc3}{capture}} ()
\begin{DoxyCompactList}\small\item\em captures the \doxylink{classtf_1_1cuda_flow}{cuda\+Flow} and turns it into a CUDA \doxylink{classtf_1_1_graph}{Graph} \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a952596fd7c46acee4c2459d8fe39da28}{run}} (cuda\+Stream\+\_\+t stream)
\begin{DoxyCompactList}\small\item\em offloads the cuda\+Flow\+Capturer onto a GPU asynchronously via a stream \end{DoxyCompactList}\item 
cuda\+Graph\+\_\+t \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a34be2e2d69ff66add60f5517e01bea83}{native\+\_\+graph}} ()
\begin{DoxyCompactList}\small\item\em acquires a reference to the underlying CUDA graph \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespacetf_a2be50e6880ead1d49a3fec2fc4bb893e}{cuda\+Graph\+Exec}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_abacdc4f183477580e24452a2a27437cd}{instantiate}} ()
\begin{DoxyCompactList}\small\item\em instantiates an executable graph from this cudaflow capturer \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Private 类型}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a5f92f6ccad52aed18441d80bc186049f}{handle\+\_\+t}} = std\+::variant$<$\mbox{\hyperlink{structtf_1_1cuda_flow_capturer_1_1_external}{External}}, \mbox{\hyperlink{structtf_1_1cuda_flow_capturer_1_1_internal}{Internal}}$>$
\item 
using \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a5109c571ccd740aa6884221f85cd926c}{Optimizer}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Private 属性}
\begin{DoxyCompactItemize}
\item 
cuda\+Flow\+Graph \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_aaaebe71b8297f4e14ba132a664401628}{\+\_\+cfg}}
\item 
\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a5109c571ccd740aa6884221f85cd926c}{Optimizer}} \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_acdc0ba0a1d25ca9f3c0780a62b68508a}{\+\_\+optimizer}}
\end{DoxyCompactItemize}
\doxysubsubsection*{友元}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a9f64f729511a922781a59663ff1c6250}{cuda\+Flow}}
\item 
class \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a763b2f90bc53f92d680a635fe28e858e}{Executor}}
\end{DoxyCompactItemize}


\doxysubsection{详细描述}
class to create a cuda\+Flow graph using stream capture 

The usage of \doxylink{classtf_1_1cuda_flow_capturer}{tf\+::cuda\+Flow\+Capturer} is similar to \doxylink{classtf_1_1cuda_flow}{tf\+::cuda\+Flow}, except users can call the method \doxylink{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}{tf\+::cuda\+Flow\+Capturer\+::on} to capture a sequence of asynchronous CUDA operations through the given stream. The following example creates a CUDA graph that captures two kernel tasks, {\ttfamily task\+\_\+1} and {\ttfamily task\+\_\+2}, where {\ttfamily task\+\_\+1} runs before {\ttfamily task\+\_\+2}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([](tf::cudaFlowCapturer\&\ capturer)\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ capture\ my\_kernel\_1\ through\ the\ given\ stream\ managed\ by\ the\ capturer}}
\DoxyCodeLine{\ \ \textcolor{keyword}{auto}\ task\_1\ =\ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}{on}}([\&](cudaStream\_t\ stream)\{}
\DoxyCodeLine{\ \ \ \ my\_kernel\_1<<<grid\_1,\ block\_1,\ shm\_size\_1,\ stream>>>(my\_parameters\_1);}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ capture\ my\_kernel\_2\ through\ the\ given\ stream\ managed\ by\ the\ capturer}}
\DoxyCodeLine{\ \ \textcolor{keyword}{auto}\ task\_2\ =\ capturer.\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}{on}}([\&](cudaStream\_t\ stream)\{}
\DoxyCodeLine{\ \ \ \ my\_kernel\_2<<<grid\_2,\ block\_2,\ shm\_size\_2,\ stream>>>(my\_parameters\_2);}
\DoxyCodeLine{\ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ task\_1.\mbox{\hyperlink{classtf_1_1cuda_task_abdd68287ec4dff4216af34d1db44d1b4}{precede}}(task\_2);}
\DoxyCodeLine{\});}

\end{DoxyCode}


Similar to \doxylink{classtf_1_1cuda_flow}{tf\+::cuda\+Flow}, a cuda\+Flow\+Capturer is a task (\doxylink{classtf_1_1_task}{tf\+::\+Task}) created from \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow} and will be run by {\itshape one} worker thread in the executor. That is, the callable that describes a cuda\+Flow\+Capturer will be executed sequentially. Inside a cuda\+Flow capturer task, different GPU tasks (\doxylink{classtf_1_1cuda_task}{tf\+::cuda\+Task}) may run in parallel depending on the selected optimization algorithm. By default, we use \doxylink{classtf_1_1cuda_flow_round_robin_optimizer}{tf\+::cuda\+Flow\+Round\+Robin\+Optimizer} to transform a user-\/level graph into a native CUDA graph.

Please refer to \doxylink{GPUTaskingcudaFlowCapturer}{GPU Tasking (cuda\+Flow\+Capturer)} for details. 

\doxysubsection{成员类型定义说明}
\Hypertarget{classtf_1_1cuda_flow_capturer_a5f92f6ccad52aed18441d80bc186049f}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!handle\_t@{handle\_t}}
\index{handle\_t@{handle\_t}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{handle\_t}{handle\_t}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a5f92f6ccad52aed18441d80bc186049f} 
using \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a5f92f6ccad52aed18441d80bc186049f}{tf\+::cuda\+Flow\+Capturer\+::handle\+\_\+t}} = std\+::variant$<$\mbox{\hyperlink{structtf_1_1cuda_flow_capturer_1_1_external}{External}}, \mbox{\hyperlink{structtf_1_1cuda_flow_capturer_1_1_internal}{Internal}}$>$\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{classtf_1_1cuda_flow_capturer_a5109c571ccd740aa6884221f85cd926c}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!Optimizer@{Optimizer}}
\index{Optimizer@{Optimizer}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{Optimizer}{Optimizer}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a5109c571ccd740aa6884221f85cd926c} 
using \mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a5109c571ccd740aa6884221f85cd926c}{tf\+::cuda\+Flow\+Capturer\+::\+Optimizer}}\hspace{0.3cm}{\ttfamily [private]}}

{\bfseries 初始值\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::variant<}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classtf_1_1cuda_flow_round_robin_optimizer}{cudaFlowRoundRobinOptimizer}},}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classtf_1_1cuda_flow_sequential_optimizer}{cudaFlowSequentialOptimizer}},}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classtf_1_1cuda_flow_linear_optimizer}{cudaFlowLinearOptimizer}}}
\DoxyCodeLine{\ \ >}

\end{DoxyCode}


\doxysubsection{构造及析构函数说明}
\Hypertarget{classtf_1_1cuda_flow_capturer_a0ddccd6faa338047921269bfe964b774}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!cudaFlowCapturer@{cudaFlowCapturer}}
\index{cudaFlowCapturer@{cudaFlowCapturer}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{cudaFlowCapturer()}{cudaFlowCapturer()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a0ddccd6faa338047921269bfe964b774} 
tf\+::cuda\+Flow\+Capturer\+::cuda\+Flow\+Capturer (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}



constructs a standalone \doxylink{classtf_1_1cuda_flow_capturer}{cuda\+Flow\+Capturer} 

\doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} standalone cuda\+Flow capturer does not go through any taskflow and can be run by the caller thread using \doxylink{classtf_1_1cuda_flow_capturer_a952596fd7c46acee4c2459d8fe39da28}{tf\+::cuda\+Flow\+Capturer\+::run}. \Hypertarget{classtf_1_1cuda_flow_capturer_a8492d77263ab2a15cce21d4bfae5b331}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!````~cudaFlowCapturer@{\texorpdfstring{$\sim$}{\string~}cudaFlowCapturer}}
\index{````~cudaFlowCapturer@{\texorpdfstring{$\sim$}{\string~}cudaFlowCapturer}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{\texorpdfstring{$\sim$}{\string~}cudaFlowCapturer()}{\string~cudaFlowCapturer()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a8492d77263ab2a15cce21d4bfae5b331} 
tf\+::cuda\+Flow\+Capturer\+::\texorpdfstring{$\sim$}{\string~}cuda\+Flow\+Capturer (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}



destructs the \doxylink{classtf_1_1cuda_flow_capturer}{cuda\+Flow\+Capturer} 

\Hypertarget{classtf_1_1cuda_flow_capturer_abeca6931972344a97c862c1f8d3ab9bb}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!cudaFlowCapturer@{cudaFlowCapturer}}
\index{cudaFlowCapturer@{cudaFlowCapturer}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{cudaFlowCapturer()}{cudaFlowCapturer()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_abeca6931972344a97c862c1f8d3ab9bb} 
tf\+::cuda\+Flow\+Capturer\+::cuda\+Flow\+Capturer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{cuda\+Flow\+Capturer}} \&\&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}



default move constructor 

函数调用图\+:
% FIG 0


\doxysubsection{成员函数说明}
\Hypertarget{classtf_1_1cuda_flow_capturer_a31f29772f4713848c1b0ff1a66a3dcc3}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!capture@{capture}}
\index{capture@{capture}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{capture()}{capture()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a31f29772f4713848c1b0ff1a66a3dcc3} 
cuda\+Graph\+\_\+t tf\+::cuda\+Flow\+Capturer\+::capture (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



captures the \doxylink{classtf_1_1cuda_flow}{cuda\+Flow} and turns it into a CUDA \doxylink{classtf_1_1_graph}{Graph} 

\Hypertarget{classtf_1_1cuda_flow_capturer_a06f1176b6a5590832f0e09a049f8a622}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!clear@{clear}}
\index{clear@{clear}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a06f1176b6a5590832f0e09a049f8a622} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::clear (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



clear this cuda\+Flow capturer 

\Hypertarget{classtf_1_1cuda_flow_capturer_a605f9dfd1363e10d08cbdab29f59a52e}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!copy@{copy}}
\index{copy@{copy}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{copy()}{copy()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a605f9dfd1363e10d08cbdab29f59a52e} 
template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, std\+::enable\+\_\+if\+\_\+t$<$!std\+::is\+\_\+same\+\_\+v$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$ \texorpdfstring{$\ast$}{*} = nullptr$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::copy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}}}]{task}{, }\item[{\mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \texorpdfstring{$\ast$}{*}}]{tgt}{, }\item[{const \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \texorpdfstring{$\ast$}{*}}]{src}{, }\item[{size\+\_\+t}]{num}{}\end{DoxyParamCaption})}



updates a capture task to a copy operation 

The method is similar to \doxylink{classtf_1_1cuda_flow_capturer_ab70f12050e78b588f5c23d874aa4e538}{cuda\+Flow\+Capturer\+::copy} but operates on an existing task. \Hypertarget{classtf_1_1cuda_flow_capturer_ab70f12050e78b588f5c23d874aa4e538}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!copy@{copy}}
\index{copy@{copy}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{copy()}{copy()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_ab70f12050e78b588f5c23d874aa4e538} 
template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, std\+::enable\+\_\+if\+\_\+t$<$!std\+::is\+\_\+same\+\_\+v$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$ \texorpdfstring{$\ast$}{*}$>$ \\
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} tf\+::cuda\+Flow\+Capturer\+::copy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \texorpdfstring{$\ast$}{*}}]{tgt}{, }\item[{const \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \texorpdfstring{$\ast$}{*}}]{src}{, }\item[{size\+\_\+t}]{num}{}\end{DoxyParamCaption})}



captures a copy task of typed data 


\begin{DoxyTemplParams}{模板参数}
{\em T} & element type (non-\/void)\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em tgt} & pointer to the target memory block \\
\hline
{\em src} & pointer to the source memory block \\
\hline
{\em num} & number of elements to copy\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
\doxylink{classtf_1_1cuda_task}{cuda\+Task} handle
\end{DoxyReturn}
\doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} copy task transfers {\ttfamily num\texorpdfstring{$\ast$}{*}sizeof(T)} bytes of data from a source location to a target location. Direction can be arbitrary among CPUs and GPUs. 函数调用图\+:
% FIG 1
\Hypertarget{classtf_1_1cuda_flow_capturer_a90d1265bcc27647906bed6e6876c9aa7}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!dump@{dump}}
\index{dump@{dump}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{dump()}{dump()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a90d1265bcc27647906bed6e6876c9aa7} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::dump (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



dumps the cuda\+Flow graph into a DOT format through an output stream 

\Hypertarget{classtf_1_1cuda_flow_capturer_a979fe2a7bf2c361c050c0742108197c7}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!dump\_native\_graph@{dump\_native\_graph}}
\index{dump\_native\_graph@{dump\_native\_graph}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{dump\_native\_graph()}{dump\_native\_graph()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a979fe2a7bf2c361c050c0742108197c7} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::dump\+\_\+native\+\_\+graph (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{os}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



dumps the native captured graph into a DOT format through an output stream 

\Hypertarget{classtf_1_1cuda_flow_capturer_a3413a20a7c8229365e1ee9fb5af4af1e}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!empty@{empty}}
\index{empty@{empty}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a3413a20a7c8229365e1ee9fb5af4af1e} 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} tf\+::cuda\+Flow\+Capturer\+::empty (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



queries the emptiness of the graph 

\Hypertarget{classtf_1_1cuda_flow_capturer_a17471b99db619c5a6b4645b3dffebe20}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!for\_each@{for\_each}}
\index{for\_each@{for\_each}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{for\_each()}{for\_each()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a17471b99db619c5a6b4645b3dffebe20} 
template$<$typename I, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::for\+\_\+each (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}}}]{task}{, }\item[{I}]{first}{, }\item[{I}]{last}{, }\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}}]{callable}{}\end{DoxyParamCaption})}



updates a capture task to a for-\/each kernel task 

This method is similar to \doxylink{classtf_1_1cuda_flow_capturer_a0b2f1bcd59f0b42e0f823818348b4ae7}{cuda\+Flow\+Capturer\+::for\+\_\+each} but operates on an existing task. 函数调用图\+:
% FIG 2
\Hypertarget{classtf_1_1cuda_flow_capturer_a0b2f1bcd59f0b42e0f823818348b4ae7}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!for\_each@{for\_each}}
\index{for\_each@{for\_each}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{for\_each()}{for\_each()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a0b2f1bcd59f0b42e0f823818348b4ae7} 
template$<$typename I, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ \\
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} tf\+::cuda\+Flow\+Capturer\+::for\+\_\+each (\begin{DoxyParamCaption}\item[{I}]{first}{, }\item[{I}]{last}{, }\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}}]{callable}{}\end{DoxyParamCaption})}



captures a kernel that applies a callable to each dereferenced element of the data array 


\begin{DoxyTemplParams}{模板参数}
{\em I} & iterator type \\
\hline
{\em C} & callable type\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em first} & iterator to the beginning \\
\hline
{\em last} & iterator to the end \\
\hline
{\em callable} & a callable object to apply to the dereferenced iterator\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
\doxylink{classtf_1_1cuda_task}{cuda\+Task} handle
\end{DoxyReturn}
This method is equivalent to the parallel execution of the following loop on a GPU\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\ itr\ =\ first;\ itr\ !=\ \mbox{\hyperlink{namespacetbb_1_1internal_a18405c9631e7064d3af5662f30a84dd2}{last}};\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}++)\ \{}
\DoxyCodeLine{\ \ callable(*itr);}
\DoxyCodeLine{\}}

\end{DoxyCode}
 函数调用图\+:
% FIG 3
\Hypertarget{classtf_1_1cuda_flow_capturer_a05ca5fb4d005f1ff05fd1e4312fcd357}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!for\_each\_index@{for\_each\_index}}
\index{for\_each\_index@{for\_each\_index}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{for\_each\_index()}{for\_each\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a05ca5fb4d005f1ff05fd1e4312fcd357} 
template$<$typename I, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::for\+\_\+each\+\_\+index (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}}}]{task}{, }\item[{I}]{first}{, }\item[{I}]{last}{, }\item[{I}]{step}{, }\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}}]{callable}{}\end{DoxyParamCaption})}



updates a capture task to a for-\/each-\/index kernel task 

This method is similar to \doxylink{classtf_1_1cuda_flow_capturer_aeb877f42ee3a627c40f1c9c84e31ba3c}{cuda\+Flow\+Capturer\+::for\+\_\+each\+\_\+index} but operates on an existing task. 函数调用图\+:
% FIG 4
\Hypertarget{classtf_1_1cuda_flow_capturer_aeb877f42ee3a627c40f1c9c84e31ba3c}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!for\_each\_index@{for\_each\_index}}
\index{for\_each\_index@{for\_each\_index}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{for\_each\_index()}{for\_each\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_aeb877f42ee3a627c40f1c9c84e31ba3c} 
template$<$typename I, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ \\
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} tf\+::cuda\+Flow\+Capturer\+::for\+\_\+each\+\_\+index (\begin{DoxyParamCaption}\item[{I}]{first}{, }\item[{I}]{last}{, }\item[{I}]{step}{, }\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}}]{callable}{}\end{DoxyParamCaption})}



captures a kernel that applies a callable to each index in the range with the step size 


\begin{DoxyTemplParams}{模板参数}
{\em I} & index type \\
\hline
{\em C} & callable type\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em first} & beginning index \\
\hline
{\em last} & last index \\
\hline
{\em step} & step size \\
\hline
{\em callable} & the callable to apply to each element in the data array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
\doxylink{classtf_1_1cuda_task}{cuda\+Task} handle
\end{DoxyReturn}
This method is equivalent to the parallel execution of the following loop on a GPU\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ step\ is\ positive\ [first,\ last)}}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}=first;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}<\mbox{\hyperlink{namespacetbb_1_1internal_a18405c9631e7064d3af5662f30a84dd2}{last}};\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}+=\mbox{\hyperlink{namespaceluisa_1_1compute_1_1dsl_a8af85ff0ba544ac84f4b42b0333f5d14}{step}})\ \{}
\DoxyCodeLine{\ \ callable(\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}});}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ step\ is\ negative\ [first,\ last)}}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}=first;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}>\mbox{\hyperlink{namespacetbb_1_1internal_a18405c9631e7064d3af5662f30a84dd2}{last}};\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}+=\mbox{\hyperlink{namespaceluisa_1_1compute_1_1dsl_a8af85ff0ba544ac84f4b42b0333f5d14}{step}})\ \{}
\DoxyCodeLine{\ \ callable(\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}});}
\DoxyCodeLine{\}}

\end{DoxyCode}
 函数调用图\+:
% FIG 5
\Hypertarget{classtf_1_1cuda_flow_capturer_abacdc4f183477580e24452a2a27437cd}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!instantiate@{instantiate}}
\index{instantiate@{instantiate}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{instantiate()}{instantiate()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_abacdc4f183477580e24452a2a27437cd} 
\mbox{\hyperlink{namespacetf_a2be50e6880ead1d49a3fec2fc4bb893e}{cuda\+Graph\+Exec}} tf\+::cuda\+Flow\+Capturer\+::instantiate (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



instantiates an executable graph from this cudaflow capturer 

函数调用图\+:
% FIG 6
\Hypertarget{classtf_1_1cuda_flow_capturer_a850c7c028e1535db1deaecd819d82efb}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!kernel@{kernel}}
\index{kernel@{kernel}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{kernel()}{kernel()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a850c7c028e1535db1deaecd819d82efb} 
template$<$typename \mbox{\hyperlink{test__flow__graph_8cpp_a1c83625ec20fd09ecaf0e5b37c75f6f8}{F}}, typename... ArgsT$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::kernel (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}}}]{task}{, }\item[{dim3}]{g}{, }\item[{dim3}]{b}{, }\item[{size\+\_\+t}]{s}{, }\item[{\mbox{\hyperlink{test__flow__graph_8cpp_a1c83625ec20fd09ecaf0e5b37c75f6f8}{F}}}]{f}{, }\item[{ArgsT \&\&...}]{args}{}\end{DoxyParamCaption})}



updates a capture task to a kernel operation 

The method is similar to \doxylink{classtf_1_1cuda_flow_capturer_a6f06c7f6954d8d67ad89f0eddfe285e9}{cuda\+Flow\+Capturer\+::kernel} but operates on an existing task. 函数调用图\+:
% FIG 7
\Hypertarget{classtf_1_1cuda_flow_capturer_a6f06c7f6954d8d67ad89f0eddfe285e9}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!kernel@{kernel}}
\index{kernel@{kernel}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{kernel()}{kernel()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a6f06c7f6954d8d67ad89f0eddfe285e9} 
template$<$typename \mbox{\hyperlink{test__flow__graph_8cpp_a1c83625ec20fd09ecaf0e5b37c75f6f8}{F}}, typename... ArgsT$>$ \\
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} tf\+::cuda\+Flow\+Capturer\+::kernel (\begin{DoxyParamCaption}\item[{dim3}]{g}{, }\item[{dim3}]{b}{, }\item[{size\+\_\+t}]{s}{, }\item[{\mbox{\hyperlink{test__flow__graph_8cpp_a1c83625ec20fd09ecaf0e5b37c75f6f8}{F}}}]{f}{, }\item[{ArgsT \&\&...}]{args}{}\end{DoxyParamCaption})}



captures a kernel 


\begin{DoxyTemplParams}{模板参数}
{\em F} & kernel function type \\
\hline
{\em ArgsT} & kernel function parameters type\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em g} & configured grid \\
\hline
{\em b} & configured block \\
\hline
{\em s} & configured shared memory size in bytes \\
\hline
{\em f} & kernel function \\
\hline
{\em args} & arguments to forward to the kernel function by copy\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
\doxylink{classtf_1_1cuda_task}{cuda\+Task} handle 
\end{DoxyReturn}
函数调用图\+:
% FIG 8
\Hypertarget{classtf_1_1cuda_flow_capturer_a218391ee8f5f13a602e6c3606e4e0c10}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!make\_optimizer@{make\_optimizer}}
\index{make\_optimizer@{make\_optimizer}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{make\_optimizer()}{make\_optimizer()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a218391ee8f5f13a602e6c3606e4e0c10} 
template$<$typename OPT, typename ... ArgsT$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::make\+\_\+optimizer (\begin{DoxyParamCaption}\item[{ArgsT \&\&...}]{args}{}\end{DoxyParamCaption})}



selects a different optimization algorithm 


\begin{DoxyTemplParams}{模板参数}
{\em OPT} & optimizer type \\
\hline
{\em ArgsT} & arguments types\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em args} & arguments to forward to construct the optimizer\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
a reference to the optimizer
\end{DoxyReturn}
We currently supports the following optimization algorithms to capture a user-\/described cuda\+Flow\+:
\begin{DoxyItemize}
\item \doxylink{classtf_1_1cuda_flow_sequential_optimizer}{tf\+::cuda\+Flow\+Sequential\+Optimizer}
\item \doxylink{classtf_1_1cuda_flow_round_robin_optimizer}{tf\+::cuda\+Flow\+Round\+Robin\+Optimizer}
\item \doxylink{classtf_1_1cuda_flow_linear_optimizer}{tf\+::cuda\+Flow\+Linear\+Optimizer}
\end{DoxyItemize}

By default, \doxylink{classtf_1_1cuda_flow_capturer}{tf\+::cuda\+Flow\+Capturer} uses the round-\/robin optimization algorithm with four streams to transform a user-\/level graph into a native CUDA graph. \Hypertarget{classtf_1_1cuda_flow_capturer_a20db64e086bf8182b350eaf5d8807af9}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!memcpy@{memcpy}}
\index{memcpy@{memcpy}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{memcpy()}{memcpy()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a20db64e086bf8182b350eaf5d8807af9} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::memcpy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}}}]{task}{, }\item[{\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}}]{dst}{, }\item[{const \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}}]{src}{, }\item[{size\+\_\+t}]{count}{}\end{DoxyParamCaption})}



updates a capture task to a memcpy operation 

The method is similar to \doxylink{classtf_1_1cuda_flow_capturer_ae84d097cdae9e2e8ce108dea760483ed}{cuda\+Flow\+Capturer\+::memcpy} but operates on an existing task. \Hypertarget{classtf_1_1cuda_flow_capturer_ae84d097cdae9e2e8ce108dea760483ed}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!memcpy@{memcpy}}
\index{memcpy@{memcpy}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{memcpy()}{memcpy()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_ae84d097cdae9e2e8ce108dea760483ed} 
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} tf\+::cuda\+Flow\+Capturer\+::memcpy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}}]{dst}{, }\item[{const \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}}]{src}{, }\item[{size\+\_\+t}]{count}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



copies data between host and device asynchronously through a stream 


\begin{DoxyParams}{参数}
{\em dst} & destination memory address \\
\hline
{\em src} & source memory address \\
\hline
{\em count} & size in bytes to copy\\
\hline
\end{DoxyParams}
The method captures a {\ttfamily cuda\+Memcpy\+Async} operation through an internal stream. 函数调用图\+:
% FIG 9
\Hypertarget{classtf_1_1cuda_flow_capturer_a4a7c4dd81f5e00e8a4c733417bca3205}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!memset@{memset}}
\index{memset@{memset}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{memset()}{memset()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a4a7c4dd81f5e00e8a4c733417bca3205} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::memset (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}}}]{task}{, }\item[{\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}}]{ptr}{, }\item[{\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}}}]{value}{, }\item[{size\+\_\+t}]{n}{}\end{DoxyParamCaption})}



updates a capture task to a memset operation 

The method is similar to \doxylink{classtf_1_1cuda_flow_capturer_a0d38965b380f940bf6cfc6667a281052}{cuda\+Flow\+Capturer\+::memset} but operates on an existing task. 函数调用图\+:
% FIG 10
\Hypertarget{classtf_1_1cuda_flow_capturer_a0d38965b380f940bf6cfc6667a281052}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!memset@{memset}}
\index{memset@{memset}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{memset()}{memset()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a0d38965b380f940bf6cfc6667a281052} 
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} tf\+::cuda\+Flow\+Capturer\+::memset (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*}}]{ptr}{, }\item[{\mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}}}]{v}{, }\item[{size\+\_\+t}]{n}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



initializes or sets GPU memory to the given value byte by byte 


\begin{DoxyParams}{参数}
{\em ptr} & pointer to GPU memory \\
\hline
{\em v} & value to set for each byte of the specified memory \\
\hline
{\em n} & size in bytes to set\\
\hline
\end{DoxyParams}
The method captures a {\ttfamily cuda\+Memset\+Async} operation through an internal stream to fill the first {\ttfamily count} bytes of the memory area pointed to by {\ttfamily dev\+Ptr} with the constant byte value {\ttfamily value}. 函数调用图\+:
% FIG 11
\Hypertarget{classtf_1_1cuda_flow_capturer_a34be2e2d69ff66add60f5517e01bea83}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!native\_graph@{native\_graph}}
\index{native\_graph@{native\_graph}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{native\_graph()}{native\_graph()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a34be2e2d69ff66add60f5517e01bea83} 
cuda\+Graph\+\_\+t tf\+::cuda\+Flow\+Capturer\+::native\+\_\+graph (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



acquires a reference to the underlying CUDA graph 

\Hypertarget{classtf_1_1cuda_flow_capturer_a593335760ea517cea597237137ef9333}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!noop@{noop}}
\index{noop@{noop}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{noop()}{noop()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a593335760ea517cea597237137ef9333} 
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} tf\+::cuda\+Flow\+Capturer\+::noop (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



captures a no-\/operation task 

\begin{DoxyReturn}{返回}
a \doxylink{classtf_1_1cuda_task}{tf\+::cuda\+Task} handle
\end{DoxyReturn}
An empty node performs no operation during execution, but can be used for transitive ordering. For example, a phased execution graph with 2 groups of {\ttfamily n} nodes with a barrier between them can be represented using an empty node and {\ttfamily 2\texorpdfstring{$\ast$}{*}n} dependency edges, rather than no empty node and {\ttfamily n\texorpdfstring{$^\wedge$}{\string^}2} dependency edges. 函数调用图\+:
% FIG 12
\Hypertarget{classtf_1_1cuda_flow_capturer_a168a968d7f5833700fcc14a210ad39bc}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!noop@{noop}}
\index{noop@{noop}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{noop()}{noop()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a168a968d7f5833700fcc14a210ad39bc} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::noop (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}}}]{task}{}\end{DoxyParamCaption})}



updates a task to a no-\/operation task 

The method is similar to \doxylink{classtf_1_1cuda_flow_capturer_a593335760ea517cea597237137ef9333}{tf\+::cuda\+Flow\+Capturer\+::noop} but operates on an existing task. \Hypertarget{classtf_1_1cuda_flow_capturer_aeb826786f1580bae1335d94ffbeb7e02}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!num\_tasks@{num\_tasks}}
\index{num\_tasks@{num\_tasks}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{num\_tasks()}{num\_tasks()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_aeb826786f1580bae1335d94ffbeb7e02} 
size\+\_\+t tf\+::cuda\+Flow\+Capturer\+::num\+\_\+tasks (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



queries the number of tasks 

\Hypertarget{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!on@{on}}
\index{on@{on}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{on()}{on()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41} 
template$<$typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}, std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+invocable\+\_\+r\+\_\+v$<$ \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}}, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}, cuda\+Stream\+\_\+t $>$, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$ \texorpdfstring{$\ast$}{*}$>$ \\
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} tf\+::cuda\+Flow\+Capturer\+::on (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} \&\&}]{callable}{}\end{DoxyParamCaption})}



captures a sequential CUDA operations from the given callable 


\begin{DoxyTemplParams}{模板参数}
{\em C} & callable type constructible with {\ttfamily std\+::function$<$void(cuda\+Stream\+\_\+t)$>$} \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em callable} & a callable to capture CUDA operations with the stream\\
\hline
\end{DoxyParams}
This methods applies a stream created by the flow to capture a sequence of CUDA operations defined in the callable. \Hypertarget{classtf_1_1cuda_flow_capturer_a5215d459df3a0d7bccac1a1f2ce9d1ee}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!on@{on}}
\index{on@{on}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{on()}{on()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a5215d459df3a0d7bccac1a1f2ce9d1ee} 
template$<$typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}, std\+::enable\+\_\+if\+\_\+t$<$ std\+::is\+\_\+invocable\+\_\+r\+\_\+v$<$ \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}}, \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}, cuda\+Stream\+\_\+t $>$, \mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} $>$ \texorpdfstring{$\ast$}{*} = nullptr$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::on (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}}}]{task}{, }\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}} \&\&}]{callable}{}\end{DoxyParamCaption})}



updates a capture task to another sequential CUDA operations 

The method is similar to \doxylink{classtf_1_1cuda_flow_capturer_ad0d937ae0d77239f148b66a77e35db41}{cuda\+Flow\+Capturer\+::on} but operates on an existing task. \Hypertarget{classtf_1_1cuda_flow_capturer_a6ca58c46c76224c26810c8487e8747bc}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!operator=@{operator=}}
\index{operator=@{operator=}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a6ca58c46c76224c26810c8487e8747bc} 
\mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{cuda\+Flow\+Capturer}} \& tf\+::cuda\+Flow\+Capturer\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_flow_capturer}{cuda\+Flow\+Capturer}} \&\&}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}



default move assignment operator 

函数调用图\+:
% FIG 13
\Hypertarget{classtf_1_1cuda_flow_capturer_a952596fd7c46acee4c2459d8fe39da28}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!run@{run}}
\index{run@{run}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{run()}{run()}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a952596fd7c46acee4c2459d8fe39da28} 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::run (\begin{DoxyParamCaption}\item[{cuda\+Stream\+\_\+t}]{stream}{}\end{DoxyParamCaption})}



offloads the cuda\+Flow\+Capturer onto a GPU asynchronously via a stream 


\begin{DoxyParams}{参数}
{\em stream} & stream for performing this operation\\
\hline
\end{DoxyParams}
Offloads the present cuda\+Flow\+Capturer onto a GPU asynchronously via the given stream.

An offloaded cuda\+Flow\+Capturer forces the underlying graph to be instantiated. After the instantiation, you should not modify the graph topology but update node parameters. \Hypertarget{classtf_1_1cuda_flow_capturer_ac944c7d20056e0633ef84f1a25b52296}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!single\_task@{single\_task}}
\index{single\_task@{single\_task}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{single\_task()}{single\_task()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_ac944c7d20056e0633ef84f1a25b52296} 
template$<$typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ \\
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} tf\+::cuda\+Flow\+Capturer\+::single\+\_\+task (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}}]{c}{}\end{DoxyParamCaption})}



capturers a kernel to runs the given callable with only one thread 


\begin{DoxyTemplParams}{模板参数}
{\em C} & callable type\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em c} & callable to run by a single kernel thread \\
\hline
\end{DoxyParams}
函数调用图\+:
% FIG 14
\Hypertarget{classtf_1_1cuda_flow_capturer_a2f7e439c336aa43781c3ef1ef0d71154}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!single\_task@{single\_task}}
\index{single\_task@{single\_task}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{single\_task()}{single\_task()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a2f7e439c336aa43781c3ef1ef0d71154} 
template$<$typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::single\+\_\+task (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}}}]{task}{, }\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}}]{c}{}\end{DoxyParamCaption})}



updates a capture task to a single-\/threaded kernel 

This method is similar to \doxylink{classtf_1_1cuda_flow_capturer_ac944c7d20056e0633ef84f1a25b52296}{cuda\+Flow\+Capturer\+::single\+\_\+task} but operates on an existing task. 函数调用图\+:
% FIG 15
\Hypertarget{classtf_1_1cuda_flow_capturer_afa62195f91702a6f5cbdad6fefb97e4c}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!transform@{transform}}
\index{transform@{transform}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{transform()}{transform()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_afa62195f91702a6f5cbdad6fefb97e4c} 
template$<$typename I, typename O, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::transform (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}}}]{task}{, }\item[{I}]{first}{, }\item[{I}]{last}{, }\item[{O}]{output}{, }\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}}]{op}{}\end{DoxyParamCaption})}



updates a capture task to a transform kernel task 

This method is similar to \doxylink{classtf_1_1cuda_flow_capturer_a99d9a86a7240ebf0767441e4ec2e14c4}{cuda\+Flow\+Capturer\+::transform} but operates on an existing task. 函数调用图\+:
% FIG 16
\Hypertarget{classtf_1_1cuda_flow_capturer_a568dcdd226d7e466e2ee106fcdde5db9}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!transform@{transform}}
\index{transform@{transform}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{transform()}{transform()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a568dcdd226d7e466e2ee106fcdde5db9} 
template$<$typename I1, typename I2, typename O, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} tf\+::cuda\+Flow\+Capturer\+::transform (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}}}]{task}{, }\item[{I1}]{first1}{, }\item[{I1}]{last1}{, }\item[{I2}]{first2}{, }\item[{O}]{output}{, }\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}}]{op}{}\end{DoxyParamCaption})}



updates a capture task to a transform kernel task 

This method is similar to \doxylink{classtf_1_1cuda_flow_capturer_a99d9a86a7240ebf0767441e4ec2e14c4}{cuda\+Flow\+Capturer\+::transform} but operates on an existing task. 函数调用图\+:
% FIG 17
\Hypertarget{classtf_1_1cuda_flow_capturer_a99d9a86a7240ebf0767441e4ec2e14c4}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!transform@{transform}}
\index{transform@{transform}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{transform()}{transform()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a99d9a86a7240ebf0767441e4ec2e14c4} 
template$<$typename I, typename O, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ \\
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} tf\+::cuda\+Flow\+Capturer\+::transform (\begin{DoxyParamCaption}\item[{I}]{first}{, }\item[{I}]{last}{, }\item[{O}]{output}{, }\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}}]{op}{}\end{DoxyParamCaption})}



captures a kernel that transforms an input range to an output range 


\begin{DoxyTemplParams}{模板参数}
{\em I} & input iterator type \\
\hline
{\em O} & output iterator type \\
\hline
{\em C} & unary operator type\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em first} & iterator to the beginning of the input range \\
\hline
{\em last} & iterator to the end of the input range \\
\hline
{\em output} & iterator to the beginning of the output range \\
\hline
{\em op} & unary operator to apply to transform each item in the range\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
\doxylink{classtf_1_1cuda_task}{cuda\+Task} handle
\end{DoxyReturn}
This method is equivalent to the parallel execution of the following loop on a GPU\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{while}\ (first\ !=\ last)\ \{}
\DoxyCodeLine{\ \ *\mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_a8390452002ecc7a0dadc5ae0dccc9b6c}{output}}++\ =\ op(*first++);}
\DoxyCodeLine{\}}

\end{DoxyCode}
 函数调用图\+:
% FIG 18
\Hypertarget{classtf_1_1cuda_flow_capturer_ac2f527e57e8fe447b9f13ba51e9b9c48}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!transform@{transform}}
\index{transform@{transform}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{transform()}{transform()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_ac2f527e57e8fe447b9f13ba51e9b9c48} 
template$<$typename I1, typename I2, typename O, typename \mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}$>$ \\
\mbox{\hyperlink{classtf_1_1cuda_task}{cuda\+Task}} tf\+::cuda\+Flow\+Capturer\+::transform (\begin{DoxyParamCaption}\item[{I1}]{first1}{, }\item[{I1}]{last1}{, }\item[{I2}]{first2}{, }\item[{O}]{output}{, }\item[{\mbox{\hyperlink{bench__gemm_8cpp_aaee470c3acb6b181fd804d072284fbaa}{C}}}]{op}{}\end{DoxyParamCaption})}



captures a kernel that transforms two input ranges to an output range 


\begin{DoxyTemplParams}{模板参数}
{\em I1} & first input iterator type \\
\hline
{\em I2} & second input iterator type \\
\hline
{\em O} & output iterator type \\
\hline
{\em C} & unary operator type\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{参数}
{\em first1} & iterator to the beginning of the input range \\
\hline
{\em last1} & iterator to the end of the input range \\
\hline
{\em first2} & iterato \\
\hline
{\em output} & iterator to the beginning of the output range \\
\hline
{\em op} & binary operator to apply to transform each pair of items in the two input ranges\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
\doxylink{classtf_1_1cuda_task}{cuda\+Task} handle
\end{DoxyReturn}
This method is equivalent to the parallel execution of the following loop on a GPU\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{while}\ (first1\ !=\ last1)\ \{}
\DoxyCodeLine{\ \ *\mbox{\hyperlink{benchmarks_2scan_2scan_8hpp_a8390452002ecc7a0dadc5ae0dccc9b6c}{output}}++\ =\ op(*first1++,\ *first2++);}
\DoxyCodeLine{\}}

\end{DoxyCode}
 函数调用图\+:
% FIG 19


\doxysubsection{友元及相关符号说明}
\Hypertarget{classtf_1_1cuda_flow_capturer_a9f64f729511a922781a59663ff1c6250}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!cudaFlow@{cudaFlow}}
\index{cudaFlow@{cudaFlow}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{cudaFlow}{cudaFlow}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a9f64f729511a922781a59663ff1c6250} 
friend class \mbox{\hyperlink{classtf_1_1cuda_flow}{cuda\+Flow}}\hspace{0.3cm}{\ttfamily [friend]}}

\Hypertarget{classtf_1_1cuda_flow_capturer_a763b2f90bc53f92d680a635fe28e858e}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!Executor@{Executor}}
\index{Executor@{Executor}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{Executor}{Executor}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_a763b2f90bc53f92d680a635fe28e858e} 
friend class \mbox{\hyperlink{classtf_1_1_executor}{Executor}}\hspace{0.3cm}{\ttfamily [friend]}}



\doxysubsection{类成员变量说明}
\Hypertarget{classtf_1_1cuda_flow_capturer_aaaebe71b8297f4e14ba132a664401628}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!\_cfg@{\_cfg}}
\index{\_cfg@{\_cfg}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{\_cfg}{\_cfg}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_aaaebe71b8297f4e14ba132a664401628} 
cuda\+Flow\+Graph tf\+::cuda\+Flow\+Capturer\+::\+\_\+cfg\hspace{0.3cm}{\ttfamily [private]}}

\Hypertarget{classtf_1_1cuda_flow_capturer_acdc0ba0a1d25ca9f3c0780a62b68508a}\index{tf::cudaFlowCapturer@{tf::cudaFlowCapturer}!\_optimizer@{\_optimizer}}
\index{\_optimizer@{\_optimizer}!tf::cudaFlowCapturer@{tf::cudaFlowCapturer}}
\doxysubsubsection{\texorpdfstring{\_optimizer}{\_optimizer}}
{\footnotesize\ttfamily \label{classtf_1_1cuda_flow_capturer_acdc0ba0a1d25ca9f3c0780a62b68508a} 
\mbox{\hyperlink{classtf_1_1cuda_flow_capturer_a5109c571ccd740aa6884221f85cd926c}{Optimizer}} tf\+::cuda\+Flow\+Capturer\+::\+\_\+optimizer\hspace{0.3cm}{\ttfamily [private]}}



该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
external/taskflow/taskflow/cuda/\mbox{\hyperlink{cuda__capturer_8hpp}{cuda\+\_\+capturer.\+hpp}}\item 
external/taskflow/taskflow/cuda/algorithm/\mbox{\hyperlink{taskflow_2cuda_2algorithm_2for__each_8hpp}{for\+\_\+each.\+hpp}}\item 
external/taskflow/taskflow/cuda/algorithm/\mbox{\hyperlink{cuda_2algorithm_2transform_8hpp}{transform.\+hpp}}\end{DoxyCompactItemize}
