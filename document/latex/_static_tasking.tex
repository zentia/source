\doxysection{Static Tasking}
\hypertarget{_static_tasking}{}\label{_static_tasking}\index{Static Tasking@{Static Tasking}}
This chapter demonstrates how to create a static task dependency graph. \doxylink{class_static}{Static} tasking captures the static parallel structure of a decomposition and is defined only by the program itself. It has a flat task hierarchy and cannot spawn new tasks from a running dependency graph.\hypertarget{_static_tasking_CreateATaskDependencyGraph}{}\doxysubsection{\texorpdfstring{Create a Task Dependency Graph}{Create a Task Dependency Graph}}\label{_static_tasking_CreateATaskDependencyGraph}
\doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} task in Taskflow is a {\itshape callable} object for which the operation @std\+\_\+invoke is applicable. It can be either a functor, a lambda expression, a bind expression, or a class objects with {\ttfamily operator()} overloaded. All tasks are created from \doxylink{classtf_1_1_taskflow}{tf\+::\+Taskflow}, the class that manages a task dependency graph. Taskflow provides two methods, \doxylink{classtf_1_1_flow_builder_acab0b4ac82260f47fdb36a3244ee3aaf}{tf\+::\+Taskflow\+::placeholder} and \doxylink{classtf_1_1_flow_builder_a60d7a666cab71ecfa3010b2efb0d6b57}{tf\+::\+Taskflow\+::emplace} to create a task.


\begin{DoxyCode}{0}
\DoxyCodeLine{1:\ \mbox{\hyperlink{classtf_1_1_taskflow}{tf::Taskflow}}\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}};}
\DoxyCodeLine{2:\ \mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.placeholder();}
\DoxyCodeLine{3:\ \mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ \mbox{\hyperlink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}task\ B\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{4:}
\DoxyCodeLine{5:\ \textcolor{keyword}{auto}\ [\mbox{\hyperlink{_eigen_solver___eigen_solver___matrix_type_8cpp_a925331f9b6e4844293d36a8df2256d38}{D}},\ \mbox{\hyperlink{sandbox_2strassen_2omp_8cpp_a4bfa035cad7c3258704669810cd5de5d}{E}},\ \mbox{\hyperlink{test__flow__graph_8cpp_a1c83625ec20fd09ecaf0e5b37c75f6f8}{F}}]\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace(}
\DoxyCodeLine{6:\ \ \ []()\{\ std::cout\ <<\ \textcolor{stringliteral}{"{}Task\ A\(\backslash\)n"{}};\ \},}
\DoxyCodeLine{7:\ \ \ []()\{\ std::cout\ <<\ \textcolor{stringliteral}{"{}Task\ B\(\backslash\)n"{}};\ \},}
\DoxyCodeLine{8:\ \ \ []()\{\ std::cout\ <<\ \textcolor{stringliteral}{"{}Task\ C\(\backslash\)n"{}};\ \}}
\DoxyCodeLine{9:\ );}

\end{DoxyCode}


Debrief\+: \begin{DoxyItemize}
\item Line 1 creates a taskflow object, or a {\itshape graph} \item Line 2 creates a placeholder task without work (i.\+e., callable) \item Line 3 creates a task from a given callable object and returns a task handle \item Lines 5-\/9 create three tasks in one call using C++ structured binding coupled with std\+::tuple\end{DoxyItemize}
Each time you create a task, the taskflow object creates a node in the task graph and returns a task handle of type \doxylink{classtf_1_1_task}{tf\+::\+Task}. \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} task handle is a lightweight object that wraps up a particular node in a graph and provides a set of methods for you to assign different attributes to the task such as adding dependencies, naming, and assigning a new work.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 1:\ \mbox{\hyperlink{classtf_1_1_taskflow}{tf::Taskflow}}\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}};}
\DoxyCodeLine{\ 2:\ \mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}create\ a\ task\ A\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{\ 3:\ \mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ \mbox{\hyperlink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}create\ a\ task\ B\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{\ 4:}
\DoxyCodeLine{\ 5:\ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}.name(\textcolor{stringliteral}{"{}TaskA"{}});}
\DoxyCodeLine{\ 6:\ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}.work([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}reassign\ A\ to\ a\ new\ callable\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{\ 7:\ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}.precede(\mbox{\hyperlink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B}});}
\DoxyCodeLine{\ 8:}
\DoxyCodeLine{\ 9:\ std::cout\ <<\ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}.name()\ <<\ std::endl;\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ TaskA}}
\DoxyCodeLine{10:\ std::cout\ <<\ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}.num\_successors()\ <<\ std::endl;\ \ \textcolor{comment}{//\ 1}}
\DoxyCodeLine{11:\ std::cout\ <<\ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}.num\_predecessors()\ <<\ std::endl;\ \ \textcolor{comment}{//\ 0}}
\DoxyCodeLine{12:\ }
\DoxyCodeLine{13:\ std::cout\ <<\ \mbox{\hyperlink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B}}.num\_successors()\ <<\ std::endl;\ \ \textcolor{comment}{//\ 0}}
\DoxyCodeLine{14:\ std::cout\ <<\ \mbox{\hyperlink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B}}.num\_predecessors()\ <<\ std::endl;\ \ \textcolor{comment}{//\ 1}}

\end{DoxyCode}


Debrief\+: \begin{DoxyItemize}
\item Line 1 creates a taskflow object \item Lines 2-\/3 create two tasks \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} and \doxylink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B} \item Lines 5-\/6 assign a name and a work to task \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}, and add a precedence link to task \doxylink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B} \item Line 7 adds a dependency link from \doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} to \doxylink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B} \item Lines 9-\/14 dump the task attributes\end{DoxyItemize}
Taskflow uses general-\/purpose polymorphic function wrapper, std\+::function, to store and invoke a callable in a task. You need to follow its contract to create a task. For example, the callable to construct a task must be copyable, and thus the code below won\textquotesingle{}t compile\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([\mbox{\hyperlink{yyjson_8h_a26c622783fa717b24fe0bbd3e060f74a}{ptr}}=std::make\_unique<int>(1)]()\{}
\DoxyCodeLine{\ \ std::cout\ <<\ \textcolor{stringliteral}{"{}captured\ unique\ pointer\ is\ not\ copyable"{}};}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{_static_tasking_VisualizeATaskDependencyGraph}{}\doxysubsection{\texorpdfstring{Visualize a Task Dependency Graph}{Visualize a Task Dependency Graph}}\label{_static_tasking_VisualizeATaskDependencyGraph}
You can dump a taskflow to a DOT format and visualize the graph using free online tools such as \href{https://dreampuf.github.io/GraphvizOnline/}{\texttt{ Graphviz\+Online}} and \href{http://www.webgraphviz.com/}{\texttt{ Web\+Graphviz}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 1:\ \#include\ <\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}/\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.hpp>}
\DoxyCodeLine{\ 2:}
\DoxyCodeLine{\ 3:\ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{main-override-static_8c_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()\ \{}
\DoxyCodeLine{\ 4:\ }
\DoxyCodeLine{\ 5:\ \ \ \mbox{\hyperlink{classtf_1_1_taskflow}{tf::Taskflow}}\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}};}
\DoxyCodeLine{\ 6:}
\DoxyCodeLine{\ 7:\ \ \ \textcolor{comment}{//\ create\ a\ task\ dependency\ graph}}
\DoxyCodeLine{\ 8:\ \ \ \mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}Task\ A\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{\ 9:\ \ \ \mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ \mbox{\hyperlink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}Task\ B\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{10:\ \ \ tf::Task\ \mbox{\hyperlink{test__buffer__node_8cpp_ac4cf4b2ab929bd23951a8676eeac086b}{C}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}Task\ C\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{11:\ \ \ tf::Task\ \mbox{\hyperlink{_eigen_solver___eigen_solver___matrix_type_8cpp_a925331f9b6e4844293d36a8df2256d38}{D}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.emplace([]\ ()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}Task\ D\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{12:}
\DoxyCodeLine{13:\ \ \ \textcolor{comment}{//\ add\ dependency\ links}}
\DoxyCodeLine{14:\ \ \ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}.precede(\mbox{\hyperlink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B}});\ }
\DoxyCodeLine{15:\ \ \ \mbox{\hyperlink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A}}.precede(\mbox{\hyperlink{test__buffer__node_8cpp_ac4cf4b2ab929bd23951a8676eeac086b}{C}});}
\DoxyCodeLine{16:\ \ \ \mbox{\hyperlink{bench__gemm_8cpp_a37a83060ac796961b44991c836f083f7}{B}}.precede(\mbox{\hyperlink{_eigen_solver___eigen_solver___matrix_type_8cpp_a925331f9b6e4844293d36a8df2256d38}{D}});}
\DoxyCodeLine{17:\ \ \ \mbox{\hyperlink{test__buffer__node_8cpp_ac4cf4b2ab929bd23951a8676eeac086b}{C}}.precede(\mbox{\hyperlink{_eigen_solver___eigen_solver___matrix_type_8cpp_a925331f9b6e4844293d36a8df2256d38}{D}});}
\DoxyCodeLine{18:}
\DoxyCodeLine{19:\ \ \ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.dump(std::cout);}
\DoxyCodeLine{20:\ \}}

\end{DoxyCode}


Debrief\+: \begin{DoxyItemize}
\item Line 5 creates a taskflow object \item Lines 8-\/11 create four tasks \item Lines 14-\/17 add four task dependencies \item Line 19 dumps the taskflow in the DOT format through standard output\end{DoxyItemize}
\hypertarget{_static_tasking_ModifyTaskAttributes}{}\doxysubsection{\texorpdfstring{Modify Task Attributes}{Modify Task Attributes}}\label{_static_tasking_ModifyTaskAttributes}
This example demonstrates how to modify a task\textquotesingle{}s attributes using methods defined in the task handler.


\begin{DoxyCode}{0}
\DoxyCodeLine{\ 1:\ \#include\ <\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}/\mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.hpp>}
\DoxyCodeLine{\ 2:}
\DoxyCodeLine{\ 3:\ \textcolor{keywordtype}{int}\ \mbox{\hyperlink{main-override-static_8c_ae66f6b31b5ad750f1fe042a706a4e3d4}{main}}()\ \{}
\DoxyCodeLine{\ 4:}
\DoxyCodeLine{\ 5:\ \ \ \mbox{\hyperlink{classtf_1_1_taskflow}{tf::Taskflow}}\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}};}
\DoxyCodeLine{\ 6:}
\DoxyCodeLine{\ 7:\ \ \ std::vector<tf::Task>\ tasks\ =\ \{\ }
\DoxyCodeLine{\ 8:\ \ \ \ \ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.placeholder(),\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ create\ a\ task\ with\ no\ work}}
\DoxyCodeLine{\ 9:\ \ \ \ \ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.placeholder()\ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ create\ a\ task\ with\ no\ work}}
\DoxyCodeLine{10:\ \ \ \};}
\DoxyCodeLine{11:}
\DoxyCodeLine{12:\ \ \ tasks[0].name(\textcolor{stringliteral}{"{}This\ is\ Task\ 0"{}});}
\DoxyCodeLine{13:\ \ \ tasks[1].name(\textcolor{stringliteral}{"{}This\ is\ Task\ 1"{}});}
\DoxyCodeLine{14:\ \ \ tasks[0].precede(tasks[1]);}
\DoxyCodeLine{15:}
\DoxyCodeLine{16:\ \ \ \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}\ :\ tasks)\ \{\ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ print\ out\ each\ task's\ attributes}}
\DoxyCodeLine{17:\ \ \ \ \ std::cout\ <<\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}.name()\ <<\ \textcolor{stringliteral}{"{}:\ "{}}}
\DoxyCodeLine{18:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}num\_predecessors="{}}\ <<\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}.num\_predecessors()\ <<\ \textcolor{stringliteral}{"{},\ "{}}}
\DoxyCodeLine{19:\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ <<\ \textcolor{stringliteral}{"{}num\_successors="{}}\ <<\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}.num\_successors()\ <<\ \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{20:\ \ \ \}}
\DoxyCodeLine{21:}
\DoxyCodeLine{22:\ \ \ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.dump(std::cout);\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ dump\ the\ taskflow\ graph}}
\DoxyCodeLine{23:}
\DoxyCodeLine{24:\ \ \ tasks[0].work([]()\{\ std::cout\ <<\ \textcolor{stringliteral}{"{}got\ a\ new\ work!\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{25:\ \ \ tasks[1].work([]()\{\ std::cout\ <<\ \textcolor{stringliteral}{"{}got\ a\ new\ work!\(\backslash\)n"{}};\ \});}
\DoxyCodeLine{26:}
\DoxyCodeLine{27:\ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{28:\ \}}

\end{DoxyCode}


The output of this program looks like the following\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{This\ is\ Task\ 0:\ num\_predecessors=0,\ num\_successors=1}
\DoxyCodeLine{This\ is\ Task\ 1:\ num\_predecessors=1,\ num\_successors=0}
\DoxyCodeLine{digraph\ Taskflow\ \{}
\DoxyCodeLine{"{}This\ is\ Task\ 1"{};}
\DoxyCodeLine{"{}This\ is\ Task\ 0"{};}
\DoxyCodeLine{"{}This\ is\ Task\ 0"{}\ -\/>\ "{}This\ is\ Task\ 1"{};}
\DoxyCodeLine{\}}

\end{DoxyCode}


Debrief\+: \begin{DoxyItemize}
\item Line 5 creates a taskflow object \item Lines 7-\/10 create two placeholder tasks with no works and stores the corresponding task handles in a vector \item Lines 12-\/13 name the two tasks with human-\/readable strings \item Line 14 adds a dependency link from the first task to the second task \item Lines 16-\/20 print out the name of each task, the number of predecessors, and the number of successors \item Line 22 dumps the task dependency graph to a @\+Graph\+Viz\+Online format (dot) \item Lines 24-\/25 assign a new target to each task\end{DoxyItemize}
You can change the name and work of a task at anytime before running the graph. The later assignment overwrites the previous values.\hypertarget{_static_tasking_TraverseAdjacentTasks}{}\doxysubsection{\texorpdfstring{Traverse Adjacent Tasks}{Traverse Adjacent Tasks}}\label{_static_tasking_TraverseAdjacentTasks}
You can iterate the successor list and the predecessor list of a task by using \doxylink{classtf_1_1_task_aff13a503d4a3c994eb08cb6f22e1b427}{tf\+::\+Task\+::for\+\_\+each\+\_\+successor} and \doxylink{classtf_1_1_task_a31d8069d4c0b10b55e68d260c4d28c1f}{tf\+::\+Task\+::for\+\_\+each\+\_\+predecessor}, respectively. Each method takes a lambda and applies it to a successor or a predecessor being traversed.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ traverse\ all\ successors\ of\ my\_task}}
\DoxyCodeLine{my\_task.for\_each\_successor([\mbox{\hyperlink{main-override_8cpp_a1384e7608274313a9433fa573868557b}{s}}=0]\ (\mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ successor)\ \textcolor{keyword}{mutable}\ \{}
\DoxyCodeLine{\ \ std::cout\ <<\ \textcolor{stringliteral}{"{}successor\ "{}}\ <<\ \mbox{\hyperlink{main-override_8cpp_a1384e7608274313a9433fa573868557b}{s}}++\ <<\ \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ traverse\ all\ predecessors\ of\ my\_task}}
\DoxyCodeLine{my\_task.for\_each\_predecessor([\mbox{\hyperlink{ittnotify__static_8h_a5f135fd1e66a03efd5275434478e0d97}{d}}=0]\ (\mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ \mbox{\hyperlink{shortpath_8cpp_affcfa30b5f2b329189366a08dd6607cc}{predecessor}})\ \textcolor{keyword}{mutable}\ \{}
\DoxyCodeLine{\ \ std::cout\ <<\ \textcolor{stringliteral}{"{}predecessor\ "{}}\ <<\ \mbox{\hyperlink{ittnotify__static_8h_a5f135fd1e66a03efd5275434478e0d97}{d}}++\ <<\ \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{_static_tasking_AttachUserDataToATask}{}\doxysubsection{\texorpdfstring{Attach User Data to a Task}{Attach User Data to a Task}}\label{_static_tasking_AttachUserDataToATask}
You can attach custom data to a task using \doxylink{classtf_1_1_task_afd82ab6d6518d1142a72c4d2c97ff114}{tf\+::\+Task\+::data(void\texorpdfstring{$\ast$}{*})} and access it using \doxylink{classtf_1_1_task_afd82ab6d6518d1142a72c4d2c97ff114}{tf\+::\+Task\+::data()}. Each node in a taskflow is associated with a C-\/styled data pointer (i.\+e., {\ttfamily void\texorpdfstring{$\ast$}{*}}) you can use to point to user data and access it in the body of a task callable. The following example attaches an integer to a task and accesses that integer through capturing the data in the callable.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ my\_data\ =\ 5;}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_task}{tf::Task}}\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}\ =\ \mbox{\hyperlink{poisson_8hpp_aa56fe360bb0ae38e0082f49e394ff825}{taskflow}}.placeholder();}
\DoxyCodeLine{\mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}.data(\&my\_data)}
\DoxyCodeLine{\ \ \ \ .work([\mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}]()\{}
\DoxyCodeLine{\ \ \ \ \ \ \textcolor{keywordtype}{int}\ my\_date\ =\ *\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}*\textcolor{keyword}{>}(\mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}.data());}
\DoxyCodeLine{\ \ \ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}my\_data:\ "{}}\ <<\ my\_data;\ }
\DoxyCodeLine{\ \ \ \ \});}

\end{DoxyCode}


Notice that you need to create a placeholder task first before assigning it a work callable. Only this way can you capture that task in the lambda and access its attached data in the lambda body.

\begin{DoxyAttention}{注意}
It is your responsibility to ensure that the attached data stay alive during the execution of its task.
\end{DoxyAttention}
\hypertarget{_static_tasking_UnderstandTheLifetimeOfATask}{}\doxysubsection{\texorpdfstring{Understand the Lifetime of a Task}{Understand the Lifetime of a Task}}\label{_static_tasking_UnderstandTheLifetimeOfATask}
\doxylink{bench__gemm_8cpp_addc86e8508f14411ec98f521c520f875}{A} task lives with its graph and belongs to only a graph at a time, and is not destroyed until the graph gets cleaned up. The lifetime of a task refers to the user-\/given callable object, including captured values. As long as the graph is alive, all the associated tasks exist.

\begin{DoxyAttention}{注意}
It is your responsibility to keep tasks and graph alive during their execution.
\end{DoxyAttention}
\hypertarget{_static_tasking_MoveATaskflow}{}\doxysubsection{\texorpdfstring{Move a Taskflow}{Move a Taskflow}}\label{_static_tasking_MoveATaskflow}
You can construct or assign a taskflow from a {\itshape moved} taskflow. Moving a taskflow to another will result in transferring the underlying graph data structures from one to the other.


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_taskflow}{tf::Taskflow}}\ taskflow1,\ taskflow3;}
\DoxyCodeLine{}
\DoxyCodeLine{taskflow1.\mbox{\hyperlink{classtf_1_1_flow_builder_a60d7a666cab71ecfa3010b2efb0d6b57}{emplace}}([]()\{\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ move-\/construct\ taskflow2\ from\ taskflow1}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1_taskflow}{tf::Taskflow}}\ taskflow2(std::move(taskflow1));}
\DoxyCodeLine{assert(taskflow2.num\_tasks()\ ==\ 1\ \&\&\ taskflow1.\mbox{\hyperlink{classtf_1_1_taskflow_af4f03bca084deb5c2228ac8936d33649}{num\_tasks}}()\ ==\ 0);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ move-\/assign\ taskflow3\ to\ taskflow2}}
\DoxyCodeLine{taskflow3\ =\ std::move(taskflow2);}
\DoxyCodeLine{assert(taskflow3.\mbox{\hyperlink{classtf_1_1_taskflow_af4f03bca084deb5c2228ac8936d33649}{num\_tasks}}()\ ==\ 1\ \&\&\ taskflow2.num\_tasks()\ ==\ 0);}

\end{DoxyCode}


You can only move a taskflow to another while that taskflow is not being run by an executor. Moving a running taskflow can result in undefined behavior. Please see \doxysectlink{_execute_taskflow_ExecuteATaskflowWithTransferredOwnership}{Execute a Taskflow with Transferred Ownership}{1} for more details. 