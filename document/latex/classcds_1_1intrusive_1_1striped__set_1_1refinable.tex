\doxysection{cds\+::intrusive\+::striped\+\_\+set\+::refinable\texorpdfstring{$<$}{<} Recursive\+Lock, Back\+Off, Alloc \texorpdfstring{$>$}{>} 模板类 参考}
\hypertarget{classcds_1_1intrusive_1_1striped__set_1_1refinable}{}\label{classcds_1_1intrusive_1_1striped__set_1_1refinable}\index{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}}


Refinable concurrent access policy  




{\ttfamily \#include $<$striping\+\_\+policy.\+h$>$}

\doxysubsubsection*{Public 类型}
\begin{DoxyCompactItemize}
\item 
typedef Recursive\+Lock \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable_aff9dc43292efe8daae8d530663763973}{lock\+\_\+type}}
\begin{DoxyCompactList}\small\item\em lock type \end{DoxyCompactList}\item 
typedef Back\+Off \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable_a3db599dbb20b85b1f923fca68f5d1ee6}{back\+\_\+off}}
\begin{DoxyCompactList}\small\item\em back-\/off strategy used \end{DoxyCompactList}\item 
typedef Alloc \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable_a4639df54637b79d58b3aeabee211687b}{allocator\+\_\+type}}
\begin{DoxyCompactList}\small\item\em allocator type \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable_ac903631b15c14a84db4df0b8cf7d375a}{refinable}} (size\+\_\+t n\+Lock\+Count)
\begin{DoxyCompactList}\small\item\em Constructor \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable_a2f06489578a0d7712d93149c02dbbb7d}{lock\+\_\+count}} () const
\begin{DoxyCompactList}\small\item\em Returns lock array size \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable_ab0e9041fe3fa89c1fe882b8f828f2d34}{resize}} (size\+\_\+t n\+New\+Capacity)
\begin{DoxyCompactList}\small\item\em Resize for new capacity \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}
\subsubsection*{template$<$class Recursive\+Lock = std\+::recursive\+\_\+mutex, typename Back\+Off = cds\+::backoff\+::yield, class Alloc = CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR$>$\newline
class cds\+::intrusive\+::striped\+\_\+set\+::refinable$<$ Recursive\+Lock, Back\+Off, Alloc $>$}
Refinable concurrent access policy 

This is one of available \doxylink{structcds_1_1opt_1_1mutex__policy}{opt\+::mutex\+\_\+policy} option type for \doxylink{classcds_1_1intrusive_1_1_striped_set}{Striped\+Set}

Refining is like a striping technique (see \doxylink{classcds_1_1intrusive_1_1striped__set_1_1striping}{striped\+\_\+set\+::striping}) but it allows growing the size of lock array when resizing the hash table. So, the sizes of hash table and lock array are equal.

Template arguments\+:
\begin{DoxyItemize}
\item {\ttfamily Recursive\+Lock} -\/ the type of mutex. Reentrant (recursive) mutex is required. The default is {\ttfamily std\+::recursive\+\_\+mutex}. The mutex type should be default-\/constructible.
\item {\ttfamily Back\+Off} -\/ back-\/off strategy. Default is \doxylink{structcds_1_1backoff_1_1yield}{cds\+::backoff\+::yield}
\item {\ttfamily Alloc} -\/ allocator type used for lock array memory allocation. Default is {\ttfamily CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR}. 
\end{DoxyItemize}

\doxysubsection{成员类型定义说明}
\Hypertarget{classcds_1_1intrusive_1_1striped__set_1_1refinable_a4639df54637b79d58b3aeabee211687b}\index{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}!allocator\_type@{allocator\_type}}
\index{allocator\_type@{allocator\_type}!cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}}
\doxysubsubsection{\texorpdfstring{allocator\_type}{allocator\_type}}
{\footnotesize\ttfamily \label{classcds_1_1intrusive_1_1striped__set_1_1refinable_a4639df54637b79d58b3aeabee211687b} 
template$<$class Recursive\+Lock = std\+::recursive\+\_\+mutex, typename Back\+Off = cds\+::backoff\+::yield, class Alloc = CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR$>$ \\
typedef Alloc \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable}{cds\+::intrusive\+::striped\+\_\+set\+::refinable}}$<$ Recursive\+Lock, Back\+Off, Alloc $>$\+::allocator\+\_\+type}



allocator type 

\Hypertarget{classcds_1_1intrusive_1_1striped__set_1_1refinable_a3db599dbb20b85b1f923fca68f5d1ee6}\index{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}!back\_off@{back\_off}}
\index{back\_off@{back\_off}!cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}}
\doxysubsubsection{\texorpdfstring{back\_off}{back\_off}}
{\footnotesize\ttfamily \label{classcds_1_1intrusive_1_1striped__set_1_1refinable_a3db599dbb20b85b1f923fca68f5d1ee6} 
template$<$class Recursive\+Lock = std\+::recursive\+\_\+mutex, typename Back\+Off = cds\+::backoff\+::yield, class Alloc = CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR$>$ \\
typedef Back\+Off \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable}{cds\+::intrusive\+::striped\+\_\+set\+::refinable}}$<$ Recursive\+Lock, Back\+Off, Alloc $>$\+::back\+\_\+off}



back-\/off strategy used 

\Hypertarget{classcds_1_1intrusive_1_1striped__set_1_1refinable_aff9dc43292efe8daae8d530663763973}\index{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}!lock\_type@{lock\_type}}
\index{lock\_type@{lock\_type}!cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}}
\doxysubsubsection{\texorpdfstring{lock\_type}{lock\_type}}
{\footnotesize\ttfamily \label{classcds_1_1intrusive_1_1striped__set_1_1refinable_aff9dc43292efe8daae8d530663763973} 
template$<$class Recursive\+Lock = std\+::recursive\+\_\+mutex, typename Back\+Off = cds\+::backoff\+::yield, class Alloc = CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR$>$ \\
typedef Recursive\+Lock \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable}{cds\+::intrusive\+::striped\+\_\+set\+::refinable}}$<$ Recursive\+Lock, Back\+Off, Alloc $>$\+::lock\+\_\+type}



lock type 



\doxysubsection{构造及析构函数说明}
\Hypertarget{classcds_1_1intrusive_1_1striped__set_1_1refinable_ac903631b15c14a84db4df0b8cf7d375a}\index{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}!refinable@{refinable}}
\index{refinable@{refinable}!cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}}
\doxysubsubsection{\texorpdfstring{refinable()}{refinable()}}
{\footnotesize\ttfamily \label{classcds_1_1intrusive_1_1striped__set_1_1refinable_ac903631b15c14a84db4df0b8cf7d375a} 
template$<$class Recursive\+Lock = std\+::recursive\+\_\+mutex, typename Back\+Off = cds\+::backoff\+::yield, class Alloc = CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR$>$ \\
\mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable}{cds\+::intrusive\+::striped\+\_\+set\+::refinable}}$<$ Recursive\+Lock, Back\+Off, Alloc $>$\+::refinable (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n\+Lock\+Count}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructor 


\begin{DoxyParams}{参数}
{\em n\+Lock\+Count} & Initial size of lock array. Must be power of two. \\
\hline
\end{DoxyParams}


\doxysubsection{成员函数说明}
\Hypertarget{classcds_1_1intrusive_1_1striped__set_1_1refinable_a2f06489578a0d7712d93149c02dbbb7d}\index{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}!lock\_count@{lock\_count}}
\index{lock\_count@{lock\_count}!cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}}
\doxysubsubsection{\texorpdfstring{lock\_count()}{lock\_count()}}
{\footnotesize\ttfamily \label{classcds_1_1intrusive_1_1striped__set_1_1refinable_a2f06489578a0d7712d93149c02dbbb7d} 
template$<$class Recursive\+Lock = std\+::recursive\+\_\+mutex, typename Back\+Off = cds\+::backoff\+::yield, class Alloc = CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR$>$ \\
size\+\_\+t \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable}{cds\+::intrusive\+::striped\+\_\+set\+::refinable}}$<$ Recursive\+Lock, Back\+Off, Alloc $>$\+::lock\+\_\+count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns lock array size 

Lock array size is not a constant for {\ttfamily refinable} policy and can be changed when the set is resized. \Hypertarget{classcds_1_1intrusive_1_1striped__set_1_1refinable_ab0e9041fe3fa89c1fe882b8f828f2d34}\index{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}!resize@{resize}}
\index{resize@{resize}!cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$@{cds::intrusive::striped\_set::refinable$<$ RecursiveLock, BackOff, Alloc $>$}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}}
{\footnotesize\ttfamily \label{classcds_1_1intrusive_1_1striped__set_1_1refinable_ab0e9041fe3fa89c1fe882b8f828f2d34} 
template$<$class Recursive\+Lock = std\+::recursive\+\_\+mutex, typename Back\+Off = cds\+::backoff\+::yield, class Alloc = CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable}{cds\+::intrusive\+::striped\+\_\+set\+::refinable}}$<$ Recursive\+Lock, Back\+Off, Alloc $>$\+::resize (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n\+New\+Capacity}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Resize for new capacity 



该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
external/libcds/cds/intrusive/striped\+\_\+set/\mbox{\hyperlink{striping__policy_8h}{striping\+\_\+policy.\+h}}\end{DoxyCompactItemize}
