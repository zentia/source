\doxysection{runtime/\+EASTL/packages/mimalloc 目录参考}
\hypertarget{dir_691f6eadf0c45e432f8d026d7affe530}{}\label{dir_691f6eadf0c45e432f8d026d7affe530}\index{runtime/EASTL/packages/mimalloc 目录参考@{runtime/EASTL/packages/mimalloc 目录参考}}
mimalloc 的目录依赖关系图
% FIG 0
\doxysubsubsection*{目录}
\begin{DoxyCompactItemize}
\item 
目录 \mbox{\hyperlink{dir_163d6e220634c8ea619389189518aef1}{bin}}
\item 
目录 \mbox{\hyperlink{dir_4ecfc90e9b009d3573b0e76123d7f91a}{contrib}}
\item 
目录 \mbox{\hyperlink{dir_a52a0021adbdb0025e0d70c95213e949}{doc}}
\item 
目录 \mbox{\hyperlink{dir_a8c403b256360842043cc117c4dd8b14}{include}}
\item 
目录 \mbox{\hyperlink{dir_fedc5c195628998e7d79c31476661589}{src}}
\item 
目录 \mbox{\hyperlink{dir_9f952bf273c4e3f573c022c584f1228c}{test}}
\end{DoxyCompactItemize}


\doxysubsection{详细描述}


\href{https://dev.azure.com/Daan0324/mimalloc/_build?definitionId=1&_a=summary}{\texttt{ }}\hypertarget{readme.md_autotoc_md30}{}\doxysubsection{\texorpdfstring{mimalloc}{mimalloc}}\label{readme.md_autotoc_md30}
~

mimalloc (pronounced "{}me-\/malloc"{}) is a general purpose allocator with excellent performance characteristics. Initially developed by Daan Leijen for the runtime systems of the \href{https://koka-lang.github.io}{\texttt{ Koka}} and \href{https://github.com/leanprover/lean}{\texttt{ Lean}} languages.

Latest release \+: {\ttfamily v3.\+0.\+2} (beta) (2025-\/03-\/06). ~\newline
 Latest v2 release\+: {\ttfamily v2.\+2.\+2} (2025-\/03-\/06). ~\newline
 Latest v1 release\+: {\ttfamily v1.\+9.\+2} (2024-\/03-\/06).

mimalloc is a drop-\/in replacement for {\ttfamily malloc} and can be used in other programs without code changes, for example, on dynamically linked ELF-\/based systems (Linux, BSD, etc.) you can use it as\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{>\ LD\_PRELOAD=/usr/lib/libmimalloc.so\ \ myprogram}

\end{DoxyCode}
 It also includes a way to dynamically override the default allocator in Windows. Notable aspects of the design include\+:


\begin{DoxyItemize}
\item {\bfseries{small and consistent}}\+: the library is about 10k LOC using simple and consistent data structures. This makes it very suitable to integrate and adapt in other projects. For runtime systems it provides hooks for a monotonic {\itshape heartbeat} and deferred freeing (for bounded worst-\/case times with reference counting). Partly due to its simplicity, mimalloc has been ported to many systems (Windows, mac\+OS, Linux, WASM, various BSD\textquotesingle{}s, Haiku, MUSL, etc) and has excellent support for dynamic overriding. At the same time, it is an industrial strength allocator that runs (very) large scale distributed services on thousands of machines with excellent worst case latencies.
\item {\bfseries{free list sharding}}\+: instead of one big free list (per size class) we have many smaller lists per "{}mimalloc page"{} which reduces fragmentation and increases locality -- things that are allocated close in time get allocated close in memory. (A mimalloc page contains blocks of one size class and is usually 64KiB on a 64-\/bit system).
\item {\bfseries{free list multi-\/sharding}}\+: the big idea! Not only do we shard the free list per mimalloc page, but for each page we have multiple free lists. In particular, there is one list for thread-\/local {\ttfamily free} operations, and another one for concurrent {\ttfamily free} operations. Free-\/ing from another thread can now be a single CAS without needing sophisticated coordination between threads. Since there will be thousands of separate free lists, contention is naturally distributed over the heap, and the chance of contending on a single location will be low -- this is quite similar to randomized algorithms like skip lists where adding a random oracle removes the need for a more complex algorithm.
\item {\bfseries{eager page purging}}\+: when a "{}page"{} becomes empty (with increased chance due to free list sharding) the memory is marked to the OS as unused (reset or decommitted) reducing (real) memory pressure and fragmentation, especially in long running programs.
\item {\bfseries{secure}}\+: {\itshape mimalloc} can be built in secure mode, adding guard pages, randomized allocation, encrypted free lists, etc. to protect against various heap vulnerabilities. The performance penalty is usually around 10\% on average over our benchmarks.
\item {\bfseries{first-\/class heaps}}\+: efficiently create and use multiple heaps to allocate across different regions. A heap can be destroyed at once instead of deallocating each object separately.
\item {\bfseries{bounded}}\+: it does not suffer from {\itshape blowup} \mbox{[}1\mbox{]}, has bounded worst-\/case allocation times ({\itshape wcat}) (upto OS primitives), bounded space overhead (\texorpdfstring{$\sim$}{\string~}0.2\% meta-\/data, with low internal fragmentation), and has no internal points of contention using only atomic operations.
\item {\bfseries{fast}}\+: In our benchmarks (see below), {\itshape mimalloc} outperforms other leading allocators ({\itshape jemalloc}, {\itshape tcmalloc}, {\itshape Hoard}, etc), and often uses less memory. A nice property is that it does consistently well over a wide range of benchmarks. There is also good huge OS page support for larger server programs.
\end{DoxyItemize}

The \href{https://microsoft.github.io/mimalloc}{\texttt{ documentation}} gives a full overview of the API. You can read more on the design of {\itshape mimalloc} in the \href{https://www.microsoft.com/en-us/research/publication/mimalloc-free-list-sharding-in-action}{\texttt{ technical report}} which also has detailed benchmark results.

Enjoy!\hypertarget{readme.md_autotoc_md31}{}\doxysubsubsubsection{\texorpdfstring{Branches}{Branches}}\label{readme.md_autotoc_md31}

\begin{DoxyItemize}
\item {\ttfamily master}\+: latest stable release (still based on {\ttfamily dev2}).
\item {\ttfamily dev}\+: development branch for mimalloc v1. Use this branch for submitting PR\textquotesingle{}s.
\item {\ttfamily dev2}\+: development branch for mimalloc v2. This branch is downstream of {\ttfamily dev} (and is essentially equal to {\ttfamily dev} except for {\ttfamily src/segment.\+c}). Uses larger sliced segments to manage mimalloc pages that can reduce fragmentation.
\item {\ttfamily dev3}\+: development branch for mimalloc v3-\/beta. This branch is downstream of {\ttfamily dev}. This version simplifies the lock-\/free ownership of previous versions, has no thread-\/local segments any more. This improves sharing of memory between threads, and on certain large workloads may use less memory with less fragmentation.
\end{DoxyItemize}\hypertarget{readme.md_autotoc_md32}{}\doxysubsubsubsection{\texorpdfstring{Releases}{Releases}}\label{readme.md_autotoc_md32}

\begin{DoxyItemize}
\item 2025-\/03-\/06, {\ttfamily v1.\+9.\+2}, {\ttfamily v2.\+2.\+2}, {\ttfamily v3.\+0.\+2-\/beta}\+: Various small bug and build fixes. Add {\ttfamily mi\+\_\+options\+\_\+print}, {\ttfamily mi\+\_\+arenas\+\_\+print}, and the experimental {\ttfamily mi\+\_\+stat\+\_\+get} and {\ttfamily mi\+\_\+stat\+\_\+get\+\_\+json}. Add {\ttfamily mi\+\_\+thread\+\_\+set\+\_\+in\+\_\+threadpool} and {\ttfamily mi\+\_\+heap\+\_\+set\+\_\+numa\+\_\+affinity} (v3 only). Add vcpkg portfile. Upgrade mimalloc-\/redirect to v1.\+3.\+2. {\ttfamily MI\+\_\+\+OPT\+\_\+\+ARCH} is off by default now but still assumes armv8.\+1-\/a on arm64 for fast atomic operations. Add QNX support.
\item 2025-\/01-\/03, {\ttfamily v1.\+8.\+9}, {\ttfamily v2.\+1.\+9}, {\ttfamily v3.\+0.\+1-\/alpha}\+: Interim release. Support Windows arm64. New guarded build that can place OS guard pages behind objects to catch buffer overflows as they occur. Many small fixes\+: build on Windows arm64, cygwin, riscV, and dragonfly; fix Windows static library initialization to account for thread local destructors (in Rust/\+C++); mac\+OS tag change; mac\+OS TLS slot fix; improve stats; consistent {\ttfamily mimalloc.\+dll} on Windows (instead of {\ttfamily mimalloc-\/override.\+dll}); fix mimalloc-\/redirect on Win11 H2; add 0-\/byte to canary; upstream CPython fixes; reduce .bss size; allow fixed TLS slot on Windows for improved performance.
\item 2024-\/05-\/21, {\ttfamily v1.\+8.\+7}, {\ttfamily v2.\+1.\+7}\+: Fix build issues on less common platforms. Started upstreaming patches from the CPython \href{https://github.com/python/cpython/issues/113141\#issuecomment-2119255217}{\texttt{ integration}}. Upstream {\ttfamily vcpkg} patches.
\item 2024-\/05-\/13, {\ttfamily v1.\+8.\+6}, {\ttfamily v2.\+1.\+6}\+: Fix build errors on various (older) platforms. Refactored aligned allocation.
\item 2024-\/04-\/22, {\ttfamily v1.\+8.\+4}, {\ttfamily v2.\+1.\+4}\+: Fixes various bugs and build issues. Add {\ttfamily MI\+\_\+\+LIBC\+\_\+\+MUSL} cmake flag for musl builds. Free-\/ing code is refactored into a separate module ({\ttfamily \doxylink{free_8c}{free.\+c}}). Mimalloc page info is simplified with the block size directly available (and new {\ttfamily block\+\_\+size\+\_\+shift} to improve aligned block free-\/ing). New approach to collection of abandoned segments\+: When a thread terminates the segments it owns are abandoned (containing still live objects) and these can be reclaimed by other threads. We no longer use a list of abandoned segments but this is now done using bitmaps in arena\textquotesingle{}s which is more concurrent (and more aggressive). Abandoned memory can now also be reclaimed if a thread frees an object in an abandoned page (which can be disabled using {\ttfamily mi\+\_\+option\+\_\+abandoned\+\_\+reclaim\+\_\+on\+\_\+free}). The option {\ttfamily mi\+\_\+option\+\_\+max\+\_\+segment\+\_\+reclaim} gives a maximum percentage of abandoned segments that can be reclaimed per try (=10\%).
\item 2023-\/04-\/24, {\ttfamily v1.\+8.\+2}, {\ttfamily v2.\+1.\+2}\+: Fixes build issues on free\+BSD, musl, and C17 (UE 5.\+1.\+1). Reduce code size/complexity by removing regions and segment-\/cache\textquotesingle{}s and only use arenas with improved memory purging -- this may improve memory usage as well for larger services. Renamed options for consistency. Improved Valgrind and ASAN checking.
\item 2023-\/04-\/03, {\ttfamily v1.\+8.\+1}, {\ttfamily v2.\+1.\+1}\+: Fixes build issues on some platforms.
\item 2023-\/03-\/29, {\ttfamily v1.\+8.\+0}, {\ttfamily v2.\+1.\+0}\+: Improved support dynamic overriding on Windows 11. Improved tracing precision with asan and Valgrind, and added Windows event tracing ETW (contributed by Xinglong He). Created an OS abstraction layer to make it easier to port and separate platform dependent code (in {\ttfamily src/prim}). Fixed C++ STL compilation on older Microsoft C++ compilers, and various small bug fixes.
\item 2022-\/12-\/23, {\ttfamily v1.\+7.\+9}, {\ttfamily v2.\+0.\+9}\+: Supports building with asan and improved Valgrind support. Support arbitrary large alignments (in particular for {\ttfamily std\+::pmr} pools). Added C++ STL allocators attached to a specific heap (thanks @vmarkovtsev). Heap walks now visit all object (including huge objects). Support Windows nano server containers (by Johannes Schindelin,@dscho). Various small bug fixes.
\item 2022-\/11-\/03, {\ttfamily v1.\+7.\+7}, {\ttfamily v2.\+0.\+7}\+: Initial support for Valgrind for leak testing and heap block overflow detection. Initial support for attaching heaps to a specific memory area (only in v2). Fix {\ttfamily realloc} behavior for zero size blocks, remove restriction to integral multiple of the alignment in {\ttfamily alloc\+\_\+align}, improved aligned allocation performance, reduced contention with many threads on few processors (thank you @dposluns!), vs2022 support, support {\ttfamily pkg-\/config}, .
\item 2022-\/04-\/14, {\ttfamily v1.\+7.\+6}, {\ttfamily v2.\+0.\+6}\+: fix fallback path for aligned OS allocation on Windows, improve Windows aligned allocation even when compiling with older SDK\textquotesingle{}s, fix dynamic overriding on mac\+OS Monterey, fix MSVC C++ dynamic overriding, fix warnings under Clang 14, improve performance if many OS threads are created and destroyed, fix statistics for large object allocations, using MIMALLOC\+\_\+\+VERBOSE=1 has no maximum on the number of error messages, various small fixes.
\item 2022-\/02-\/14, {\ttfamily v1.\+7.\+5}, {\ttfamily v2.\+0.\+5} (alpha)\+: fix malloc override on Windows 11, fix compilation with musl, potentially reduced committed memory, add {\ttfamily bin/minject} for Windows, improved wasm support, faster aligned allocation, various small fixes.
\item Older release notes
\end{DoxyItemize}

Special thanks to\+:


\begin{DoxyItemize}
\item \href{https://devnexen.blogspot.com/}{\texttt{ David Carlier}} (@devnexen) for his many contributions, and making mimalloc work better on many less common operating systems, like Haiku, Dragonfly, etc.
\item Mary Feofanova (@mary3000), Evgeniy Moiseenko, and Manuel Pöter (@mpoeter) for making mimalloc TSAN checkable, and finding memory model bugs using the \href{https://plv.mpi-sws.org/genmc/}{\texttt{ gen\+MC}} model checker.
\item Weipeng Liu (@pongba), Zhuowei Li, Junhua Wang, and Jakub Szymanski, for their early support of mimalloc and deployment at large scale services, leading to many improvements in the mimalloc algorithms for large workloads.
\item Jason Gibson (@jasongibson) for exhaustive testing on large scale workloads and server environments, and finding complex bugs in (early versions of) {\ttfamily mimalloc}.
\item Manuel Pöter (@mpoeter) and Sam Gross(@colesbury) for finding an ABA concurrency issue in abandoned segment reclamation. Sam also created the \href{https://github.com/colesbury/nogil}{\texttt{ no GIL}} Python fork which uses mimalloc internally.
\end{DoxyItemize}\hypertarget{readme.md_autotoc_md33}{}\doxysubsubsubsection{\texorpdfstring{Usage}{Usage}}\label{readme.md_autotoc_md33}
mimalloc is used in various large scale low-\/latency services and programs, for example\+:

\href{https://www.bing.com}{\texttt{ }} \href{https://azure.microsoft.com/}{\texttt{ }} \href{https://deathstrandingpc.505games.com}{\texttt{ }} \href{https://docs.unrealengine.com/4.26/en-US/WhatsNew/Builds/ReleaseNotes/4_25/}{\texttt{ }} \href{https://cab.spbu.ru/software/spades/}{\texttt{ }}\hypertarget{readme.md_autotoc_md34}{}\doxysubsection{\texorpdfstring{Building}{Building}}\label{readme.md_autotoc_md34}
\hypertarget{readme.md_autotoc_md35}{}\doxysubsubsection{\texorpdfstring{Windows}{Windows}}\label{readme.md_autotoc_md35}
Open {\ttfamily ide/vs2022/mimalloc.\+sln} in Visual Studio 2022 and build. The {\ttfamily mimalloc-\/lib} project builds a static library (in {\ttfamily out/msvc-\/x64}), while the {\ttfamily mimalloc-\/override-\/dll} project builds DLL for overriding malloc in the entire program.\hypertarget{readme.md_autotoc_md36}{}\doxysubsubsection{\texorpdfstring{Linux, mac\+OS, BSD, etc.}{Linux, mac\+OS, BSD, etc.}}\label{readme.md_autotoc_md36}
We use \href{https://cmake.org}{\texttt{ {\ttfamily cmake}}} as the build system\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ mkdir\ -\/p\ out/release}
\DoxyCodeLine{>\ cd\ out/release}
\DoxyCodeLine{>\ cmake\ ../..}
\DoxyCodeLine{>\ make}

\end{DoxyCode}
 This builds the library as a shared (dynamic) library ({\ttfamily .so} or {\ttfamily .dylib}), a static library ({\ttfamily .a}), and as a single object file ({\ttfamily .o}).

{\ttfamily \texorpdfstring{$>$}{>} sudo make install} (install the library and header files in {\ttfamily /usr/local/lib} and {\ttfamily /usr/local/include})

You can build the debug version which does many internal checks and maintains detailed statistics as\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ mkdir\ -\/p\ out/debug}
\DoxyCodeLine{>\ cd\ out/debug}
\DoxyCodeLine{>\ cmake\ -\/DCMAKE\_BUILD\_TYPE=Debug\ ../..}
\DoxyCodeLine{>\ make}

\end{DoxyCode}


This will name the shared library as {\ttfamily libmimalloc-\/debug.\+so}.

Finally, you can build a {\itshape secure} version that uses guard pages, encrypted free lists, etc., as\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ mkdir\ -\/p\ out/secure}
\DoxyCodeLine{>\ cd\ out/secure}
\DoxyCodeLine{>\ cmake\ -\/DMI\_SECURE=ON\ ../..}
\DoxyCodeLine{>\ make}

\end{DoxyCode}


This will name the shared library as {\ttfamily libmimalloc-\/secure.\+so}. Use {\ttfamily cmake ../.. -\/LH} to see all the available build options.

The examples use the default compiler. If you like to use another, use\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ CC=clang\ CXX=clang++\ cmake\ ../..}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md37}{}\doxysubsubsection{\texorpdfstring{Cmake with Visual Studio}{Cmake with Visual Studio}}\label{readme.md_autotoc_md37}
You can also use cmake on Windows. Open a Visual Studio 2022 development prompt and invoke {\ttfamily cmake} with the right \href{https://cmake.org/cmake/help/latest/generator/Visual\%20Studio\%2017\%202022.html}{\texttt{ generator}} and architecture, like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ cmake\ ..\(\backslash\)..\ -\/G\ "{}Visual\ Studio\ 17\ 2022"{}\ -\/A\ x64\ -\/DMI\_OVERRIDE=ON}

\end{DoxyCode}


The cmake build type is specified when actually building, for example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ cmake\ -\/-\/build\ .\ -\/-\/config=Release}

\end{DoxyCode}


You can also install the \href{https://learn.microsoft.com/en-us/cpp/build/clang-support-msbuild?view=msvc-170\#install-1}{\texttt{ LLVM toolset}} on Windows to build with the {\ttfamily clang-\/cl} compiler directly\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ cmake\ ../..\ -\/G\ "{}Visual\ Studio\ 17\ 2022"{}\ -\/T\ ClangCl}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md38}{}\doxysubsubsection{\texorpdfstring{Single Source}{Single Source}}\label{readme.md_autotoc_md38}
You can also directly build the single {\ttfamily \doxylink{static_8c}{src/static.\+c}} file as part of your project without needing {\ttfamily cmake} at all. Make sure to also add the mimalloc {\ttfamily include} directory to the include path.\hypertarget{readme.md_autotoc_md39}{}\doxysubsection{\texorpdfstring{Using the Library}{Using the Library}}\label{readme.md_autotoc_md39}
The preferred usage is including {\ttfamily \texorpdfstring{$<$}{<}\doxylink{mimalloc_8h}{mimalloc.\+h}\texorpdfstring{$>$}{>}}, linking with the shared-\/ or static library, and using the {\ttfamily mi\+\_\+malloc} API exclusively for allocation. For example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{>\ gcc\ -\/o\ myprogram\ -\/lmimalloc\ myfile.c}

\end{DoxyCode}


mimalloc uses only safe OS calls ({\ttfamily mmap} and {\ttfamily Virtual\+Alloc}) and can co-\/exist with other allocators linked to the same program. If you use {\ttfamily cmake}, you can simply use\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{find\_package(mimalloc\ 1.8\ REQUIRED)}

\end{DoxyCode}
 in your {\ttfamily CMake\+Lists.\+txt} to find a locally installed mimalloc. Then use either\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{target\_link\_libraries(myapp\ PUBLIC\ mimalloc)}

\end{DoxyCode}
 to link with the shared (dynamic) library, or\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{target\_link\_libraries(myapp\ PUBLIC\ mimalloc-\/static)}

\end{DoxyCode}
 to link with the static library. See {\ttfamily test\textbackslash{}CMake\+Lists.\+txt} for an example.

For best performance in C++ programs, it is also recommended to override the global {\ttfamily new} and {\ttfamily delete} operators. For convenience, mimalloc provides \href{include/mimalloc-new-delete.h}{\texttt{ {\ttfamily mimalloc-\/new-\/delete.\+h}}} which does this for you -- just include it in a single(!) source file in your project. In C++, mimalloc also provides the {\ttfamily \doxylink{structmi__stl__allocator}{mi\+\_\+stl\+\_\+allocator}} struct which implements the {\ttfamily std\+::allocator} interface.

You can pass environment variables to print verbose messages ({\ttfamily MIMALLOC\+\_\+\+VERBOSE=1}) and statistics ({\ttfamily MIMALLOC\+\_\+\+SHOW\+\_\+\+STATS=1}) (in the debug version)\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{>\ env\ MIMALLOC\_SHOW\_STATS=1\ ./cfrac\ 175451865205073170563711388363}
\DoxyCodeLine{}
\DoxyCodeLine{175451865205073170563711388363\ =\ 374456281610909315237213\ *\ 468551}
\DoxyCodeLine{}
\DoxyCodeLine{heap\ stats:\ \ \ \ \ peak\ \ \ \ \ \ total\ \ \ \ \ \ freed\ \ \ \ \ \ \ unit}
\DoxyCodeLine{normal\ \ \ 2:\ \ \ \ 16.4\ kb\ \ \ \ 17.5\ mb\ \ \ \ 17.5\ mb\ \ \ \ \ \ 16\ b\ \ \ ok}
\DoxyCodeLine{normal\ \ \ 3:\ \ \ \ 16.3\ kb\ \ \ \ 15.2\ mb\ \ \ \ 15.2\ mb\ \ \ \ \ \ 24\ b\ \ \ ok}
\DoxyCodeLine{normal\ \ \ 4:\ \ \ \ \ \ 64\ b\ \ \ \ \ \ 4.6\ kb\ \ \ \ \ 4.6\ kb\ \ \ \ \ \ 32\ b\ \ \ ok}
\DoxyCodeLine{normal\ \ \ 5:\ \ \ \ \ \ 80\ b\ \ \ \ 118.4\ kb\ \ \ 118.4\ kb\ \ \ \ \ \ 40\ b\ \ \ ok}
\DoxyCodeLine{normal\ \ \ 6:\ \ \ \ \ \ 48\ b\ \ \ \ \ \ \ 48\ b\ \ \ \ \ \ \ 48\ b\ \ \ \ \ \ \ 48\ b\ \ \ ok}
\DoxyCodeLine{normal\ \ 17:\ \ \ \ \ 960\ b\ \ \ \ \ \ 960\ b\ \ \ \ \ \ 960\ b\ \ \ \ \ \ 320\ b\ \ \ ok}
\DoxyCodeLine{}
\DoxyCodeLine{heap\ stats:\ \ \ \ \ peak\ \ \ \ \ \ total\ \ \ \ \ \ freed\ \ \ \ \ \ \ unit}
\DoxyCodeLine{\ \ \ \ normal:\ \ \ \ 33.9\ kb\ \ \ \ 32.8\ mb\ \ \ \ 32.8\ mb\ \ \ \ \ \ \ 1\ b\ \ \ ok}
\DoxyCodeLine{\ \ \ \ \ \ huge:\ \ \ \ \ \ \ 0\ b\ \ \ \ \ \ \ \ 0\ b\ \ \ \ \ \ \ \ 0\ b\ \ \ \ \ \ \ \ 1\ b\ \ \ ok}
\DoxyCodeLine{\ \ \ \ \ total:\ \ \ \ 33.9\ kb\ \ \ \ 32.8\ mb\ \ \ \ 32.8\ mb\ \ \ \ \ \ \ 1\ b\ \ \ ok}
\DoxyCodeLine{malloc\ requested:\ \ \ \ \ \ \ \ \ 32.8\ mb}
\DoxyCodeLine{}
\DoxyCodeLine{\ committed:\ \ \ \ 58.2\ kb\ \ \ \ 58.2\ kb\ \ \ \ 58.2\ kb\ \ \ \ \ \ \ 1\ b\ \ \ ok}
\DoxyCodeLine{\ \ reserved:\ \ \ \ \ 2.0\ mb\ \ \ \ \ 2.0\ mb\ \ \ \ \ 2.0\ mb\ \ \ \ \ \ \ 1\ b\ \ \ ok}
\DoxyCodeLine{\ \ \ \ \ reset:\ \ \ \ \ \ \ 0\ b\ \ \ \ \ \ \ \ 0\ b\ \ \ \ \ \ \ \ 0\ b\ \ \ \ \ \ \ \ 1\ b\ \ \ ok}
\DoxyCodeLine{\ \ segments:\ \ \ \ \ \ \ 1\ \ \ \ \ \ \ \ \ \ 1\ \ \ \ \ \ \ \ \ \ 1}
\DoxyCodeLine{-\/abandoned:\ \ \ \ \ \ \ 0}
\DoxyCodeLine{\ \ \ \ \ pages:\ \ \ \ \ \ \ 6\ \ \ \ \ \ \ \ \ \ 6\ \ \ \ \ \ \ \ \ \ 6}
\DoxyCodeLine{-\/abandoned:\ \ \ \ \ \ \ 0}
\DoxyCodeLine{\ \ \ \ \ mmaps:\ \ \ \ \ \ \ 3}
\DoxyCodeLine{\ mmap\ fast:\ \ \ \ \ \ \ 0}
\DoxyCodeLine{\ mmap\ slow:\ \ \ \ \ \ \ 1}
\DoxyCodeLine{\ \ \ threads:\ \ \ \ \ \ \ 0}
\DoxyCodeLine{\ \ \ elapsed:\ \ \ \ \ 2.022s}
\DoxyCodeLine{\ \ \ process:\ user:\ 1.781s,\ system:\ 0.016s,\ faults:\ 756,\ reclaims:\ 0,\ rss:\ 2.7\ mb}

\end{DoxyCode}


The above model of using the {\ttfamily mi\+\_\+} prefixed API is not always possible though in existing programs that already use the standard malloc interface, and another option is to override the standard malloc interface completely and redirect all calls to the {\itshape mimalloc} library instead .\hypertarget{readme.md_autotoc_md40}{}\doxysubsubsection{\texorpdfstring{Environment Options}{Environment Options}}\label{readme.md_autotoc_md40}
You can set further options either programmatically (using \href{https://microsoft.github.io/mimalloc/group__options.html}{\texttt{ {\ttfamily mi\+\_\+option\+\_\+set}}}), or via environment variables\+:


\begin{DoxyItemize}
\item {\ttfamily MIMALLOC\+\_\+\+SHOW\+\_\+\+STATS=1}\+: show statistics when the program terminates.
\item {\ttfamily MIMALLOC\+\_\+\+VERBOSE=1}\+: show verbose messages.
\item {\ttfamily MIMALLOC\+\_\+\+SHOW\+\_\+\+ERRORS=1}\+: show error and warning messages.
\end{DoxyItemize}

Advanced options\+:


\begin{DoxyItemize}
\item {\ttfamily MIMALLOC\+\_\+\+ARENA\+\_\+\+EAGER\+\_\+\+COMMIT=2}\+: turns on eager commit for the large arenas (usually 1GiB) from which mimalloc allocates segments and pages. Set this to 2 (default) to only enable this on overcommit systems (e.\+g. Linux). Set this to 1 to enable explicitly on other systems as well (like Windows or mac\+OS) which may improve performance (as the whole arena is committed at once). Note that eager commit only increases the commit but not the actual the peak resident set (rss) so it is generally ok to enable this.
\item {\ttfamily MIMALLOC\+\_\+\+PURGE\+\_\+\+DELAY=N}\+: the delay in {\ttfamily N} milli-\/seconds (by default {\ttfamily 10}) after which mimalloc will purge OS pages that are not in use. This signals to the OS that the underlying physical memory can be reused which can reduce memory fragmentation especially in long running (server) programs. Setting {\ttfamily N} to {\ttfamily 0} purges immediately when a page becomes unused which can improve memory usage but also decreases performance. Setting {\ttfamily N} to a higher value like {\ttfamily 100} can improve performance (sometimes by a lot) at the cost of potentially using more memory at times. Setting it to {\ttfamily -\/1} disables purging completely.
\item {\ttfamily MIMALLOC\+\_\+\+PURGE\+\_\+\+DECOMMITS=1}\+: By default "{}purging"{} memory means unused memory is decommitted ({\ttfamily MEM\+\_\+\+DECOMMIT} on Windows, {\ttfamily MADV\+\_\+\+DONTNEED} (which decresease rss immediately) on {\ttfamily mmap} systems). Set this to 0 to instead "{}reset"{} unused memory on a purge ({\ttfamily MEM\+\_\+\+RESET} on Windows, generally {\ttfamily MADV\+\_\+\+FREE} (which does not decrease rss immediately) on {\ttfamily mmap} systems). Mimalloc generally does not "{}free"{} OS memory but only "{}purges"{} OS memory, in other words, it tries to keep virtual address ranges and decommits within those ranges (to make the underlying physical memory available to other processes).
\end{DoxyItemize}

Further options for large workloads and services\+:


\begin{DoxyItemize}
\item {\ttfamily MIMALLOC\+\_\+\+USE\+\_\+\+NUMA\+\_\+\+NODES=N}\+: pretend there are at most {\ttfamily N} NUMA nodes. If not set, the actual NUMA nodes are detected at runtime. Setting {\ttfamily N} to 1 may avoid problems in some virtual environments. Also, setting it to a lower number than the actual NUMA nodes is fine and will only cause threads to potentially allocate more memory across actual NUMA nodes (but this can happen in any case as NUMA local allocation is always a best effort but not guaranteed).
\item {\ttfamily MIMALLOC\+\_\+\+ALLOW\+\_\+\+LARGE\+\_\+\+OS\+\_\+\+PAGES=0}\+: Set to 1 to use large OS pages (2 or 4MiB) when available; for some workloads this can significantly improve performance. When this option is disabled (default), it also disables transparent huge pages (THP) for the process (on Linux and Android). On Linux the default setting is 2 -- this enables the use of large pages through THP only. Use {\ttfamily MIMALLOC\+\_\+\+VERBOSE} to check if the large OS pages are enabled -- usually one needs to explicitly give permissions for large OS pages (as on \href{https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/enable-the-lock-pages-in-memory-option-windows?view=sql-server-2017}{\texttt{ Windows}} and \href{https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/tuning_and_optimizing_red_hat_enterprise_linux_for_oracle_9i_and_10g_databases/sect-oracle_9i_and_10g_tuning_guide-large_memory_optimization_big_pages_and_huge_pages-configuring_huge_pages_in_red_hat_enterprise_linux_4_or_5}{\texttt{ Linux}}). However, sometimes the OS is very slow to reserve contiguous physical memory for large OS pages so use with care on systems that can have fragmented memory (for that reason, we generally recommend to use {\ttfamily MIMALLOC\+\_\+\+RESERVE\+\_\+\+HUGE\+\_\+\+OS\+\_\+\+PAGES} instead whenever possible).
\item {\ttfamily MIMALLOC\+\_\+\+RESERVE\+\_\+\+HUGE\+\_\+\+OS\+\_\+\+PAGES=N}\+: where {\ttfamily N} is the number of 1GiB {\itshape huge} OS pages. This reserves the huge pages at startup and sometimes this can give a large (latency) performance improvement on big workloads. Usually it is better to not use {\ttfamily MIMALLOC\+\_\+\+ALLOW\+\_\+\+LARGE\+\_\+\+OS\+\_\+\+PAGES=1} in combination with this setting. Just like large OS pages, use with care as reserving contiguous physical memory can take a long time when memory is fragmented (but reserving the huge pages is done at startup only once). Note that we usually need to explicitly give permission for huge OS pages (as on \href{https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/enable-the-lock-pages-in-memory-option-windows?view=sql-server-2017}{\texttt{ Windows}} and \href{https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/tuning_and_optimizing_red_hat_enterprise_linux_for_oracle_9i_and_10g_databases/sect-oracle_9i_and_10g_tuning_guide-large_memory_optimization_big_pages_and_huge_pages-configuring_huge_pages_in_red_hat_enterprise_linux_4_or_5}{\texttt{ Linux}})). With huge OS pages, it may be beneficial to set the setting {\ttfamily MIMALLOC\+\_\+\+EAGER\+\_\+\+COMMIT\+\_\+\+DELAY=N} ({\ttfamily N} is 1 by default) to delay the initial {\ttfamily N} segments (of 4MiB) of a thread to not allocate in the huge OS pages; this prevents threads that are short lived and allocate just a little to take up space in the huge OS page area (which cannot be purged as huge OS pages are pinned to physical memory). The huge pages are usually allocated evenly among NUMA nodes. We can use {\ttfamily MIMALLOC\+\_\+\+RESERVE\+\_\+\+HUGE\+\_\+\+OS\+\_\+\+PAGES\+\_\+\+AT=N} where {\ttfamily N} is the numa node (starting at 0) to allocate all the huge pages at a specific numa node instead.
\end{DoxyItemize}

Use caution when using {\ttfamily fork} in combination with either large or huge OS pages\+: on a fork, the OS uses copy-\/on-\/write for all pages in the original process including the huge OS pages. When any memory is now written in that area, the OS will copy the entire 1GiB huge page (or 2MiB large page) which can cause the memory usage to grow in large increments.\hypertarget{readme.md_autotoc_md41}{}\doxysubsubsection{\texorpdfstring{Secure Mode}{Secure Mode}}\label{readme.md_autotoc_md41}
{\itshape mimalloc} can be build in secure mode by using the {\ttfamily -\/DMI\+\_\+\+SECURE=ON} flags in {\ttfamily cmake}. This build enables various mitigations to make mimalloc more robust against exploits. In particular\+:


\begin{DoxyItemize}
\item All internal mimalloc pages are surrounded by guard pages and the heap metadata is behind a guard page as well (so a buffer overflow exploit cannot reach into the metadata).
\item All free list pointers are \href{https://github.com/microsoft/mimalloc/blob/783e3377f79ee82af43a0793910a9f2d01ac7863/include/mimalloc-internal.h\#L396}{\texttt{ encoded}} with per-\/page keys which is used both to prevent overwrites with a known pointer, as well as to detect heap corruption.
\item Double free\textquotesingle{}s are detected (and ignored).
\item The free lists are initialized in a random order and allocation randomly chooses between extension and reuse within a page to mitigate against attacks that rely on a predicable allocation order. Similarly, the larger heap blocks allocated by mimalloc from the OS are also address randomized.
\end{DoxyItemize}

As always, evaluate with care as part of an overall security strategy as all of the above are mitigations but not guarantees.\hypertarget{readme.md_autotoc_md42}{}\doxysubsubsection{\texorpdfstring{Debug Mode}{Debug Mode}}\label{readme.md_autotoc_md42}
When {\itshape mimalloc} is built using debug mode, ({\ttfamily -\/DCMAKE\+\_\+\+BUILD\+\_\+\+TYPE=Debug}), various checks are done at runtime to catch development errors.


\begin{DoxyItemize}
\item Statistics are maintained in detail for each object size. They can be shown using {\ttfamily MIMALLOC\+\_\+\+SHOW\+\_\+\+STATS=1} at runtime.
\item All objects have padding at the end to detect (byte precise) heap block overflows.
\item Double free\textquotesingle{}s, and freeing invalid heap pointers are detected.
\item Corrupted free-\/lists and some forms of use-\/after-\/free are detected.
\end{DoxyItemize}\hypertarget{readme.md_autotoc_md43}{}\doxysubsubsection{\texorpdfstring{Guarded Mode}{Guarded Mode}}\label{readme.md_autotoc_md43}
{\itshape mimalloc} can be build in guarded mode using the {\ttfamily -\/DMI\+\_\+\+GUARDED=ON} flags in {\ttfamily cmake}. This enables placing OS guard pages behind certain object allocations to catch buffer overflows as they occur. This can be invaluable to catch buffer-\/overflow bugs in large programs. However, it also means that any object allocated with a guard page takes at least 8 KiB memory for the guard page and its alignment. As such, allocating a guard page for every allocation may be too expensive both in terms of memory, and in terms of performance with many system calls. Therefore, there are various environment variables (and options) to tune this\+:


\begin{DoxyItemize}
\item {\ttfamily MIMALLOC\+\_\+\+GUARDED\+\_\+\+SAMPLE\+\_\+\+RATE=N}\+: Set the sample rate to {\ttfamily N} (by default 4000). This mode places a guard page behind every {\ttfamily N} suitable object allocations (per thread). Since the performance in guarded mode without placing guard pages is close to release mode, this can be used to enable guard pages even in production to catch latent buffer overflow bugs. Set the sample rate to {\ttfamily 1} to guard every object, and to {\ttfamily 0} to place no guard pages at all.
\item {\ttfamily MIMALLOC\+\_\+\+GUARDED\+\_\+\+SAMPLE\+\_\+\+SEED=N}\+: Start sampling at {\ttfamily N} (by default random). Can be used to reproduce a buffer overflow if needed.
\item {\ttfamily MIMALLOC\+\_\+\+GUARDED\+\_\+\+MIN=N}, {\ttfamily MIMALLOC\+\_\+\+GUARDED\+\_\+\+MAX=N}\+: Minimal and maximal {\itshape rounded} object sizes for which a guard page is considered ({\ttfamily 0} and {\ttfamily 1GiB} respectively). If you suspect a buffer overflow occurs with an object of size 141, set the minimum and maximum to {\ttfamily 148} and the sample rate to {\ttfamily 1} to have all of those guarded.
\item {\ttfamily MIMALLOC\+\_\+\+GUARDED\+\_\+\+PRECISE=1}\+: If we have an object of size 13, we would usually place it an aligned 16 bytes in front of the guard page. Using {\ttfamily MIMALLOC\+\_\+\+GUARDED\+\_\+\+PRECISE} places it exactly 13 bytes before a page so that even a 1 byte overflow is detected. This violates the C/\+C++ minimal alignment guarantees though so use with care.
\end{DoxyItemize}\hypertarget{readme.md_autotoc_md44}{}\doxysubsection{\texorpdfstring{Overriding Standard Malloc}{Overriding Standard Malloc}}\label{readme.md_autotoc_md44}
Overriding the standard {\ttfamily malloc} (and {\ttfamily new}) can be done either {\itshape dynamically} or {\itshape statically}.\hypertarget{readme.md_autotoc_md45}{}\doxysubsubsection{\texorpdfstring{Dynamic override}{Dynamic override}}\label{readme.md_autotoc_md45}
This is the recommended way to override the standard malloc interface.\hypertarget{readme.md_autotoc_md46}{}\doxysubsubsubsection{\texorpdfstring{Dynamic Override on Linux, BSD}{Dynamic Override on Linux, BSD}}\label{readme.md_autotoc_md46}
On these ELF-\/based systems we preload the mimalloc shared library so all calls to the standard {\ttfamily malloc} interface are resolved to the {\itshape mimalloc} library. 
\begin{DoxyCode}{0}
\DoxyCodeLine{>\ env\ LD\_PRELOAD=/usr/lib/libmimalloc.so\ myprogram}

\end{DoxyCode}


You can set extra environment variables to check that mimalloc is running, like\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{>\ env\ MIMALLOC\_VERBOSE=1\ LD\_PRELOAD=/usr/lib/libmimalloc.so\ myprogram}

\end{DoxyCode}
 or run with the debug version to get detailed statistics\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{>\ env\ MIMALLOC\_SHOW\_STATS=1\ LD\_PRELOAD=/usr/lib/libmimalloc-\/debug.so\ myprogram}

\end{DoxyCode}
\hypertarget{readme.md_autotoc_md47}{}\doxysubsubsubsection{\texorpdfstring{Dynamic Override on Mac\+OS}{Dynamic Override on Mac\+OS}}\label{readme.md_autotoc_md47}
On mac\+OS we can also preload the mimalloc shared library so all calls to the standard {\ttfamily malloc} interface are resolved to the {\itshape mimalloc} library. 
\begin{DoxyCode}{0}
\DoxyCodeLine{>\ env\ DYLD\_INSERT\_LIBRARIES=/usr/lib/libmimalloc.dylib\ myprogram}

\end{DoxyCode}


Note that certain security restrictions may apply when doing this from the \href{https://stackoverflow.com/questions/43941322/dyld-insert-libraries-ignored-when-calling-application-through-bash}{\texttt{ shell}}.\hypertarget{readme.md_autotoc_md48}{}\doxysubsubsubsection{\texorpdfstring{Dynamic Override on Windows}{Dynamic Override on Windows}}\label{readme.md_autotoc_md48}
We use a separate redirection DLL to override mimalloc on Windows such that we redirect all malloc/free calls that go through the (dynamic) C runtime allocator, including those from other DLL\textquotesingle{}s or libraries. As it intercepts all allocation calls on a low level, it can be used on large programs that include other 3rd party components. There are four requirements to make the overriding work well\+:


\begin{DoxyEnumerate}
\item Use the C-\/runtime library as a DLL (using the {\ttfamily /\+MD} or {\ttfamily /\+MDd} switch).
\item Link your program explicitly with the {\ttfamily mimalloc.\+dll.\+lib} export library for the {\ttfamily mimalloc.\+dll}. (which must be compiled with {\ttfamily -\/DMI\+\_\+\+OVERRIDE=ON}, which is the default though). To ensure the {\ttfamily mimalloc.\+dll} is actually loaded at run-\/time it is easiest to insert some call to the mimalloc API in the {\ttfamily main} function, like {\ttfamily \doxylink{mimalloc_8h_a906d3e6d7f3e9cf284134c7d23d965e7}{mi\+\_\+version()}} (or use the {\ttfamily /include\+:mi\+\_\+version} switch on the linker command, or similarly, {\ttfamily \#pragma comment(linker, "{}/include\+:mi\+\_\+version"{})} in some source file). See the {\ttfamily mimalloc-\/test-\/override} project for an example on how to use this.
\item The {\ttfamily mimalloc-\/redirect.\+dll} must be put in the same directory as the main {\ttfamily mimalloc.\+dll} at runtime (as it is a dependency of that DLL). The redirection DLL ensures that all calls to the C runtime malloc API get redirected to mimalloc functions (which reside in {\ttfamily mimalloc.\+dll}).
\item Ensure the {\ttfamily mimalloc.\+dll} comes as early as possible in the import list of the final executable (so it can intercept all potential allocations). You can use {\ttfamily minject -\/l \texorpdfstring{$<$}{<}exe\texorpdfstring{$>$}{>}} to check this if needed.
\end{DoxyEnumerate}

For best performance on Windows with C++, it is also recommended to also override the {\ttfamily new}/{\ttfamily delete} operations (by including \href{include/mimalloc-new-delete.h}{\texttt{ {\ttfamily mimalloc-\/new-\/delete.\+h}}} a single(!) source file in your project).

The environment variable {\ttfamily MIMALLOC\+\_\+\+DISABLE\+\_\+\+REDIRECT=1} can be used to disable dynamic overriding at run-\/time. Use {\ttfamily MIMALLOC\+\_\+\+VERBOSE=1} to check if mimalloc was successfully redirected.

For different platforms than x64, you may need a specific \mbox{[}redirection dll\mbox{]}(bin). Furthermore, we cannot always re-\/link an executable or ensure {\ttfamily mimalloc.\+dll} comes first in the import table. In such cases the \mbox{[}{\ttfamily minject}\mbox{]}(bin) tool can be used to patch the executable\textquotesingle{}s import tables.\hypertarget{readme.md_autotoc_md49}{}\doxysubsubsection{\texorpdfstring{Static override}{Static override}}\label{readme.md_autotoc_md49}
On Unix-\/like systems, you can also statically link with {\itshape mimalloc} to override the standard malloc interface. The recommended way is to link the final program with the {\itshape mimalloc} single object file ({\ttfamily mimalloc.\+o}). We use an object file instead of a library file as linkers give preference to that over archives to resolve symbols. To ensure that the standard malloc interface resolves to the {\itshape mimalloc} library, link it as the first object file. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ gcc\ -\/o\ myprogram\ mimalloc.o\ \ myfile1.c\ ...}

\end{DoxyCode}


Another way to override statically that works on all platforms, is to link statically to mimalloc (as shown in the introduction) and include a header file in each source file that re-\/defines {\ttfamily malloc} etc. to {\ttfamily mi\+\_\+malloc}. This is provided by \href{include/mimalloc-override.h}{\texttt{ {\ttfamily mimalloc-\/override.\+h}}}. This only works reliably though if all sources are under your control or otherwise mixing of pointers from different heaps may occur!\hypertarget{readme.md_autotoc_md50}{}\doxysubsection{\texorpdfstring{Tools}{Tools}}\label{readme.md_autotoc_md50}
Generally, we recommend using the standard allocator with memory tracking tools, but mimalloc can also be build to support the \href{https://github.com/google/sanitizers/wiki/AddressSanitizer}{\texttt{ address sanitizer}} or the excellent \href{https://valgrind.org/}{\texttt{ Valgrind}} tool. Moreover, it can be build to support Windows event tracing (\href{https://learn.microsoft.com/en-us/windows-hardware/test/wpt/event-tracing-for-windows}{\texttt{ ETW}}). This has a small performance overhead but does allow detecting memory leaks and byte-\/precise buffer overflows directly on final executables. See also the {\ttfamily \doxylink{test-wrong_8c}{test/test-\/wrong.\+c}} file to test with various tools.\hypertarget{readme.md_autotoc_md51}{}\doxysubsubsection{\texorpdfstring{Valgrind}{Valgrind}}\label{readme.md_autotoc_md51}
To build with \href{https://valgrind.org/}{\texttt{ valgrind}} support, use the {\ttfamily MI\+\_\+\+TRACK\+\_\+\+VALGRIND=ON} cmake option\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ cmake\ ../..\ -\/DMI\_TRACK\_VALGRIND=ON}

\end{DoxyCode}


This can also be combined with secure mode or debug mode. You can then run your programs directly under valgrind\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ valgrind\ <myprogram>}

\end{DoxyCode}


If you rely on overriding {\ttfamily malloc}/{\ttfamily free} by mimalloc (instead of using the {\ttfamily mi\+\_\+malloc}/{\ttfamily mi\+\_\+free} API directly), you also need to tell {\ttfamily valgrind} to not intercept those calls itself, and use\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ MIMALLOC\_SHOW\_STATS=1\ valgrind\ \ -\/-\/soname-\/synonyms=somalloc=*mimalloc*\ -\/-\/\ <myprogram>}

\end{DoxyCode}


By setting the {\ttfamily MIMALLOC\+\_\+\+SHOW\+\_\+\+STATS} environment variable you can check that mimalloc is indeed used and not the standard allocator. Even though the \href{https://valgrind.org/docs/manual/manual-core.html\#opt.soname-synonyms}{\texttt{ Valgrind option}} is called {\ttfamily -\/-\/soname-\/synonyms}, this also works when overriding with a static library or object file. To dynamically override mimalloc using {\ttfamily LD\+\_\+\+PRELOAD} together with {\ttfamily valgrind}, use\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ valgrind\ -\/-\/trace-\/children=yes\ -\/-\/soname-\/synonyms=somalloc=*mimalloc*\ /usr/bin/env\ LD\_PRELOAD=/usr/lib/libmimalloc.so\ -\/-\/\ <myprogram>}

\end{DoxyCode}


See also the {\ttfamily \doxylink{test-wrong_8c}{test/test-\/wrong.\+c}} file to test with {\ttfamily valgrind}.

Valgrind support is in its initial development -- please report any issues.\hypertarget{readme.md_autotoc_md52}{}\doxysubsubsection{\texorpdfstring{ASAN}{ASAN}}\label{readme.md_autotoc_md52}
To build with the address sanitizer, use the {\ttfamily -\/DMI\+\_\+\+TRACK\+\_\+\+ASAN=ON} cmake option\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ cmake\ ../..\ -\/DMI\_TRACK\_ASAN=ON}

\end{DoxyCode}


This can also be combined with secure mode or debug mode. You can then run your programs as\+:\textquotesingle{}


\begin{DoxyCode}{0}
\DoxyCodeLine{>\ ASAN\_OPTIONS=verbosity=1\ <myprogram>}

\end{DoxyCode}


When you link a program with an address sanitizer build of mimalloc, you should generally compile that program too with the address sanitizer enabled. For example, assuming you build mimalloc in {\ttfamily out/debug}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{clang\ -\/g\ -\/o\ test-\/wrong\ -\/Iinclude\ test/test-\/wrong.c\ out/debug/libmimalloc-\/asan-\/debug.a\ -\/lpthread\ -\/fsanitize=address\ -\/fsanitize-\/recover=address}

\end{DoxyCode}


Since the address sanitizer redirects the standard allocation functions, on some platforms (mac\+OSX for example) it is required to compile mimalloc with {\ttfamily -\/DMI\+\_\+\+OVERRIDE=OFF}. Address sanitizer support is in its initial development -- please report any issues.\hypertarget{readme.md_autotoc_md53}{}\doxysubsubsection{\texorpdfstring{ETW}{ETW}}\label{readme.md_autotoc_md53}
Event tracing for Windows (\href{https://learn.microsoft.com/en-us/windows-hardware/test/wpt/event-tracing-for-windows}{\texttt{ ETW}}) provides a high performance way to capture all allocations though mimalloc and analyze them later. To build with ETW support, use the {\ttfamily -\/DMI\+\_\+\+TRACK\+\_\+\+ETW=ON} cmake option.

You can then capture an allocation trace using the Windows performance recorder (WPR), using the {\ttfamily src/prim/windows/etw-\/mimalloc.\+wprp} profile. In an admin prompt, you can use\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{>\ wpr\ -\/start\ src\(\backslash\)prim\(\backslash\)windows\(\backslash\)etw-\/mimalloc.wprp\ -\/filemode}
\DoxyCodeLine{>\ <my\_mimalloc\_program>}
\DoxyCodeLine{>\ wpr\ -\/stop\ <my\_mimalloc\_program>.etl}

\end{DoxyCode}
 and then open {\ttfamily \texorpdfstring{$<$}{<}my\+\_\+mimalloc\+\_\+program\texorpdfstring{$>$}{>}.etl} in the Windows Performance Analyzer (WPA), or use a tool like \href{https://github.com/xinglonghe/TraceControl}{\texttt{ Trace\+Control}} that is specialized for analyzing mimalloc traces.\hypertarget{readme.md_autotoc_md54}{}\doxysubsection{\texorpdfstring{Performance}{Performance}}\label{readme.md_autotoc_md54}
Last update\+: 2021-\/01-\/30

We tested {\itshape mimalloc} against many other top allocators over a wide range of benchmarks, ranging from various real world programs to synthetic benchmarks that see how the allocator behaves under more extreme circumstances. In our benchmark suite, {\itshape mimalloc} outperforms other leading allocators ({\itshape jemalloc}, {\itshape tcmalloc}, {\itshape Hoard}, etc), and has a similar memory footprint. A nice property is that it does consistently well over the wide range of benchmarks.

General memory allocators are interesting as there exists no algorithm that is optimal -- for a given allocator one can usually construct a workload where it does not do so well. The goal is thus to find an allocation strategy that performs well over a wide range of benchmarks without suffering from (too much) underperformance in less common situations.

As always, interpret these results with care since some benchmarks test synthetic or uncommon situations that may never apply to your workloads. For example, most allocators do not do well on {\ttfamily xmalloc-\/testN} but that includes even the best industrial allocators like {\itshape jemalloc} and {\itshape tcmalloc} that are used in some of the world\textquotesingle{}s largest systems (like Chrome or Free\+BSD).

Also, the benchmarks here do not measure the behaviour on very large and long-\/running server workloads, or worst-\/case latencies of allocation. Much work has gone into {\ttfamily mimalloc} to work well on such workloads (for example, to reduce virtual memory fragmentation on long-\/running services) but such optimizations are not always reflected in the current benchmark suite.

We show here only an overview -- for more specific details and further benchmarks we refer to the \href{https://www.microsoft.com/en-us/research/publication/mimalloc-free-list-sharding-in-action}{\texttt{ technical report}}. The benchmark suite is automated and available separately as \href{https://github.com/daanx/mimalloc-bench}{\texttt{ mimalloc-\/bench}}.\hypertarget{readme.md_autotoc_md55}{}\doxysubsubsection{\texorpdfstring{Benchmark Results on a 16-\/core AMD 5950x (Zen3)}{Benchmark Results on a 16-\/core AMD 5950x (Zen3)}}\label{readme.md_autotoc_md55}
Testing on the 16-\/core AMD 5950x processor at 3.\+4\+Ghz (4.\+9\+Ghz boost), with with 32GiB memory at 3600Mhz, running Ubuntu 20.\+04 with glibc 2.\+31 and GCC 9.\+3.\+0.

We measure three versions of {\itshape mimalloc}\+: the main version {\ttfamily mi} (tag\+:v1.\+7.\+0), the new v2.\+0 beta version as {\ttfamily xmi} (tag\+:v2.\+0.\+0), and the main version in secure mode as {\ttfamily smi} (tag\+:v1.\+7.\+0).

The other allocators are Google\textquotesingle{}s \href{https://github.com/gperftools/gperftools}{\texttt{ {\itshape tcmalloc}}} ({\ttfamily tc}, tag\+:gperftools-\/2.\+8.\+1) used in Chrome, Facebook\textquotesingle{}s \href{https://github.com/jemalloc/jemalloc}{\texttt{ {\itshape jemalloc}}} ({\ttfamily je}, tag\+:5.\+2.\+1) by Jason Evans used in Firefox and Free\+BSD, the Intel thread building blocks \href{https://github.com/intel/tbb}{\texttt{ allocator}} ({\ttfamily tbb}, tag\+:v2020.\+3), \href{https://github.com/mjansson/rpmalloc}{\texttt{ rpmalloc}} ({\ttfamily rp},tag\+:1.\+4.\+1) by Mattias Jansson, the original scalable \href{https://github.com/emeryberger/Hoard}{\texttt{ {\itshape Hoard}}} (git\+:d880f72) allocator by Emery Berger \mbox{[}1\mbox{]}, the memory compacting \href{https://github.com/plasma-umass/Mesh}{\texttt{ {\itshape Mesh}}} (git\+:67ff31a) allocator by Bobby Powers {\itshape et al} \mbox{[}8\mbox{]}, and finally the default system allocator ({\ttfamily glibc}, 2.\+31) (based on {\itshape Pt\+Malloc2}).

 

Any benchmarks ending in {\ttfamily N} run on all 32 logical cores in parallel. Results are averaged over 10 runs and reported relative to mimalloc (where 1.\+2 means it took 1.\+2{$\times$} longer to run). The legend also contains the {\itshape overall relative score} between the allocators where 100 points is the maximum if an allocator is fastest on all benchmarks.

The single threaded {\itshape cfrac} benchmark by Dave Barrett is an implementation of continued fraction factorization which uses many small short-\/lived allocations. All allocators do well on such common usage, where {\itshape mimalloc} is just a tad faster than {\itshape tcmalloc} and {\itshape jemalloc}.

The {\itshape leanN} program is interesting as a large realistic and concurrent workload of the \href{https://github.com/leanprover/lean}{\texttt{ Lean}} theorem prover compiling its own standard library, and there is a 13\% speedup over {\itshape tcmalloc}. This is quite significant\+: if Lean spends 20\% of its time in the allocator that means that {\itshape mimalloc} is 1.\+6{$\times$} faster than {\itshape tcmalloc} here. (This is surprising as that is not measured in a pure allocation benchmark like {\itshape alloc-\/test}. We conjecture that we see this outsized improvement here because {\itshape mimalloc} has better locality in the allocation which improves performance for the {\itshape other} computations in a program as well).

The single threaded {\itshape redis} benchmark again show that most allocators do well on such workloads.

The {\itshape larsonN} server benchmark by Larson and Krishnan \mbox{[}2\mbox{]} allocates and frees between threads. They observed this behavior (which they call {\itshape bleeding}) in actual server applications, and the benchmark simulates this. Here, {\itshape mimalloc} is quite a bit faster than {\itshape tcmalloc} and {\itshape jemalloc} probably due to the object migration between different threads.

The {\itshape mstressN} workload performs many allocations and re-\/allocations, and migrates objects between threads (as in {\itshape larsonN}). However, it also creates and destroys the {\itshape N} worker threads a few times keeping some objects alive beyond the life time of the allocating thread. We observed this behavior in many larger server applications.

The \href{https://github.com/mjansson/rpmalloc-benchmark}{\texttt{ {\itshape rptestN}}} benchmark by Mattias Jansson is a allocator test originally designed for {\itshape rpmalloc}, and tries to simulate realistic allocation patterns over multiple threads. Here the differences between allocators become more apparent.

The second benchmark set tests specific aspects of the allocators and shows even more extreme differences between them.

The {\itshape alloc-\/test}, by \href{http://ithare.com/testing-memory-allocators-ptmalloc2-tcmalloc-hoard-jemalloc-while-trying-to-simulate-real-world-loads/}{\texttt{ OLogN Technologies AG}}, is a very allocation intensive benchmark doing millions of allocations in various size classes. The test is scaled such that when an allocator performs almost identically on {\itshape alloc-\/test1} as {\itshape alloc-\/testN} it means that it scales linearly.

The {\itshape sh6bench} and {\itshape sh8bench} benchmarks are developed by \href{http://www.microquill.com/}{\texttt{ Micro\+Quill}} as part of Smart\+Heap. In {\itshape sh6bench} {\itshape mimalloc} does much better than the others (more than 2.\+5{$\times$} faster than {\itshape jemalloc}). We cannot explain this well but believe it is caused in part by the "{}reverse"{} free-\/ing pattern in {\itshape sh6bench}. The {\itshape sh8bench} is a variation with object migration between threads; whereas {\itshape tcmalloc} did well on {\itshape sh6bench}, the addition of object migration causes it to be 10{$\times$} slower than before.

The {\itshape xmalloc-\/testN} benchmark by Lever and Boreham \mbox{[}5\mbox{]} and Christian Eder, simulates an asymmetric workload where some threads only allocate, and others only free -- they observed this pattern in larger server applications. Here we see that the {\itshape mimalloc} technique of having non-\/contended sharded thread free lists pays off as it outperforms others by a very large margin. Only {\itshape rpmalloc}, {\itshape tbb}, and {\itshape glibc} also scale well on this benchmark.

The {\itshape cache-\/scratch} benchmark by Emery Berger \mbox{[}1\mbox{]}, and introduced with the Hoard allocator to test for {\itshape passive-\/false} sharing of cache lines. With a single thread they all perform the same, but when running with multiple threads the potential allocator induced false sharing of the cache lines can cause large run-\/time differences. Crundal \mbox{[}6\mbox{]} describes in detail why the false cache line sharing occurs in the {\itshape tcmalloc} design, and also discusses how this can be avoided with some small implementation changes. Only the {\itshape tbb}, {\itshape rpmalloc} and {\itshape mesh} allocators also avoid the cache line sharing completely, while {\itshape Hoard} and {\itshape glibc} seem to mitigate the effects. Kukanov and Voss \mbox{[}7\mbox{]} describe in detail how the design of {\itshape tbb} avoids the false cache line sharing.\hypertarget{readme.md_autotoc_md56}{}\doxysubsubsection{\texorpdfstring{On a 36-\/core Intel Xeon}{On a 36-\/core Intel Xeon}}\label{readme.md_autotoc_md56}
For completeness, here are the results on a big Amazon \href{https://aws.amazon.com/ec2/instance-types/\#Compute_Optimized}{\texttt{ c5.\+18xlarge}} instance consisting of a 2{$\times$}18-\/core Intel Xeon (Cascade Lake) at 3.\+4\+GHz (boost 3.\+5\+GHz) with 144GiB ECC memory, running Ubuntu 20.\+04 with glibc 2.\+31, GCC 9.\+3.\+0, and Clang 10.\+0.\+0. This time, the mimalloc allocators (mi, xmi, and smi) were compiled with the Clang compiler instead of GCC. The results are similar to the AMD results but it is interesting to see the differences in the {\itshape larsonN}, {\itshape mstressN}, and {\itshape xmalloc-\/testN} benchmarks.

 \hypertarget{readme.md_autotoc_md57}{}\doxysubsubsection{\texorpdfstring{Peak Working Set}{Peak Working Set}}\label{readme.md_autotoc_md57}
The following figure shows the peak working set (rss) of the allocators on the benchmarks (on the c5.\+18xlarge instance).

 

Note that the {\itshape xmalloc-\/testN} memory usage should be disregarded as it allocates more the faster the program runs. Similarly, memory usage of {\itshape larsonN}, {\itshape mstressN}, {\itshape rptestN} and {\itshape sh8bench} can vary depending on scheduling and speed. Nevertheless, we hope to improve the memory usage on {\itshape mstressN} and {\itshape rptestN} (just as {\itshape cfrac}, {\itshape larsonN} and {\itshape sh8bench} have a small working set which skews the results).\hypertarget{readme.md_autotoc_md61}{}\doxysubsection{\texorpdfstring{References}{References}}\label{readme.md_autotoc_md61}

\begin{DoxyItemize}
\item \mbox{[}1\mbox{]} Emery D. Berger, Kathryn S. Mc\+Kinley, Robert D. Blumofe, and Paul R. Wilson. {\itshape Hoard\+: A Scalable Memory Allocator for Multithreaded Applications} the Ninth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-\/\+IX). Cambridge, MA, November 2000. \href{http://www.cs.utexas.edu/users/mckinley/papers/asplos-2000.pdf}{\texttt{ pdf}}
\item \mbox{[}2\mbox{]} P. Larson and M. Krishnan. {\itshape Memory allocation for long-\/running server applications}. In ISMM, Vancouver, B.\+C., Canada, 1998. \href{http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.45.1947&rep=rep1&type=pdf}{\texttt{ pdf}}
\item \mbox{[}3\mbox{]} D. Grunwald, B. Zorn, and R. Henderson. {\itshape Improving the cache locality of memory allocation}. In R. Cartwright, editor, Proceedings of the Conference on Programming Language Design and Implementation, pages 177–186, New York, NY, USA, June 1993. \href{http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.43.6621&rep=rep1&type=pdf}{\texttt{ pdf}}
\item \mbox{[}4\mbox{]} J. Barnes and P. Hut. {\itshape A hierarchical O(n\texorpdfstring{$\ast$}{*}log(n)) force-\/calculation algorithm}. Nature, 324\+:446-\/449, 1986.
\item \mbox{[}5\mbox{]} C. Lever, and D. Boreham. {\itshape Malloc() Performance in a Multithreaded Linux Environment.} In USENIX Annual Technical Conference, Freenix Session. San Diego, CA. Jun. 2000. Available at \href{https://github.com/kuszmaul/SuperMalloc/tree/master/tests}{\texttt{ https\+://github.\+com/kuszmaul/\+Super\+Malloc/tree/master/tests}}
\item \mbox{[}6\mbox{]} Timothy Crundal. {\itshape Reducing Active-\/\+False Sharing in TCMalloc}. 2016. CS16\+S1 project at the Australian National University. \href{http://courses.cecs.anu.edu.au/courses/CSPROJECTS/16S1/Reports/Timothy_Crundal_Report.pdf}{\texttt{ pdf}}
\item \mbox{[}7\mbox{]} Alexey Kukanov, and Michael J Voss. {\itshape The Foundations for Scalable Multi-\/\+Core Software in Intel Threading Building Blocks.} Intel Technology Journal 11 (4). 2007
\item \mbox{[}8\mbox{]} Bobby Powers, David Tench, Emery D. Berger, and Andrew Mc\+Gregor. {\itshape Mesh\+: Compacting Memory Management for C/\+C++} In Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI\textquotesingle{}19), June 2019, pages 333-\/–346.
\end{DoxyItemize}\hypertarget{readme.md_autotoc_md62}{}\doxysubsection{\texorpdfstring{Contributing}{Contributing}}\label{readme.md_autotoc_md62}
This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit \href{https://cla.microsoft.com}{\texttt{ https\+://cla.\+microsoft.\+com}}.

When you submit a pull request, a CLA-\/bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.\+g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.\hypertarget{readme.md_autotoc_md63}{}\doxysubsection{\texorpdfstring{Older Release Notes}{Older Release Notes}}\label{readme.md_autotoc_md63}

\begin{DoxyItemize}
\item 2021-\/11-\/14, {\ttfamily v1.\+7.\+3}, {\ttfamily v2.\+0.\+3} (beta)\+: improved WASM support, improved mac\+OS support and performance (including M1), improved performance for v2 for large objects, Python integration improvements, more standard installation directories, various small fixes.
\item 2021-\/06-\/17, {\ttfamily v1.\+7.\+2}, {\ttfamily v2.\+0.\+2} (beta)\+: support M1, better installation layout on Linux, fix thread\+\_\+id on Android, prefer 2-\/6TiB area for aligned allocation to work better on pre-\/windows 8, various small fixes.
\item 2021-\/04-\/06, {\ttfamily v1.\+7.\+1}, {\ttfamily v2.\+0.\+1} (beta)\+: fix bug in arena allocation for huge pages, improved aslr on large allocations, initial M1 support (still experimental).
\item 2021-\/01-\/31, {\ttfamily v2.\+0.\+0}\+: beta release 2.\+0\+: new slice algorithm for managing internal mimalloc pages.
\item 2021-\/01-\/31, {\ttfamily v1.\+7.\+0}\+: stable release 1.\+7\+: support explicit user provided memory regions, more precise statistics, improve mac\+OS overriding, initial support for Apple M1, improved Dragon\+Fly support, faster memcpy on Windows, various small fixes.
\item 2020-\/09-\/24, {\ttfamily v1.\+6.\+7}\+: stable release 1.\+6\+: using standard C atomics, passing tsan testing, improved handling of failing to commit on Windows, add \href{https://github.com/microsoft/mimalloc/blob/master/include/mimalloc.h\#L156}{\texttt{ {\ttfamily mi\+\_\+process\+\_\+info}}} api call.
\item 2020-\/08-\/06, {\ttfamily v1.\+6.\+4}\+: stable release 1.\+6\+: improved error recovery in low-\/memory situations, support for Illum\+OS and Haiku, NUMA support for Vista/\+XP, improved NUMA detection for AMD Ryzen, ubsan support.
\item 2020-\/05-\/05, {\ttfamily v1.\+6.\+3}\+: stable release 1.\+6\+: improved behavior in out-\/of-\/memory situations, improved malloc zones on mac\+OS, build PIC static libraries by default, add option to abort on out-\/of-\/memory, line buffered statistics.
\item 2020-\/04-\/20, {\ttfamily v1.\+6.\+2}\+: stable release 1.\+6\+: fix compilation on Android, MingW, Raspberry, and Conda, stability fix for Windows 7, fix multiple mimalloc instances in one executable, fix {\ttfamily strnlen} overload, fix aligned debug padding.
\item 2020-\/02-\/17, {\ttfamily v1.\+6.\+1}\+: stable release 1.\+6\+: minor updates (build with clang-\/cl, fix alignment issue for small objects).
\item 2020-\/02-\/09, {\ttfamily v1.\+6.\+0}\+: stable release 1.\+6\+: fixed potential memory leak, improved overriding and thread local support on Free\+BSD, Net\+BSD, Dragon\+Fly, and mac\+OSX. New byte-\/precise heap block overflow detection in debug mode (besides the double-\/free detection and free-\/list corruption detection). Add {\ttfamily nodiscard} attribute to most allocation functions. Enable {\ttfamily MIMALLOC\+\_\+\+PAGE\+\_\+\+RESET} by default. New reclamation strategy for abandoned heap pages for better memory footprint.
\item 2020-\/02-\/09, {\ttfamily v1.\+5.\+0}\+: stable release 1.\+5\+: improved free performance, small bug fixes.
\item 2020-\/01-\/22, {\ttfamily v1.\+4.\+0}\+: stable release 1.\+4\+: improved performance for delayed OS page reset, more eager concurrent free, addition of STL allocator, fixed potential memory leak.
\item 2020-\/01-\/15, {\ttfamily v1.\+3.\+0}\+: stable release 1.\+3\+: bug fixes, improved randomness and \href{https://github.com/microsoft/mimalloc/blob/783e3377f79ee82af43a0793910a9f2d01ac7863/include/mimalloc-internal.h\#L396}{\texttt{ stronger free list encoding}} in secure mode.
\item 2019-\/12-\/22, {\ttfamily v1.\+2.\+2}\+: stable release 1.\+2\+: minor updates.
\item 2019-\/11-\/22, {\ttfamily v1.\+2.\+0}\+: stable release 1.\+2\+: bug fixes, improved secure mode (free list corruption checks, double free mitigation). Improved dynamic overriding on Windows.
\item 2019-\/10-\/07, {\ttfamily v1.\+1.\+0}\+: stable release 1.\+1.
\item 2019-\/09-\/01, {\ttfamily v1.\+0.\+8}\+: pre-\/release 8\+: more robust windows dynamic overriding, initial huge page support.
\item 2019-\/08-\/10, {\ttfamily v1.\+0.\+6}\+: pre-\/release 6\+: various performance improvements. 
\end{DoxyItemize}