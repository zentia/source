\doxysection{cds\+::memory\+::lazy\+\_\+vyukov\+\_\+queue\+\_\+pool\texorpdfstring{$<$}{<} T, Traits \texorpdfstring{$>$}{>} 模板类 参考}
\hypertarget{classcds_1_1memory_1_1lazy__vyukov__queue__pool}{}\label{classcds_1_1memory_1_1lazy__vyukov__queue__pool}\index{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}}


Lazy free-\/list based on bounded lock-\/free queue {\ttfamily \doxylink{classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue}{cds\+::intrusive\+::\+Vyukov\+MPMCCycle\+Queue}}  




{\ttfamily \#include $<$vyukov\+\_\+queue\+\_\+pool.\+h$>$}

\doxysubsubsection*{Public 类型}
\begin{DoxyCompactItemize}
\item 
typedef \mbox{\hyperlink{classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue}{cds\+::intrusive\+::\+Vyukov\+MPMCCycle\+Queue}}$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, Traits $>$ \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a36d8e8fca6bf5421a4dfc06181a8cce1}{queue\+\_\+type}}
\begin{DoxyCompactList}\small\item\em Queue type \end{DoxyCompactList}\item 
typedef \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a7cee4aa080579c21cd52bbb09cc1ac9a}{value\+\_\+type}}
\begin{DoxyCompactList}\small\item\em \doxylink{struct_value}{Value} type \end{DoxyCompactList}\item 
typedef Traits \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a69e5497f749619c0935c4deb9e8b2282}{traits}}
\begin{DoxyCompactList}\small\item\em Pool traits \end{DoxyCompactList}\item 
typedef std\+::allocator\+\_\+traits$<$ typenametraits\+::allocator $>$\+::template rebind\+\_\+alloc$<$ \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a7cee4aa080579c21cd52bbb09cc1ac9a}{value\+\_\+type}} $>$ \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_afd71f7df97a45f081db4f6a98e986a19}{allocator\+\_\+type}}
\begin{DoxyCompactList}\small\item\em allocator type \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a406e04c0222c8190e9d0ae94431a40ff}{lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}} (size\+\_\+t n\+Capacity=0)
\begin{DoxyCompactList}\small\item\em Constructs empty pool \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a300d92da95ea06944957819d09cd19e4}{\texorpdfstring{$\sim$}{\string~}lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}} ()
\begin{DoxyCompactList}\small\item\em Deallocates all objects from the pool \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a7cee4aa080579c21cd52bbb09cc1ac9a}{value\+\_\+type}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a31da49030ee491460b32e1be3eab47c0}{allocate}} (size\+\_\+t \mbox{\hyperlink{_bi_c_g_s_t_a_b__simple_8cpp_a5150192f625f4d7970d61169b9567f39}{n}})
\begin{DoxyCompactList}\small\item\em Allocates an object from pool \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a9e8767a7c0423f20d4fbcdecd33a3657}{deallocate}} (\mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a7cee4aa080579c21cd52bbb09cc1ac9a}{value\+\_\+type}} \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{main-override_8cpp_a117104b82864d3b23ec174af6d392709}{p}}, size\+\_\+t \mbox{\hyperlink{_bi_c_g_s_t_a_b__simple_8cpp_a5150192f625f4d7970d61169b9567f39}{n}})
\begin{DoxyCompactList}\small\item\em Deallocates the object {\ttfamily p} \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}
\subsubsection*{template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, typename Traits = vyukov\+\_\+queue\+\_\+pool\+\_\+traits$>$\newline
class cds\+::memory\+::lazy\+\_\+vyukov\+\_\+queue\+\_\+pool$<$ T, Traits $>$}
Lazy free-\/list based on bounded lock-\/free queue {\ttfamily \doxylink{classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue}{cds\+::intrusive\+::\+Vyukov\+MPMCCycle\+Queue}} 

Template parameters\+:
\begin{DoxyItemize}
\item {\ttfamily T} -\/ the type of object maintaining by free-\/list. {\ttfamily T} must be default constructible
\item {\ttfamily Traits} -\/ traits for {\ttfamily \doxylink{classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue}{cds\+::intrusive\+::\+Vyukov\+MPMCCycle\+Queue}} class plus {\ttfamily \doxylink{structcds_1_1opt_1_1allocator}{cds\+::opt\+::allocator}} option, default is {\ttfamily \doxylink{structcds_1_1memory_1_1vyukov__queue__pool__traits}{vyukov\+\_\+queue\+\_\+pool\+\_\+traits}} 
\end{DoxyItemize}

{\bfseries{Internals}} 

This free-\/list is very simple. At construction time the pool is empty. When allocating the free-\/list tries to pop an object from internal queue. If success the popped object is returned. Otherwise a new one is allocated. When deallocating, the free-\/list tries to push the object into the pool. If internal queue is full, the object is deallocated by using the allocator provided. The pool can manage more than {\ttfamily N} items but only {\ttfamily N} items is placed in the free-\/list.

{\bfseries{Usage}} 

{\ttfamily lazy\+\_\+vyukov\+\_\+queue\+\_\+pool} should be used together with \doxylink{classcds_1_1memory_1_1pool__allocator}{pool\+\_\+allocator}. You should declare an static object of type {\ttfamily lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}, provide an accessor functor to this object and use {\ttfamily \doxylink{classcds_1_1memory_1_1pool__allocator}{pool\+\_\+allocator}} as an allocator\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <\mbox{\hyperlink{vyukov__queue__pool_8h}{cds/memory/vyukov\_queue\_pool.h}}>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <\mbox{\hyperlink{pool__allocator_8h}{cds/memory/pool\_allocator.h}}>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Pool\ of\ Foo\ object\ of\ size\ 1024.}}
\DoxyCodeLine{\textcolor{keyword}{typedef}\ cds::memory::lazy\_vyukov\_queue\_pool<\ Foo\ >\ \mbox{\hyperlink{namespacecds__test_aad6f7852933f5de189aa75fc65649e6d}{pool\_type}};}
\DoxyCodeLine{\textcolor{keyword}{static}\ \mbox{\hyperlink{namespacecds__test_aad6f7852933f5de189aa75fc65649e6d}{pool\_type}}\ thePool(\ 1024\ );}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct\ }pool\_accessor\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{typedef}\ \textcolor{keyword}{typename}\ pool\_type::value\_type\ \ value\_type;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespacecds__test_aad6f7852933f5de189aa75fc65649e6d}{pool\_type}}\&\ operator()()\textcolor{keyword}{\ const}}
\DoxyCodeLine{\textcolor{keyword}{\ \ \ \ }\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ thePool;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Declare\ pool\ allocator}}
\DoxyCodeLine{\textcolor{keyword}{typedef}\ cds::memory::pool\_allocator<\ Foo,\ pool\_accessor\ >\ \ \ pool\_allocator;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Use\ pool\_allocator}}
\DoxyCodeLine{\textcolor{comment}{//\ Allocate\ an\ object}}
\DoxyCodeLine{\mbox{\hyperlink{bug1213_8cpp_add4cd82fef2db3867de22e0c84c750a1aca2a3a2b2da8e517565fb654a86639b6}{Foo}}\ *\ \mbox{\hyperlink{main-override_8cpp_a117104b82864d3b23ec174af6d392709}{p}}\ =\ pool\_allocator().allocate(\ 1\ );}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ construct\ object}}
\DoxyCodeLine{\textcolor{keyword}{new}(\mbox{\hyperlink{main-override_8cpp_a117104b82864d3b23ec174af6d392709}{p}})\ Foo;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//...}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Destruct\ object}}
\DoxyCodeLine{\mbox{\hyperlink{main-override_8cpp_a117104b82864d3b23ec174af6d392709}{p}}-\/>\string~Foo();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Deallocate\ object}}
\DoxyCodeLine{pool\_allocator().deallocate(\ \mbox{\hyperlink{main-override_8cpp_a117104b82864d3b23ec174af6d392709}{p}}\ ,\ 1\ );}

\end{DoxyCode}
 

\doxysubsection{成员类型定义说明}
\Hypertarget{classcds_1_1memory_1_1lazy__vyukov__queue__pool_afd71f7df97a45f081db4f6a98e986a19}\index{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}!allocator\_type@{allocator\_type}}
\index{allocator\_type@{allocator\_type}!cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}}
\doxysubsubsection{\texorpdfstring{allocator\_type}{allocator\_type}}
{\footnotesize\ttfamily \label{classcds_1_1memory_1_1lazy__vyukov__queue__pool_afd71f7df97a45f081db4f6a98e986a19} 
template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, typename Traits = vyukov\+\_\+queue\+\_\+pool\+\_\+traits$>$ \\
typedef std\+::allocator\+\_\+traits$<$typenametraits\+::allocator$>$\+::template rebind\+\_\+alloc$<$\mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a7cee4aa080579c21cd52bbb09cc1ac9a}{value\+\_\+type}}$>$ \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool}{cds\+::memory\+::lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}}$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, Traits $>$\+::allocator\+\_\+type}



allocator type 

\Hypertarget{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a36d8e8fca6bf5421a4dfc06181a8cce1}\index{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}!queue\_type@{queue\_type}}
\index{queue\_type@{queue\_type}!cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}}
\doxysubsubsection{\texorpdfstring{queue\_type}{queue\_type}}
{\footnotesize\ttfamily \label{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a36d8e8fca6bf5421a4dfc06181a8cce1} 
template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, typename Traits = vyukov\+\_\+queue\+\_\+pool\+\_\+traits$>$ \\
typedef \mbox{\hyperlink{classcds_1_1intrusive_1_1_vyukov_m_p_m_c_cycle_queue}{cds\+::intrusive\+::\+Vyukov\+MPMCCycle\+Queue}}$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, Traits $>$ \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool}{cds\+::memory\+::lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}}$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, Traits $>$\+::queue\+\_\+type}



Queue type 

\Hypertarget{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a69e5497f749619c0935c4deb9e8b2282}\index{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}!traits@{traits}}
\index{traits@{traits}!cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}}
\doxysubsubsection{\texorpdfstring{traits}{traits}}
{\footnotesize\ttfamily \label{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a69e5497f749619c0935c4deb9e8b2282} 
template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, typename Traits = vyukov\+\_\+queue\+\_\+pool\+\_\+traits$>$ \\
typedef Traits \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool}{cds\+::memory\+::lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}}$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, Traits $>$\+::traits}



Pool traits 

\Hypertarget{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a7cee4aa080579c21cd52bbb09cc1ac9a}\index{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}!value\_type@{value\_type}}
\index{value\_type@{value\_type}!cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}}
\doxysubsubsection{\texorpdfstring{value\_type}{value\_type}}
{\footnotesize\ttfamily \label{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a7cee4aa080579c21cd52bbb09cc1ac9a} 
template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, typename Traits = vyukov\+\_\+queue\+\_\+pool\+\_\+traits$>$ \\
typedef \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}} \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool}{cds\+::memory\+::lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}}$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, Traits $>$\+::value\+\_\+type}



\doxylink{struct_value}{Value} type 



\doxysubsection{构造及析构函数说明}
\Hypertarget{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a406e04c0222c8190e9d0ae94431a40ff}\index{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}!lazy\_vyukov\_queue\_pool@{lazy\_vyukov\_queue\_pool}}
\index{lazy\_vyukov\_queue\_pool@{lazy\_vyukov\_queue\_pool}!cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}}
\doxysubsubsection{\texorpdfstring{lazy\_vyukov\_queue\_pool()}{lazy\_vyukov\_queue\_pool()}}
{\footnotesize\ttfamily \label{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a406e04c0222c8190e9d0ae94431a40ff} 
template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, typename Traits = vyukov\+\_\+queue\+\_\+pool\+\_\+traits$>$ \\
\mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool}{cds\+::memory\+::lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}}$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, Traits $>$\+::lazy\+\_\+vyukov\+\_\+queue\+\_\+pool (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n\+Capacity}{ = {\ttfamily 0}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Constructs empty pool 

\Hypertarget{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a300d92da95ea06944957819d09cd19e4}\index{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}!````~lazy\_vyukov\_queue\_pool@{\texorpdfstring{$\sim$}{\string~}lazy\_vyukov\_queue\_pool}}
\index{````~lazy\_vyukov\_queue\_pool@{\texorpdfstring{$\sim$}{\string~}lazy\_vyukov\_queue\_pool}!cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}}
\doxysubsubsection{\texorpdfstring{\texorpdfstring{$\sim$}{\string~}lazy\_vyukov\_queue\_pool()}{\string~lazy\_vyukov\_queue\_pool()}}
{\footnotesize\ttfamily \label{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a300d92da95ea06944957819d09cd19e4} 
template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, typename Traits = vyukov\+\_\+queue\+\_\+pool\+\_\+traits$>$ \\
\mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool}{cds\+::memory\+::lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}}$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, Traits $>$\+::\texorpdfstring{$\sim$}{\string~}\mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool}{lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deallocates all objects from the pool 



\doxysubsection{成员函数说明}
\Hypertarget{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a31da49030ee491460b32e1be3eab47c0}\index{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}!allocate@{allocate}}
\index{allocate@{allocate}!cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}}
{\footnotesize\ttfamily \label{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a31da49030ee491460b32e1be3eab47c0} 
template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, typename Traits = vyukov\+\_\+queue\+\_\+pool\+\_\+traits$>$ \\
\mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a7cee4aa080579c21cd52bbb09cc1ac9a}{value\+\_\+type}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool}{cds\+::memory\+::lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}}$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, Traits $>$\+::allocate (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Allocates an object from pool 

The pool supports allocation only single object ({\ttfamily n} = 1). If {\ttfamily n} \texorpdfstring{$>$}{>} 1 the behavior is undefined.

If the queue is not empty, the popped value is returned. Otherwise, a new value allocated. \Hypertarget{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a9e8767a7c0423f20d4fbcdecd33a3657}\index{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$@{cds::memory::lazy\_vyukov\_queue\_pool$<$ T, Traits $>$}}
\doxysubsubsection{\texorpdfstring{deallocate()}{deallocate()}}
{\footnotesize\ttfamily \label{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a9e8767a7c0423f20d4fbcdecd33a3657} 
template$<$typename \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, typename Traits = vyukov\+\_\+queue\+\_\+pool\+\_\+traits$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool}{cds\+::memory\+::lazy\+\_\+vyukov\+\_\+queue\+\_\+pool}}$<$ \mbox{\hyperlink{_tutorial__sparse__example_8cpp_af639fb96631ba0018f0b2259fc95edfb}{T}}, Traits $>$\+::deallocate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classcds_1_1memory_1_1lazy__vyukov__queue__pool_a7cee4aa080579c21cd52bbb09cc1ac9a}{value\+\_\+type}} \texorpdfstring{$\ast$}{*}}]{p}{, }\item[{size\+\_\+t}]{n}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deallocates the object {\ttfamily p} 

The pool supports allocation only single object ({\ttfamily n} = 1). If {\ttfamily n} \texorpdfstring{$>$}{>} 1 the behaviour is undefined.

If the queue is not full, {\ttfamily p} is pushed into the queue. Otherwise, {\ttfamily p} is deallocated by allocator provided. 

该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
external/libcds/cds/memory/\mbox{\hyperlink{vyukov__queue__pool_8h}{vyukov\+\_\+queue\+\_\+pool.\+h}}\end{DoxyCompactItemize}
