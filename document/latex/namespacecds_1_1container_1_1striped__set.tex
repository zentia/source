\doxysection{cds\+::container\+::striped\+\_\+set 命名空间参考}
\hypertarget{namespacecds_1_1container_1_1striped__set}{}\label{namespacecds_1_1container_1_1striped__set}\index{cds::container::striped\_set@{cds::container::striped\_set}}


Striped hash set related definitions  


\doxysubsubsection*{类}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classcds_1_1container_1_1striped__set_1_1adapt}{adapt}}
\begin{DoxyCompactList}\small\item\em Default adapter for intrusive striped/refinable hash set \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{类型定义}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$size\+\_\+t Load\+Factor$>$ }\\using \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_a2934a868ebde410fca08353b1da5973e}{load\+\_\+factor\+\_\+resizing}} = \mbox{\hyperlink{structcds_1_1intrusive_1_1striped__set_1_1load__factor__resizing}{cds\+::intrusive\+::striped\+\_\+set\+::load\+\_\+factor\+\_\+resizing}}$<$Load\+Factor$>$
\begin{DoxyCompactList}\small\item\em Load factor based resizing policy    \end{DoxyCompactList}\item 
{\footnotesize template$<$size\+\_\+t Numerator, size\+\_\+t Denominator = 1$>$ }\\using \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_a6d92ebe8893f51590311f8518509e116}{rational\+\_\+load\+\_\+factor\+\_\+resizing}} = \mbox{\hyperlink{structcds_1_1intrusive_1_1striped__set_1_1rational__load__factor__resizing}{cds\+::intrusive\+::striped\+\_\+set\+::rational\+\_\+load\+\_\+factor\+\_\+resizing}}$<$Numerator, Denominator$>$
\begin{DoxyCompactList}\small\item\em Rational load factor resizing policy    \end{DoxyCompactList}\item 
{\footnotesize template$<$size\+\_\+t Threshold$>$ }\\using \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_a01bcbbda8462f13876de492298df10a4}{single\+\_\+bucket\+\_\+size\+\_\+threshold}} = \mbox{\hyperlink{structcds_1_1intrusive_1_1striped__set_1_1single__bucket__size__threshold}{cds\+::intrusive\+::striped\+\_\+set\+::single\+\_\+bucket\+\_\+size\+\_\+threshold}}$<$Threshold$>$
\begin{DoxyCompactList}\small\item\em Single bucket threshold resizing policy    \end{DoxyCompactList}\item 
typedef \mbox{\hyperlink{structcds_1_1intrusive_1_1striped__set_1_1no__resizing}{cds\+::intrusive\+::striped\+\_\+set\+::no\+\_\+resizing}} \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_a1a6926eacdbf9fb4fc264d6d85d353c2}{no\+\_\+resizing}}
\begin{DoxyCompactList}\small\item\em Dummy resizing policy    \end{DoxyCompactList}\item 
{\footnotesize template$<$class Lock = std\+::mutex, class Alloc = CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR$>$ }\\using \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_aaf61af57cc14c32b696e0a70593a30e4}{striping}} = \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1striping}{cds\+::intrusive\+::striped\+\_\+set\+::striping}}$<$Lock, Alloc$>$
\begin{DoxyCompactList}\small\item\em Lock striping concurrent access policy    \end{DoxyCompactList}\item 
{\footnotesize template$<$class Recursive\+Lock = std\+::recursive\+\_\+mutex, typename Back\+Off = cds\+::backoff\+::yield, class Alloc = CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR$>$ }\\using \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_af1022e641c5c9fa7c8ae0de91c468f77}{refinable}} = \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable}{cds\+::intrusive\+::striped\+\_\+set\+::refinable}}$<$Recursive\+Lock, Back\+Off, Alloc $>$
\begin{DoxyCompactList}\small\item\em Refinable concurrent access policy    \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}
Striped hash set related definitions 

\doxysubsection{类型定义说明}
\Hypertarget{namespacecds_1_1container_1_1striped__set_a2934a868ebde410fca08353b1da5973e}\index{cds::container::striped\_set@{cds::container::striped\_set}!load\_factor\_resizing@{load\_factor\_resizing}}
\index{load\_factor\_resizing@{load\_factor\_resizing}!cds::container::striped\_set@{cds::container::striped\_set}}
\doxysubsubsection{\texorpdfstring{load\_factor\_resizing}{load\_factor\_resizing}}
{\footnotesize\ttfamily \label{namespacecds_1_1container_1_1striped__set_a2934a868ebde410fca08353b1da5973e} 
template$<$size\+\_\+t Load\+Factor$>$ \\
using \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_a2934a868ebde410fca08353b1da5973e}{cds\+::container\+::striped\+\_\+set\+::load\+\_\+factor\+\_\+resizing}} = \mbox{\hyperlink{structcds_1_1intrusive_1_1striped__set_1_1load__factor__resizing}{cds\+::intrusive\+::striped\+\_\+set\+::load\+\_\+factor\+\_\+resizing}}$<$Load\+Factor$>$}



Load factor based resizing policy    

When total item count in a container exceeds {\ttfamily container.\+bucket\+\_\+count() \texorpdfstring{$\ast$}{*} Load\+Factor} then resizing is needed.

This policy is stateless.

The {\ttfamily reset()} function is called after the resizing is done. The function is intended for resetting internal state of the policy.    \Hypertarget{namespacecds_1_1container_1_1striped__set_a1a6926eacdbf9fb4fc264d6d85d353c2}\index{cds::container::striped\_set@{cds::container::striped\_set}!no\_resizing@{no\_resizing}}
\index{no\_resizing@{no\_resizing}!cds::container::striped\_set@{cds::container::striped\_set}}
\doxysubsubsection{\texorpdfstring{no\_resizing}{no\_resizing}}
{\footnotesize\ttfamily \label{namespacecds_1_1container_1_1striped__set_a1a6926eacdbf9fb4fc264d6d85d353c2} 
typedef \mbox{\hyperlink{structcds_1_1intrusive_1_1striped__set_1_1no__resizing}{cds\+::intrusive\+::striped\+\_\+set\+::no\+\_\+resizing}} \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_a1a6926eacdbf9fb4fc264d6d85d353c2}{cds\+::container\+::striped\+\_\+set\+::no\+\_\+resizing}}}



Dummy resizing policy    

This policy is dummy and always returns {\ttfamily false} that means no resizing is needed.

This policy is stateless.    \Hypertarget{namespacecds_1_1container_1_1striped__set_a6d92ebe8893f51590311f8518509e116}\index{cds::container::striped\_set@{cds::container::striped\_set}!rational\_load\_factor\_resizing@{rational\_load\_factor\_resizing}}
\index{rational\_load\_factor\_resizing@{rational\_load\_factor\_resizing}!cds::container::striped\_set@{cds::container::striped\_set}}
\doxysubsubsection{\texorpdfstring{rational\_load\_factor\_resizing}{rational\_load\_factor\_resizing}}
{\footnotesize\ttfamily \label{namespacecds_1_1container_1_1striped__set_a6d92ebe8893f51590311f8518509e116} 
template$<$size\+\_\+t Numerator, size\+\_\+t Denominator = 1$>$ \\
using \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_a6d92ebe8893f51590311f8518509e116}{cds\+::container\+::striped\+\_\+set\+::rational\+\_\+load\+\_\+factor\+\_\+resizing}} = \mbox{\hyperlink{structcds_1_1intrusive_1_1striped__set_1_1rational__load__factor__resizing}{cds\+::intrusive\+::striped\+\_\+set\+::rational\+\_\+load\+\_\+factor\+\_\+resizing}}$<$Numerator, Denominator$>$}



Rational load factor resizing policy    

When total item count in a container exceeds {\ttfamily container.\+bucket\+\_\+count() \texorpdfstring{$\ast$}{*} Numerator / Denominator} then resizing is needed.

This policy is stateless\+: {\ttfamily Numerator} and {\ttfamily Denominator} specifies in compile time as template arguments    \Hypertarget{namespacecds_1_1container_1_1striped__set_af1022e641c5c9fa7c8ae0de91c468f77}\index{cds::container::striped\_set@{cds::container::striped\_set}!refinable@{refinable}}
\index{refinable@{refinable}!cds::container::striped\_set@{cds::container::striped\_set}}
\doxysubsubsection{\texorpdfstring{refinable}{refinable}}
{\footnotesize\ttfamily \label{namespacecds_1_1container_1_1striped__set_af1022e641c5c9fa7c8ae0de91c468f77} 
template$<$class Recursive\+Lock = std\+::recursive\+\_\+mutex, typename Back\+Off = cds\+::backoff\+::yield, class Alloc = CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR$>$ \\
using \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_af1022e641c5c9fa7c8ae0de91c468f77}{cds\+::container\+::striped\+\_\+set\+::refinable}} = \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1refinable}{cds\+::intrusive\+::striped\+\_\+set\+::refinable}}$<$Recursive\+Lock, Back\+Off, Alloc $>$}



Refinable concurrent access policy    

This is one of available \doxylink{structcds_1_1opt_1_1mutex__policy}{opt\+::mutex\+\_\+policy} option type for \doxylink{classcds_1_1container_1_1_striped_set}{Striped\+Set}

Refining is like a striping technique (see \doxylink{namespacecds_1_1container_1_1striped__set_aaf61af57cc14c32b696e0a70593a30e4}{striped\+\_\+set\+::striping}) but it allows growing the size of lock array when resizing the hash table. So, the sizes of hash table and lock array are equal.

Template arguments\+:
\begin{DoxyItemize}
\item {\ttfamily Recursive\+Lock} -\/ the type of mutex. Reentrant (recursive) mutex is required. The default is {\ttfamily std\+::recursive\+\_\+mutex}. The mutex type should be default-\/constructible.
\item {\ttfamily Back\+Off} -\/ back-\/off strategy. Default is \doxylink{structcds_1_1backoff_1_1yield}{cds\+::backoff\+::yield}
\item {\ttfamily Alloc} -\/ allocator type used for lock array memory allocation. Default is {\ttfamily CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR}.    
\end{DoxyItemize}\Hypertarget{namespacecds_1_1container_1_1striped__set_a01bcbbda8462f13876de492298df10a4}\index{cds::container::striped\_set@{cds::container::striped\_set}!single\_bucket\_size\_threshold@{single\_bucket\_size\_threshold}}
\index{single\_bucket\_size\_threshold@{single\_bucket\_size\_threshold}!cds::container::striped\_set@{cds::container::striped\_set}}
\doxysubsubsection{\texorpdfstring{single\_bucket\_size\_threshold}{single\_bucket\_size\_threshold}}
{\footnotesize\ttfamily \label{namespacecds_1_1container_1_1striped__set_a01bcbbda8462f13876de492298df10a4} 
template$<$size\+\_\+t Threshold$>$ \\
using \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_a01bcbbda8462f13876de492298df10a4}{cds\+::container\+::striped\+\_\+set\+::single\+\_\+bucket\+\_\+size\+\_\+threshold}} = \mbox{\hyperlink{structcds_1_1intrusive_1_1striped__set_1_1single__bucket__size__threshold}{cds\+::intrusive\+::striped\+\_\+set\+::single\+\_\+bucket\+\_\+size\+\_\+threshold}}$<$Threshold$>$}



Single bucket threshold resizing policy    

If any single bucket size exceeds the global {\ttfamily Threshold} then resizing is needed.

This policy is stateless.    \Hypertarget{namespacecds_1_1container_1_1striped__set_aaf61af57cc14c32b696e0a70593a30e4}\index{cds::container::striped\_set@{cds::container::striped\_set}!striping@{striping}}
\index{striping@{striping}!cds::container::striped\_set@{cds::container::striped\_set}}
\doxysubsubsection{\texorpdfstring{striping}{striping}}
{\footnotesize\ttfamily \label{namespacecds_1_1container_1_1striped__set_aaf61af57cc14c32b696e0a70593a30e4} 
template$<$class Lock = std\+::mutex, class Alloc = CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR$>$ \\
using \mbox{\hyperlink{namespacecds_1_1container_1_1striped__set_aaf61af57cc14c32b696e0a70593a30e4}{cds\+::container\+::striped\+\_\+set\+::striping}} = \mbox{\hyperlink{classcds_1_1intrusive_1_1striped__set_1_1striping}{cds\+::intrusive\+::striped\+\_\+set\+::striping}}$<$Lock, Alloc$>$}



Lock striping concurrent access policy    

This is one of available \doxylink{structcds_1_1opt_1_1mutex__policy}{opt\+::mutex\+\_\+policy} option type for \doxylink{classcds_1_1container_1_1_striped_set}{Striped\+Set}

Lock striping is very simple technique. The set consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When set is resized, bucket table capacity will be doubled but lock array will not. The lock {\ttfamily i} protects each bucket {\ttfamily j}, where {\ttfamily  j = i mod L }, where {\ttfamily L} -\/ the size of lock array.

The policy contains an internal array of {\ttfamily Lock} locks.

Template arguments\+:
\begin{DoxyItemize}
\item {\ttfamily Lock} -\/ the type of mutex. The default is {\ttfamily std\+::mutex}. The mutex type should be default-\/constructible. Note that a spin-\/lock is not so good suitable for lock striping for performance reason.
\item {\ttfamily Alloc} -\/ allocator type used for lock array memory allocation. Default is {\ttfamily CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR}.    
\end{DoxyItemize}