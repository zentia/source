\chapter{Parallel Find}
\hypertarget{cuda_flow_find}{}\label{cuda_flow_find}\index{Parallel Find@{Parallel Find}}
Taskflow provides standalone template methods for finding elements in the given ranges using CUDA.\hypertarget{cuda_flow_find_CUDAParallelFindIncludeTheHeader}{}\doxysection{\texorpdfstring{Include the Header}{Include the Header}}\label{cuda_flow_find_CUDAParallelFindIncludeTheHeader}
You need to include the header file, {\ttfamily taskflow/cuda/algorithm/find.hpp}, for creating a parallel-\/find task.\hypertarget{cuda_flow_find_cudaFlowFindItems}{}\doxysection{\texorpdfstring{Find an Element in a Range}{Find an Element in a Range}}\label{cuda_flow_find_cudaFlowFindItems}
tf\+::cuda\+Flow\+::find\+\_\+if finds the index of the first element in the range {\ttfamily \mbox{[}first, last)} that satisfies the given criteria. This is equivalent to the parallel execution of the following loop\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{unsigned}\ idx\ =\ 0;}
\DoxyCodeLine{\textcolor{keywordflow}{for}(;\ first\ !=\ last;\ ++first,\ ++idx)\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{if}\ (\mbox{\hyperlink{main-override_8cpp_a117104b82864d3b23ec174af6d392709}{p}}(*first))\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ idx;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ idx;}

\end{DoxyCode}


If no such an element is found, the size of the range is returned. The following code finds the index of the first element that is dividable by {\ttfamily 17} over a range of one million elements.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}\ =\ 1000000;}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}\ =\ \mbox{\hyperlink{namespacetf_ad289846c38e3f122e1315d906243fc8b}{tf::cuda\_malloc\_shared<int>}}(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}});\ \ \ \ \ \ \ \textcolor{comment}{//\ vector}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ idx\ =\ \mbox{\hyperlink{namespacetf_ad289846c38e3f122e1315d906243fc8b}{tf::cuda\_malloc\_shared<unsigned>}}(1);\ \ \textcolor{comment}{//\ index}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ initializes\ the\ data}}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}=0;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}<\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}};\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}[\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}++]\ =\ rand());}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ finds\ the\ index\ of\ the\ first\ element\ that\ is\ a\ multiple\ of\ 17}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_flow}{tf::cudaFlow}}\ cudaflow;}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}\ =\ cudaflow.find\_if(}
\DoxyCodeLine{\ \ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}},\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}+\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ idx,\ []\ \_\_device\_\_\ (\textcolor{keyword}{auto}\ \mbox{\hyperlink{_cwise__arg_8cpp_a49bb5a0db288a22a099643d44c5abbd6}{v}})\ \{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{_cwise__arg_8cpp_a49bb5a0db288a22a099643d44c5abbd6}{v}}\%17\ ==\ 0;\ \}}
\DoxyCodeLine{);}
\DoxyCodeLine{cudaflow.offload();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ verifies\ the\ result}}
\DoxyCodeLine{\textcolor{keywordflow}{if}(*idx\ !=\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}})\ \{}
\DoxyCodeLine{\ \ assert(\mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}[*idx]\ \%17\ ==\ 0);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ deletes\ the\ memory}}
\DoxyCodeLine{\mbox{\hyperlink{namespacetf_ac7a8fe7456b888d6072ba94783c5003c}{tf::cuda\_free}}(\mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}});}
\DoxyCodeLine{\mbox{\hyperlink{namespacetf_ac7a8fe7456b888d6072ba94783c5003c}{tf::cuda\_free}}(idx);}

\end{DoxyCode}
\hypertarget{cuda_flow_find_cudaFlowFindMinItems}{}\doxysection{\texorpdfstring{Find the Minimum Element in a Range}{Find the Minimum Element in a Range}}\label{cuda_flow_find_cudaFlowFindMinItems}
tf\+::cuda\+Flow\+::min\+\_\+element finds the index of the minimum element in the given range {\ttfamily \mbox{[}first, last)} using the given comparison function object. This is equivalent to a parallel execution of the following loop\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{if}(first\ ==\ last)\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ smallest\ =\ first;}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (++first;\ first\ !=\ last;\ ++first)\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{if}\ (op(*first,\ *smallest))\ \{}
\DoxyCodeLine{\ \ \ \ smallest\ =\ first;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ std::distance(first,\ smallest);}

\end{DoxyCode}


The following code finds the index of the minimum element in a range of one millions elements.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}\ =\ 1000000;}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}\ =\ \mbox{\hyperlink{namespacetf_ad289846c38e3f122e1315d906243fc8b}{tf::cuda\_malloc\_shared<int>}}(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}});\ \ \ \ \ \ \ \textcolor{comment}{//\ vector}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ idx\ =\ \mbox{\hyperlink{namespacetf_ad289846c38e3f122e1315d906243fc8b}{tf::cuda\_malloc\_shared<unsigned>}}(1);\ \ \textcolor{comment}{//\ index}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ initializes\ the\ data}}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}=0;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}<\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}};\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}[\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}++]\ =\ rand());}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ finds\ the\ minimum\ element\ using\ the\ less\ comparator}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_flow}{tf::cudaFlow}}\ cudaflow;}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}\ =\ cudaflow.min\_element(}
\DoxyCodeLine{\ \ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}},\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}+\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ idx,\ []\ \_\_device\_\_\ (\textcolor{keyword}{auto}\ \mbox{\hyperlink{_cwise__product_8cpp_ad2cbe4616e813eb9af81732dca777b24}{a}},\ \textcolor{keyword}{auto}\ \mbox{\hyperlink{offscreen_8c_a846c9667e34d56c560bb7f0ac6e173f6}{b}})\ \{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{_cwise__product_8cpp_ad2cbe4616e813eb9af81732dca777b24}{a}}<\mbox{\hyperlink{offscreen_8c_a846c9667e34d56c560bb7f0ac6e173f6}{b}};\ \}}
\DoxyCodeLine{);}
\DoxyCodeLine{cudaflow.offload();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ verifies\ the\ result}}
\DoxyCodeLine{assert(\mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}[*idx]\ ==\ *std::min\_element(\mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}},\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}+\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ std::less<int>\{\}));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ deletes\ the\ memory}}
\DoxyCodeLine{\mbox{\hyperlink{namespacetf_ac7a8fe7456b888d6072ba94783c5003c}{tf::cuda\_free}}(\mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}});}
\DoxyCodeLine{\mbox{\hyperlink{namespacetf_ac7a8fe7456b888d6072ba94783c5003c}{tf::cuda\_free}}(idx);}

\end{DoxyCode}
\hypertarget{cuda_flow_find_cudaFlowFindMaxItems}{}\doxysection{\texorpdfstring{Find the Maximum Element in a Range}{Find the Maximum Element in a Range}}\label{cuda_flow_find_cudaFlowFindMaxItems}
Similar to tf\+::cuda\+Flow\+::min\+\_\+element, tf\+::cuda\+Flow\+::max\+\_\+element finds the index of the maximum element in the given range {\ttfamily \mbox{[}first, last)} using the given comparison function object. This is equivalent to a parallel execution of the following loop\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{if}(first\ ==\ last)\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ largest\ =\ first;}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (++first;\ first\ !=\ last;\ ++first)\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{if}\ (op(*largest,\ *first))\ \{}
\DoxyCodeLine{\ \ \ \ largest\ =\ first;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordflow}{return}\ std::distance(first,\ largest);}

\end{DoxyCode}


The following code finds the index of the maximum element in a range of one millions elements.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}}\ =\ 1000000;}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}\ =\ \mbox{\hyperlink{namespacetf_ad289846c38e3f122e1315d906243fc8b}{tf::cuda\_malloc\_shared<int>}}(\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}});\ \ \ \ \ \ \ \textcolor{comment}{//\ vector}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ idx\ =\ \mbox{\hyperlink{namespacetf_ad289846c38e3f122e1315d906243fc8b}{tf::cuda\_malloc\_shared<unsigned>}}(1);\ \ \textcolor{comment}{//\ index}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ initializes\ the\ data}}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}=0;\ \mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}<\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}};\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}[\mbox{\hyperlink{_bi_c_g_s_t_a_b__step__by__step_8cpp_acb559820d9ca11295b4500f179ef6392}{i}}++]\ =\ rand());}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ finds\ the\ maximum\ element\ using\ the\ less\ comparator}}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_flow}{tf::cudaFlow}}\ cudaflow;}
\DoxyCodeLine{\mbox{\hyperlink{classtf_1_1cuda_task}{tf::cudaTask}}\ \mbox{\hyperlink{test__partitioner__whitebox_8h_a5c4cf3d37a4eee22275de22cb9619863}{task}}\ =\ cudaflow.max\_element(}
\DoxyCodeLine{\ \ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}},\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}+\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ idx,\ []\ \_\_device\_\_\ (\textcolor{keyword}{auto}\ \mbox{\hyperlink{_cwise__product_8cpp_ad2cbe4616e813eb9af81732dca777b24}{a}},\ \textcolor{keyword}{auto}\ \mbox{\hyperlink{offscreen_8c_a846c9667e34d56c560bb7f0ac6e173f6}{b}})\ \{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{_cwise__product_8cpp_ad2cbe4616e813eb9af81732dca777b24}{a}}<\mbox{\hyperlink{offscreen_8c_a846c9667e34d56c560bb7f0ac6e173f6}{b}};\ \}}
\DoxyCodeLine{);}
\DoxyCodeLine{cudaflow.offload();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ verifies\ the\ result}}
\DoxyCodeLine{assert(\mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}[*idx]\ ==\ *std::max\_element(\mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}},\ \mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}}+\mbox{\hyperlink{main-override-static_8c_a0240ac851181b84ac374872dc5434ee4}{N}},\ std::less<int>\{\}));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ deletes\ the\ memory}}
\DoxyCodeLine{\mbox{\hyperlink{namespacetf_ac7a8fe7456b888d6072ba94783c5003c}{tf::cuda\_free}}(\mbox{\hyperlink{benchmarks_2for__each_2for__each_8hpp_ad86cbaae2e3f21959301250e9f7c2701}{vec}});}
\DoxyCodeLine{\mbox{\hyperlink{namespacetf_ac7a8fe7456b888d6072ba94783c5003c}{tf::cuda\_free}}(idx);}

\end{DoxyCode}
\hypertarget{cuda_flow_find_cudaFlowFindMiscellaneousItems}{}\doxysection{\texorpdfstring{Miscellaneous Items}{Miscellaneous Items}}\label{cuda_flow_find_cudaFlowFindMiscellaneousItems}
Parallel find algorithms are also available in \doxylink{classtf_1_1cuda_flow_capturer}{tf\+::cuda\+Flow\+Capturer} with the same API. 