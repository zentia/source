\chapter{Environment Options}
\hypertarget{environment}{}\label{environment}\index{Environment Options@{Environment Options}}
You can set further options either programmatically (using \href{https://microsoft.github.io/mimalloc/group__options.html}{\texttt{ {\ttfamily mi\+\_\+option\+\_\+set}}}), or via environment variables\+:


\begin{DoxyItemize}
\item {\ttfamily MIMALLOC\+\_\+\+SHOW\+\_\+\+STATS=1}\+: show statistics when the program terminates.
\item {\ttfamily MIMALLOC\+\_\+\+VERBOSE=1}\+: show verbose messages.
\item {\ttfamily MIMALLOC\+\_\+\+SHOW\+\_\+\+ERRORS=1}\+: show error and warning messages.
\end{DoxyItemize}

Advanced options\+:


\begin{DoxyItemize}
\item {\ttfamily MIMALLOC\+\_\+\+ARENA\+\_\+\+EAGER\+\_\+\+COMMIT=2}\+: turns on eager commit for the large arenas (usually 1GiB) from which mimalloc allocates segments and pages. Set this to 2 (default) to only enable this on overcommit systems (e.\+g. Linux). Set this to 1 to enable explicitly on other systems as well (like Windows or mac\+OS) which may improve performance (as the whole arena is committed at once). Note that eager commit only increases the commit but not the actual the peak resident set (rss) so it is generally ok to enable this.
\item {\ttfamily MIMALLOC\+\_\+\+PURGE\+\_\+\+DELAY=N}\+: the delay in {\ttfamily N} milli-\/seconds (by default {\ttfamily 10}) after which mimalloc will purge OS pages that are not in use. This signals to the OS that the underlying physical memory can be reused which can reduce memory fragmentation especially in long running (server) programs. Setting {\ttfamily N} to {\ttfamily 0} purges immediately when a page becomes unused which can improve memory usage but also decreases performance. Setting {\ttfamily N} to a higher value like {\ttfamily 100} can improve performance (sometimes by a lot) at the cost of potentially using more memory at times. Setting it to {\ttfamily -\/1} disables purging completely.
\item {\ttfamily MIMALLOC\+\_\+\+PURGE\+\_\+\+DECOMMITS=1}\+: By default "{}purging"{} memory means unused memory is decommitted ({\ttfamily MEM\+\_\+\+DECOMMIT} on Windows, {\ttfamily MADV\+\_\+\+DONTNEED} (which decresease rss immediately) on {\ttfamily mmap} systems). Set this to 0 to instead "{}reset"{} unused memory on a purge ({\ttfamily MEM\+\_\+\+RESET} on Windows, generally {\ttfamily MADV\+\_\+\+FREE} (which does not decrease rss immediately) on {\ttfamily mmap} systems). Mimalloc generally does not "{}free"{} OS memory but only "{}purges"{} OS memory, in other words, it tries to keep virtual address ranges and decommits within those ranges (to make the underlying physical memory available to other processes).
\end{DoxyItemize}

Further options for large workloads and services\+:


\begin{DoxyItemize}
\item {\ttfamily MIMALLOC\+\_\+\+USE\+\_\+\+NUMA\+\_\+\+NODES=N}\+: pretend there are at most {\ttfamily N} NUMA nodes. If not set, the actual NUMA nodes are detected at runtime. Setting {\ttfamily N} to 1 may avoid problems in some virtual environments. Also, setting it to a lower number than the actual NUMA nodes is fine and will only cause threads to potentially allocate more memory across actual NUMA nodes (but this can happen in any case as NUMA local allocation is always a best effort but not guaranteed).
\item {\ttfamily MIMALLOC\+\_\+\+ALLOW\+\_\+\+LARGE\+\_\+\+OS\+\_\+\+PAGES=1}\+: use large OS pages (2 or 4MiB) when available; for some workloads this can significantly improve performance. When this option is disabled (default), it also disables transparent huge pages (THP) for the process (on Linux and Android). On Linux the default setting is 2 -- this enables the use of large pages through THP only. Use {\ttfamily MIMALLOC\+\_\+\+VERBOSE} to check if the large OS pages are enabled -- usually one needs to explicitly give permissions for large OS pages (as on \href{https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/enable-the-lock-pages-in-memory-option-windows?view=sql-server-2017}{\texttt{ Windows}} and \href{https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/tuning_and_optimizing_red_hat_enterprise_linux_for_oracle_9i_and_10g_databases/sect-oracle_9i_and_10g_tuning_guide-large_memory_optimization_big_pages_and_huge_pages-configuring_huge_pages_in_red_hat_enterprise_linux_4_or_5}{\texttt{ Linux}}). However, sometimes the OS is very slow to reserve contiguous physical memory for large OS pages so use with care on systems that can have fragmented memory (for that reason, we generally recommend to use {\ttfamily MIMALLOC\+\_\+\+RESERVE\+\_\+\+HUGE\+\_\+\+OS\+\_\+\+PAGES} instead whenever possible).
\item {\ttfamily MIMALLOC\+\_\+\+RESERVE\+\_\+\+HUGE\+\_\+\+OS\+\_\+\+PAGES=N}\+: where {\ttfamily N} is the number of 1GiB {\itshape huge} OS pages. This reserves the huge pages at startup and sometimes this can give a large (latency) performance improvement on big workloads. Usually it is better to not use {\ttfamily MIMALLOC\+\_\+\+ALLOW\+\_\+\+LARGE\+\_\+\+OS\+\_\+\+PAGES=1} in combination with this setting. Just like large OS pages, use with care as reserving contiguous physical memory can take a long time when memory is fragmented (but reserving the huge pages is done at startup only once). Note that we usually need to explicitly give permission for huge OS pages (as on \href{https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/enable-the-lock-pages-in-memory-option-windows?view=sql-server-2017}{\texttt{ Windows}} and \href{https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/tuning_and_optimizing_red_hat_enterprise_linux_for_oracle_9i_and_10g_databases/sect-oracle_9i_and_10g_tuning_guide-large_memory_optimization_big_pages_and_huge_pages-configuring_huge_pages_in_red_hat_enterprise_linux_4_or_5}{\texttt{ Linux}})). With huge OS pages, it may be beneficial to set the setting {\ttfamily MIMALLOC\+\_\+\+EAGER\+\_\+\+COMMIT\+\_\+\+DELAY=N} ({\ttfamily N} is 1 by default) to delay the initial {\ttfamily N} segments (of 4MiB) of a thread to not allocate in the huge OS pages; this prevents threads that are short lived and allocate just a little to take up space in the huge OS page area (which cannot be purged as huge OS pages are pinned to physical memory). The huge pages are usually allocated evenly among NUMA nodes. We can use {\ttfamily MIMALLOC\+\_\+\+RESERVE\+\_\+\+HUGE\+\_\+\+OS\+\_\+\+PAGES\+\_\+\+AT=N} where {\ttfamily N} is the numa node (starting at 0) to allocate all the huge pages at a specific numa node instead.
\end{DoxyItemize}

Use caution when using {\ttfamily fork} in combination with either large or huge OS pages\+: on a fork, the OS uses copy-\/on-\/write for all pages in the original process including the huge OS pages. When any memory is now written in that area, the OS will copy the entire 1GiB huge page (or 2MiB large page) which can cause the memory usage to grow in large increments. 