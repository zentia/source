\doxysection{tbb.\+pool.\+Pool类 参考}
\hypertarget{classtbb_1_1pool_1_1_pool}{}\label{classtbb_1_1pool_1_1_pool}\index{tbb.pool.Pool@{tbb.pool.Pool}}


类 tbb.\+pool.\+Pool 继承关系图\+:
% FIG 0


tbb.\+pool.\+Pool 的协作图\+:
% FIG 1
\doxysubsubsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_a58c9ff98d40e9ef17d167bed1b44d9ce}{\+\_\+\+\_\+init\+\_\+\+\_\+}} (self, nworkers=0, \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{name}}="{}Pool"{})
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_a65eace511d22758bdf844f7212fcd4bc}{apply}} (self, \mbox{\hyperlink{structfunc}{func}}, \mbox{\hyperlink{tbbproxy_8cpp_acd08a6295eccfeb30c79985f047e4be5}{args}}=(), kwds=dict())
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_a2d153884307097579f7d4cf465c0cbf0}{map}} (self, \mbox{\hyperlink{structfunc}{func}}, iterable, chunksize=None)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_adae7c1b9c221508388652c93cc3159c3}{imap}} (self, \mbox{\hyperlink{structfunc}{func}}, iterable, chunksize=1)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_ab0e38ae75cabb197002b7a54769cd038}{imap\+\_\+unordered}} (self, \mbox{\hyperlink{structfunc}{func}}, iterable, chunksize=1)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_ab51a2ec0f8376ee6bc94f7cae106bec4}{apply\+\_\+async}} (self, \mbox{\hyperlink{structfunc}{func}}, \mbox{\hyperlink{tbbproxy_8cpp_acd08a6295eccfeb30c79985f047e4be5}{args}}=(), kwds=dict(), \mbox{\hyperlink{external_2spine-runtimes_2spine-sfml_2c_2example_2main_8cpp_a2f27b7fc84a39cace84d90f62a8d4c8e}{callback}}=None)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_a9466baa3fb77b9518557df36e52dda97}{map\+\_\+async}} (self, \mbox{\hyperlink{structfunc}{func}}, iterable, chunksize=None, \mbox{\hyperlink{external_2spine-runtimes_2spine-sfml_2c_2example_2main_8cpp_a2f27b7fc84a39cace84d90f62a8d4c8e}{callback}}=None)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_a881c975d1cf536a56b4307a9d3ba02b2}{imap\+\_\+async}} (self, \mbox{\hyperlink{structfunc}{func}}, iterable, chunksize=None, \mbox{\hyperlink{external_2spine-runtimes_2spine-sfml_2c_2example_2main_8cpp_a2f27b7fc84a39cace84d90f62a8d4c8e}{callback}}=None)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_a6bfc003603a06e6010760f03b5cda029}{imap\+\_\+unordered\+\_\+async}} (self, \mbox{\hyperlink{structfunc}{func}}, iterable, chunksize=None, \mbox{\hyperlink{external_2spine-runtimes_2spine-sfml_2c_2example_2main_8cpp_a2f27b7fc84a39cace84d90f62a8d4c8e}{callback}}=None)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_ad5fcc889083e41ae9703fbc4b1d72365}{close}} (self)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_a86b3ef85533ab47e76e48a4c837df097}{terminate}} (self)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_ac5adc3301a656770e8f13660b1e251aa}{join}} (self)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_acd43bd0e28854c6915d46bcf7d6ae13e}{\+\_\+\+\_\+enter\+\_\+\+\_\+}} (self)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_af5a0976fdb6df3eb23e7f0685e5df2fc}{\+\_\+\+\_\+exit\+\_\+\+\_\+}} (self, exc\+\_\+type, exc\+\_\+value, traceback)
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_adf4788cad6523c1fceaf215f59f8511f}{\+\_\+\+\_\+del\+\_\+\+\_\+}} (self)
\end{DoxyCompactItemize}
\doxysubsection*{Public 成员函数 继承自 \mbox{\hyperlink{class_non_copyable}{Non\+Copyable}}}
\begin{DoxyCompactItemize}
\item 
constexpr \mbox{\hyperlink{class_non_copyable_aca9b4d7789282ce2af55d73468edaf2b}{Non\+Copyable}} ()
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_a6982cad72154a652e58d4b2a66d4c007}{\+\_\+create\+\_\+sequences}} (self, \mbox{\hyperlink{structfunc}{func}}, iterable, chunksize, collector)
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected 属性}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classtbb_1_1pool_1_1_pool_ab8d5bb388a49ba7abcee4af6cbfb8a19}{\+\_\+closed}} = \mbox{\hyperlink{bzlib__private_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}
\item 
\mbox{\hyperlink{classtbb_1_1pool_1_1_pool_a9853025a5b37962317e87f61ad666672}{\+\_\+tasks}} = \mbox{\hyperlink{classtbb_1_1task__group}{task\+\_\+group}}()
\item 
list \mbox{\hyperlink{classtbb_1_1pool_1_1_pool_aaa4161afbd7fda24341456b893a4b381}{\+\_\+pool}} = \mbox{[}None,\mbox{]}\texorpdfstring{$\ast$}{*}default\+\_\+num\+\_\+threads()
\end{DoxyCompactItemize}
\doxysubsubsection*{额外继承的成员函数}
\doxysubsection*{Public 属性 继承自 \mbox{\hyperlink{classobject}{object}}}
\begin{DoxyCompactItemize}
\item 
unsigned \mbox{\hyperlink{sugar_8h_ae4f82344f573c70aa1066a2394bba345}{int}} \mbox{\hyperlink{classobject_a895ce377c757e57e2d6464d8642396b7}{id}}
\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classobject_ae5f359a8b8e85c6eaf113fa24ea6f59f}{nextobj}}
\item 
\mbox{\hyperlink{structobject__methods}{object\+\_\+methods}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classobject_a9420bd981702f0b8722e760a4b2a3c9c}{methods}}
\item 
\mbox{\hyperlink{structtexture}{texture}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classobject_a11875926a36060078e812c6927444f08}{tex}}
\end{DoxyCompactItemize}


\doxysubsection{详细描述}
\begin{DoxyVerb}The Pool class provides standard multiprocessing.Pool interface
which is mapped onto Intel(R) TBB tasks executing in its thread pool
\end{DoxyVerb}
 

\doxysubsection{构造及析构函数说明}
\Hypertarget{classtbb_1_1pool_1_1_pool_a58c9ff98d40e9ef17d167bed1b44d9ce}\index{tbb.pool.Pool@{tbb.pool.Pool}!\_\_init\_\_@{\_\_init\_\_}}
\index{\_\_init\_\_@{\_\_init\_\_}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{\_\_init\_\_()}{\_\_init\_\_()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_a58c9ff98d40e9ef17d167bed1b44d9ce} 
tbb.\+pool.\+Pool.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{nworkers}{ = {\ttfamily 0}, }\item[{}]{name}{ = {\ttfamily "{}Pool"{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}\param nworkers (integer) number of worker threads to start
\param name (string) prefix for the worker threads' name
\end{DoxyVerb}
 \Hypertarget{classtbb_1_1pool_1_1_pool_adf4788cad6523c1fceaf215f59f8511f}\index{tbb.pool.Pool@{tbb.pool.Pool}!\_\_del\_\_@{\_\_del\_\_}}
\index{\_\_del\_\_@{\_\_del\_\_}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{\_\_del\_\_()}{\_\_del\_\_()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_adf4788cad6523c1fceaf215f59f8511f} 
tbb.\+pool.\+Pool.\+\_\+\+\_\+del\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self}{}\end{DoxyParamCaption})}

函数调用图\+:
% FIG 2


\doxysubsection{成员函数说明}
\Hypertarget{classtbb_1_1pool_1_1_pool_acd43bd0e28854c6915d46bcf7d6ae13e}\index{tbb.pool.Pool@{tbb.pool.Pool}!\_\_enter\_\_@{\_\_enter\_\_}}
\index{\_\_enter\_\_@{\_\_enter\_\_}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{\_\_enter\_\_()}{\_\_enter\_\_()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_acd43bd0e28854c6915d46bcf7d6ae13e} 
tbb.\+pool.\+Pool.\+\_\+\+\_\+enter\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self}{}\end{DoxyParamCaption})}

\Hypertarget{classtbb_1_1pool_1_1_pool_af5a0976fdb6df3eb23e7f0685e5df2fc}\index{tbb.pool.Pool@{tbb.pool.Pool}!\_\_exit\_\_@{\_\_exit\_\_}}
\index{\_\_exit\_\_@{\_\_exit\_\_}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{\_\_exit\_\_()}{\_\_exit\_\_()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_af5a0976fdb6df3eb23e7f0685e5df2fc} 
tbb.\+pool.\+Pool.\+\_\+\+\_\+exit\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{exc\+\_\+type}{, }\item[{}]{exc\+\_\+value}{, }\item[{}]{traceback}{}\end{DoxyParamCaption})}

函数调用图\+:
% FIG 3
\Hypertarget{classtbb_1_1pool_1_1_pool_a6982cad72154a652e58d4b2a66d4c007}\index{tbb.pool.Pool@{tbb.pool.Pool}!\_create\_sequences@{\_create\_sequences}}
\index{\_create\_sequences@{\_create\_sequences}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{\_create\_sequences()}{\_create\_sequences()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_a6982cad72154a652e58d4b2a66d4c007} 
tbb.\+pool.\+Pool.\+\_\+create\+\_\+sequences (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{func}{, }\item[{}]{iterable}{, }\item[{}]{chunksize}{, }\item[{}]{collector}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Create callable objects to process and pushes them on the
work queue. Each work unit is meant to process a slice of
iterable of size chunksize. If collector is specified, then
the ApplyResult objects associated with the jobs will notify
collector when their result becomes ready.

\return the list callable objects (basically: JobSequences)
pushed onto the work queue
\end{DoxyVerb}
 函数调用图\+:
% FIG 4
\Hypertarget{classtbb_1_1pool_1_1_pool_a65eace511d22758bdf844f7212fcd4bc}\index{tbb.pool.Pool@{tbb.pool.Pool}!apply@{apply}}
\index{apply@{apply}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{apply()}{apply()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_a65eace511d22758bdf844f7212fcd4bc} 
tbb.\+pool.\+Pool.\+apply (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{func}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{kwds}{ = {\ttfamily dict()}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Equivalent of the apply() builtin function. It blocks till
the result is ready.\end{DoxyVerb}
 函数调用图\+:
% FIG 5
\Hypertarget{classtbb_1_1pool_1_1_pool_ab51a2ec0f8376ee6bc94f7cae106bec4}\index{tbb.pool.Pool@{tbb.pool.Pool}!apply\_async@{apply\_async}}
\index{apply\_async@{apply\_async}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{apply\_async()}{apply\_async()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_ab51a2ec0f8376ee6bc94f7cae106bec4} 
tbb.\+pool.\+Pool.\+apply\+\_\+async (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{func}{, }\item[{}]{args}{ = {\ttfamily ()}, }\item[{}]{kwds}{ = {\ttfamily dict()}, }\item[{}]{callback}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}A variant of the apply() method which returns an
ApplyResult object.

If callback is specified then it should be a callable which
accepts a single argument. When the result becomes ready,
callback is applied to it (unless the call failed). callback
should complete immediately since otherwise the thread which
handles the results will get blocked.\end{DoxyVerb}
 函数调用图\+:
% FIG 6
\Hypertarget{classtbb_1_1pool_1_1_pool_ad5fcc889083e41ae9703fbc4b1d72365}\index{tbb.pool.Pool@{tbb.pool.Pool}!close@{close}}
\index{close@{close}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{close()}{close()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_ad5fcc889083e41ae9703fbc4b1d72365} 
tbb.\+pool.\+Pool.\+close (\begin{DoxyParamCaption}\item[{}]{self}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Prevents any more tasks from being submitted to the
pool. Once all the tasks have been completed the worker
processes will exit.\end{DoxyVerb}
 \Hypertarget{classtbb_1_1pool_1_1_pool_adae7c1b9c221508388652c93cc3159c3}\index{tbb.pool.Pool@{tbb.pool.Pool}!imap@{imap}}
\index{imap@{imap}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{imap()}{imap()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_adae7c1b9c221508388652c93cc3159c3} 
tbb.\+pool.\+Pool.\+imap (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{func}{, }\item[{}]{iterable}{, }\item[{}]{chunksize}{ = {\ttfamily 1}}\end{DoxyParamCaption})}

\begin{DoxyVerb}An equivalent of itertools.imap().

The chunksize argument is the same as the one used by the
map() method. For very long iterables using a large value for
chunksize can make the job complete much faster than
using the default value of 1.

Also if chunksize is 1 then the next() method of the iterator
returned by the imap() method has an optional timeout
parameter: next(timeout) will raise processing.TimeoutError if
the result cannot be returned within timeout seconds.
\end{DoxyVerb}
 函数调用图\+:
% FIG 7
\Hypertarget{classtbb_1_1pool_1_1_pool_a881c975d1cf536a56b4307a9d3ba02b2}\index{tbb.pool.Pool@{tbb.pool.Pool}!imap\_async@{imap\_async}}
\index{imap\_async@{imap\_async}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{imap\_async()}{imap\_async()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_a881c975d1cf536a56b4307a9d3ba02b2} 
tbb.\+pool.\+Pool.\+imap\+\_\+async (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{func}{, }\item[{}]{iterable}{, }\item[{}]{chunksize}{ = {\ttfamily None}, }\item[{}]{callback}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}A variant of the imap() method which returns an ApplyResult
object that provides an iterator (next method(timeout)
available).

If callback is specified then it should be a callable which
accepts a single argument. When the resulting iterator becomes
ready, callback is applied to it (unless the call
failed). callback should complete immediately since otherwise
the thread which handles the results will get blocked.\end{DoxyVerb}
 函数调用图\+:
% FIG 8
\Hypertarget{classtbb_1_1pool_1_1_pool_ab0e38ae75cabb197002b7a54769cd038}\index{tbb.pool.Pool@{tbb.pool.Pool}!imap\_unordered@{imap\_unordered}}
\index{imap\_unordered@{imap\_unordered}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{imap\_unordered()}{imap\_unordered()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_ab0e38ae75cabb197002b7a54769cd038} 
tbb.\+pool.\+Pool.\+imap\+\_\+unordered (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{func}{, }\item[{}]{iterable}{, }\item[{}]{chunksize}{ = {\ttfamily 1}}\end{DoxyParamCaption})}

\begin{DoxyVerb}The same as imap() except that the ordering of the results
from the returned iterator should be considered
arbitrary. (Only when there is only one worker process is the
order guaranteed to be "correct".)\end{DoxyVerb}
 函数调用图\+:
% FIG 9
\Hypertarget{classtbb_1_1pool_1_1_pool_a6bfc003603a06e6010760f03b5cda029}\index{tbb.pool.Pool@{tbb.pool.Pool}!imap\_unordered\_async@{imap\_unordered\_async}}
\index{imap\_unordered\_async@{imap\_unordered\_async}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{imap\_unordered\_async()}{imap\_unordered\_async()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_a6bfc003603a06e6010760f03b5cda029} 
tbb.\+pool.\+Pool.\+imap\+\_\+unordered\+\_\+async (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{func}{, }\item[{}]{iterable}{, }\item[{}]{chunksize}{ = {\ttfamily None}, }\item[{}]{callback}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}A variant of the imap_unordered() method which returns an
ApplyResult object that provides an iterator (next
method(timeout) available).

If callback is specified then it should be a callable which
accepts a single argument. When the resulting iterator becomes
ready, callback is applied to it (unless the call
failed). callback should complete immediately since otherwise
the thread which handles the results will get blocked.\end{DoxyVerb}
 函数调用图\+:
% FIG 10
\Hypertarget{classtbb_1_1pool_1_1_pool_ac5adc3301a656770e8f13660b1e251aa}\index{tbb.pool.Pool@{tbb.pool.Pool}!join@{join}}
\index{join@{join}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{join()}{join()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_ac5adc3301a656770e8f13660b1e251aa} 
tbb.\+pool.\+Pool.\+join (\begin{DoxyParamCaption}\item[{}]{self}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Wait for the worker processes to exit. One must call
close() or terminate() before using join().\end{DoxyVerb}
 \Hypertarget{classtbb_1_1pool_1_1_pool_a2d153884307097579f7d4cf465c0cbf0}\index{tbb.pool.Pool@{tbb.pool.Pool}!map@{map}}
\index{map@{map}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{map()}{map()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_a2d153884307097579f7d4cf465c0cbf0} 
tbb.\+pool.\+Pool.\+map (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{func}{, }\item[{}]{iterable}{, }\item[{}]{chunksize}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}A parallel equivalent of the map() builtin function. It
blocks till the result is ready.

This method chops the iterable into a number of chunks which
it submits to the process pool as separate tasks. The
(approximate) size of these chunks can be specified by setting
chunksize to a positive integer.\end{DoxyVerb}
 函数调用图\+:
% FIG 11
\Hypertarget{classtbb_1_1pool_1_1_pool_a9466baa3fb77b9518557df36e52dda97}\index{tbb.pool.Pool@{tbb.pool.Pool}!map\_async@{map\_async}}
\index{map\_async@{map\_async}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{map\_async()}{map\_async()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_a9466baa3fb77b9518557df36e52dda97} 
tbb.\+pool.\+Pool.\+map\+\_\+async (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{}]{func}{, }\item[{}]{iterable}{, }\item[{}]{chunksize}{ = {\ttfamily None}, }\item[{}]{callback}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}A variant of the map() method which returns a ApplyResult
object.

If callback is specified then it should be a callable which
accepts a single argument. When the result becomes ready
callback is applied to it (unless the call failed). callback
should complete immediately since otherwise the thread which
handles the results will get blocked.\end{DoxyVerb}
 函数调用图\+:
% FIG 12
\Hypertarget{classtbb_1_1pool_1_1_pool_a86b3ef85533ab47e76e48a4c837df097}\index{tbb.pool.Pool@{tbb.pool.Pool}!terminate@{terminate}}
\index{terminate@{terminate}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{terminate()}{terminate()}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_a86b3ef85533ab47e76e48a4c837df097} 
tbb.\+pool.\+Pool.\+terminate (\begin{DoxyParamCaption}\item[{}]{self}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Stops the worker processes immediately without completing
outstanding work. When the pool object is garbage collected
terminate() will be called immediately.\end{DoxyVerb}
 函数调用图\+:
% FIG 13


\doxysubsection{类成员变量说明}
\Hypertarget{classtbb_1_1pool_1_1_pool_ab8d5bb388a49ba7abcee4af6cbfb8a19}\index{tbb.pool.Pool@{tbb.pool.Pool}!\_closed@{\_closed}}
\index{\_closed@{\_closed}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{\_closed}{\_closed}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_ab8d5bb388a49ba7abcee4af6cbfb8a19} 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} tbb.\+pool.\+Pool.\+\_\+closed = \mbox{\hyperlink{bzlib__private_8h_a306ebd41c0cd1303b1372c6153f0caf8}{False}}\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classtbb_1_1pool_1_1_pool_aaa4161afbd7fda24341456b893a4b381}\index{tbb.pool.Pool@{tbb.pool.Pool}!\_pool@{\_pool}}
\index{\_pool@{\_pool}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{\_pool}{\_pool}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_aaa4161afbd7fda24341456b893a4b381} 
list tbb.\+pool.\+Pool.\+\_\+pool = \mbox{[}None,\mbox{]}\texorpdfstring{$\ast$}{*}default\+\_\+num\+\_\+threads()\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{classtbb_1_1pool_1_1_pool_a9853025a5b37962317e87f61ad666672}\index{tbb.pool.Pool@{tbb.pool.Pool}!\_tasks@{\_tasks}}
\index{\_tasks@{\_tasks}!tbb.pool.Pool@{tbb.pool.Pool}}
\doxysubsubsection{\texorpdfstring{\_tasks}{\_tasks}}
{\footnotesize\ttfamily \label{classtbb_1_1pool_1_1_pool_a9853025a5b37962317e87f61ad666672} 
tbb.\+pool.\+Pool.\+\_\+tasks = \mbox{\hyperlink{classtbb_1_1task__group}{task\+\_\+group}}()\hspace{0.3cm}{\ttfamily [protected]}}



该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
external/taskflow/3rd-\/party/tbb/python/tbb/\mbox{\hyperlink{pool_8py}{pool.\+py}}\end{DoxyCompactItemize}
