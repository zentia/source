\doxysection{cds\+::container\+::Striped\+Map\texorpdfstring{$<$}{<} Container, Options \texorpdfstring{$>$}{>} 模板类 参考}
\hypertarget{classcds_1_1container_1_1_striped_map}{}\label{classcds_1_1container_1_1_striped_map}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}


Striped hash map  




{\ttfamily \#include $<$striped\+\_\+map.\+h$>$}



类 cds\+::container\+::Striped\+Map\texorpdfstring{$<$}{<} Container, Options \texorpdfstring{$>$}{>} 继承关系图\+:
% FIG 0


cds\+::container\+::Striped\+Map\texorpdfstring{$<$}{<} Container, Options \texorpdfstring{$>$}{>} 的协作图\+:
% FIG 1
\doxysubsubsection*{Public 类型}
\begin{DoxyCompactItemize}
\item 
typedef Container \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a2e8f54fde7d2f4330dbbd32e32da715a}{underlying\+\_\+container\+\_\+type}}
\begin{DoxyCompactList}\small\item\em original intrusive container type for the bucket \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::bucket\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_af41155b6b3ff185f4ee4a64bdf256c7d}{bucket\+\_\+type}}
\begin{DoxyCompactList}\small\item\em container type adapted for hash set \end{DoxyCompactList}\item 
typedef bucket\+\_\+type\+::value\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_abc37b83c74cd041b958aba25ff3ea079}{value\+\_\+type}}
\begin{DoxyCompactList}\small\item\em pair type ({\ttfamily  std\+::pair$<$key\+\_\+type const, mapped\+\_\+type$>$ }) \end{DoxyCompactList}\item 
typedef value\+\_\+type\+::first\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a95d2f85653d88cea2e02fc6c39a5d2b3}{key\+\_\+type}}
\begin{DoxyCompactList}\small\item\em key type \end{DoxyCompactList}\item 
typedef value\+\_\+type\+::second\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_abcd34343ee928de44a8d121cfdbb11b9}{mapped\+\_\+type}}
\begin{DoxyCompactList}\small\item\em mapped type \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::hash \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a6b1b0a9b45e942498737a5652b325e26}{hash}}
\begin{DoxyCompactList}\small\item\em \doxylink{struct_hash}{Hash} functor \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::item\+\_\+counter \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a4097c7d9306f06b3fb0ef3f351387040}{item\+\_\+counter}}
\begin{DoxyCompactList}\small\item\em Item counter \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::resizing\+\_\+policy \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a3155c54ac7cc35f2ab627ce6eb7333e3}{resizing\+\_\+policy}}
\begin{DoxyCompactList}\small\item\em Resizing policy \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::allocator\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a6492d65eb7a28cb6a6714b0c04b826df}{allocator\+\_\+type}}
\begin{DoxyCompactList}\small\item\em allocator type specified in options. \end{DoxyCompactList}\item 
typedef base\+\_\+class\+::mutex\+\_\+policy \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a0c68a4f3ca5a79fcffac0cb2624e0441}{mutex\+\_\+policy}}
\begin{DoxyCompactList}\small\item\em Mutex policy \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a2fb520f4aeda28167438e1f7ccd531df}{Striped\+Map}} ()
\begin{DoxyCompactList}\small\item\em Default ctor. The initial capacity is 16. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a892bd935c22aad68b394f3faa67ce8ec}{Striped\+Map}} (size\+\_\+t n\+Capacity)
\begin{DoxyCompactList}\small\item\em Ctor with initial capacity specified \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map_ab1c828a31c862660ff8b6ae35e89e8d0}{Striped\+Map}} (size\+\_\+t n\+Capacity, \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a3155c54ac7cc35f2ab627ce6eb7333e3}{resizing\+\_\+policy}} const \&resizing\+Policy)
\begin{DoxyCompactList}\small\item\em Ctor with resizing policy (copy semantics) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map_ad331b6324ae414f56df0324d3435a54f}{Striped\+Map}} (size\+\_\+t n\+Capacity, \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a3155c54ac7cc35f2ab627ce6eb7333e3}{resizing\+\_\+policy}} \&\&resizing\+Policy)
\begin{DoxyCompactList}\small\item\em Ctor with resizing policy (move semantics) \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a09d5a55697a29b39d471dd71b580cbc3}{\texorpdfstring{$\sim$}{\string~}\+Striped\+Map}} ()
\begin{DoxyCompactList}\small\item\em Destructor destroys internal data \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a8306ce18508455e5a4761f8a051f6c16}{insert}} (K const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}})
\begin{DoxyCompactList}\small\item\em Inserts new node with key and default value \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K, typename \mbox{\hyperlink{_eigen_solver___eigen_solver___matrix_type_8cpp_a77c224aa52b434918ce65c33175aa8ad}{V}}$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a5543dba6bc798cb924b41de9f98cfedf}{insert}} (K const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, \mbox{\hyperlink{_eigen_solver___eigen_solver___matrix_type_8cpp_a77c224aa52b434918ce65c33175aa8ad}{V}} const \&val)
\begin{DoxyCompactList}\small\item\em Inserts new node \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K, typename Func$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_abd563bbd37f3b08f2763c3cff9abaf49}{insert\+\_\+with}} (const K \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Func \mbox{\hyperlink{structfunc}{func}})
\begin{DoxyCompactList}\small\item\em Inserts new node and initialize it by a functor \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K, typename... Args$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_ab1377e67bb7bf2b40ace6d8bb9f3f3da}{emplace}} (K \&\&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Args \&\&... \mbox{\hyperlink{tbbproxy_8cpp_acd08a6295eccfeb30c79985f047e4be5}{args}})
\begin{DoxyCompactList}\small\item\em For key {\ttfamily key} inserts data of type {\ttfamily \doxylink{classcds_1_1container_1_1_striped_map_abcd34343ee928de44a8d121cfdbb11b9}{mapped\+\_\+type}} created in-\/place from {\ttfamily args} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K, typename Func$>$ }\\std\+::pair$<$ \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} $>$ \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_ad61085c91459e53c8a6d817f64b16fb9}{update}} (K const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Func \mbox{\hyperlink{structfunc}{func}}, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} b\+Allow\+Insert=\mbox{\hyperlink{yyjson_8h_a41f9c5fb8b08eb5dc3edce4dcb37fee7}{true}})
\begin{DoxyCompactList}\small\item\em Updates the node \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_abf4f29d2c1f58e1f92759f3fad808bb3}{erase}} (K const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}})
\begin{DoxyCompactList}\small\item\em Delete {\ttfamily key} from the map \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K, typename Less, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+erase\+\_\+with $>$\+::type$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a0f28cdf88f10e2fcc0910e00c9854f4e}{erase\+\_\+with}} (K const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Less pred)
\begin{DoxyCompactList}\small\item\em Deletes the item from the map using {\ttfamily pred} predicate for searching \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K, typename Func$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a213858e29c6865981935d07665804048}{erase}} (K const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em Delete {\ttfamily key} from the map \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K, typename Less, typename Func, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+erase\+\_\+with $>$\+::type$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_af7ebc1913a673717786c8f7598b9237b}{erase\+\_\+with}} (K const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Less pred, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em Deletes the item from the map using {\ttfamily pred} predicate for searching \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K, typename Func$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a7cc91ff823125ec02014aab0911083f5}{find}} (K const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em \doxylink{struct_find}{Find} the key {\ttfamily key} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K, typename Less, typename Func, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+find\+\_\+with $>$\+::type$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_aa1353dfa60543a01fc0092733129a4fd}{find\+\_\+with}} (K const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Less pred, Func \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})
\begin{DoxyCompactList}\small\item\em \doxylink{struct_find}{Find} the key {\ttfamily val} using {\ttfamily pred} predicate \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a00b5e87952d9a31cb50707f71dfaef61}{contains}} (K const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}})
\begin{DoxyCompactList}\small\item\em Checks whether the map contains {\ttfamily key} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename K, typename Less, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+find\+\_\+with $>$\+::type$>$ }\\\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a9d217945377cb14045e40c4ea862aafd}{contains}} (K const \&\mbox{\hyperlink{ittnotify__static_8h_aeeaf6235e69da2907f537f67e598fc9d}{key}}, Less pred)
\begin{DoxyCompactList}\small\item\em Checks whether the set contains {\ttfamily key} using {\ttfamily pred} predicate for searching \end{DoxyCompactList}\item 
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a0f13b4556ea60dfa9a77c9e44040812b}{clear}} ()
\begin{DoxyCompactList}\small\item\em Clears the map \end{DoxyCompactList}\item 
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_ac1e02f63d146c37c574d3432f84d1ba9}{empty}} () const
\begin{DoxyCompactList}\small\item\em Checks if the map is empty \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a289aecf9771b5c4602375f89871583a3}{size}} () const
\begin{DoxyCompactList}\small\item\em Returns item count in the map \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a856f6f7aa7bbeffd0e447c1fee9e3d4a}{bucket\+\_\+count}} () const
\begin{DoxyCompactList}\small\item\em Returns the size of hash table \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a82a5fb6f0e6a0723b22e70520147407c}{lock\+\_\+count}} () const
\begin{DoxyCompactList}\small\item\em Returns lock array size \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a3155c54ac7cc35f2ab627ce6eb7333e3}{resizing\+\_\+policy}} \& \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a1cc70a631a193852a1a03ea83aa9fa91}{get\+\_\+resizing\+\_\+policy}} ()
\begin{DoxyCompactList}\small\item\em Returns resizing policy object \end{DoxyCompactList}\item 
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a3155c54ac7cc35f2ab627ce6eb7333e3}{resizing\+\_\+policy}} const \& \mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a57cc578587602d60d2fd65e9af0b701d}{get\+\_\+resizing\+\_\+policy}} () const
\begin{DoxyCompactList}\small\item\em Returns resizing policy (const version) \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{详细描述}
\subsubsection*{template$<$class Container, typename... Options$>$\newline
class cds\+::container\+::\+Striped\+Map$<$ Container, Options $>$}
Striped hash map 

Source
\begin{DoxyItemize}
\item \mbox{[}2008\mbox{]} Maurice Herlihy, Nir Shavit "{}\+The Art of Multiprocessor Programming"{}
\end{DoxyItemize}

Lock striping is very simple technique. The map consists of the bucket table and the array of locks. Initially, the capacity of lock array and bucket table is the same. When the map is resized, bucket table capacity will be doubled but lock array will not. The lock {\ttfamily i} protects each bucket {\ttfamily j}, where {\ttfamily  j = i mod L }, where {\ttfamily L} -\/ the size of lock array.

Template arguments\+:
\begin{DoxyItemize}
\item {\ttfamily Container} -\/ the container class that is used as bucket entry. The {\ttfamily Container} class should support an uniform interface described below.
\item {\ttfamily Options} -\/ options
\end{DoxyItemize}

The {\ttfamily Striped\+Map} class does not exactly specify the type of container that should be used as a {\ttfamily Container} bucket. Instead, the class supports different container type for the bucket, for exampe, {\ttfamily std\+::list}, {\ttfamily std\+::map} and others.

Remember that {\ttfamily Striped\+Map} class algorithm ensures sequential blocking access to its bucket through the mutex type you specify among {\ttfamily Options} template arguments.

The {\ttfamily Options} are\+:
\begin{DoxyItemize}
\item {\ttfamily \doxylink{structcds_1_1opt_1_1mutex__policy}{cds\+::opt\+::mutex\+\_\+policy}} -\/ concurrent access policy. Available policies\+: {\ttfamily \doxylink{namespacecds_1_1container_1_1striped__set_aaf61af57cc14c32b696e0a70593a30e4}{striped\+\_\+set\+::striping}}, {\ttfamily \doxylink{namespacecds_1_1container_1_1striped__set_af1022e641c5c9fa7c8ae0de91c468f77}{striped\+\_\+set\+::refinable}}. Default is {\ttfamily striped\+\_\+set\+::striping}.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1hash}{cds\+::opt\+::hash}} -\/ hash functor. Default option value see {\ttfamily opt\+::v\+::hash\+\_\+selector$<$opt\+::none$>$ } which selects default hash functor for your compiler.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1compare}{cds\+::opt\+::compare}} -\/ key comparison functor. No default functor is provided. If the option is not specified, the {\ttfamily opt\+::less} is used.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1less}{cds\+::opt\+::less}} -\/ specifies binary predicate used for key comparison. Default is {\ttfamily std\+::less$<$\+T$>$}.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1item__counter}{cds\+::opt\+::item\+\_\+counter}} -\/ item counter type. Default is {\ttfamily \doxylink{classcds_1_1atomicity_1_1item__counter}{atomicity\+::item\+\_\+counter}} since some operation on the counter is performed without locks. Note that item counting is an essential part of the map algorithm, so dummy counter like as {\ttfamily \doxylink{classcds_1_1atomicity_1_1empty__item__counter}{atomicity\+::empty\+\_\+item\+\_\+counter}} is not suitable.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1allocator}{cds\+::opt\+::allocator}} -\/ the allocator type using for memory allocation of bucket table and lock array. Default is \doxylink{external_2libcds_2cds_2user__setup_2allocator_8h_ad5fb7e3cbe8cf24295f0ea3c165a2d82}{CDS\+\_\+\+DEFAULT\+\_\+\+ALLOCATOR}.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1resizing__policy}{cds\+::opt\+::resizing\+\_\+policy}} -\/ the resizing policy that is a functor that decides when to resize the hash map. Default option value depends on bucket container type\+: for sequential containers like {\ttfamily std\+::list}, {\ttfamily std\+::vector} the resizing policy is {\ttfamily \doxylink{namespacecds_1_1container_1_1striped__set_a2934a868ebde410fca08353b1da5973e}{striped\+\_\+set\+::load\+\_\+factor\+\_\+resizing$<$4$>$} }; for other type of containers like {\ttfamily std\+::map}, {\ttfamily std\+::unordered\+\_\+map} the resizing policy is {\ttfamily \doxylink{namespacecds_1_1container_1_1striped__set_a1a6926eacdbf9fb4fc264d6d85d353c2}{striped\+\_\+set\+::no\+\_\+resizing}}. See \doxylink{group__cds__striped__resizing__policy}{available resizing policy}. Note that the choose of resizing policy depends of {\ttfamily Container} type\+: for sequential containers like {\ttfamily std\+::list}, {\ttfamily std\+::vector} and so on, right choosing of the policy can significantly improve performance. For other, non-\/sequential types of {\ttfamily Container} (like a {\ttfamily std\+::map}) the resizing policy is not so important.
\item {\ttfamily \doxylink{structcds_1_1opt_1_1copy__policy}{cds\+::opt\+::copy\+\_\+policy}} -\/ the copy policy which is used to copy items from the old map to the new one when resizing. The policy can be optionally used in adapted bucket container for performance reasons of resizing. The detail of copy algorithm depends on type of bucket container and explains below.
\end{DoxyItemize}

{\ttfamily opt\+::compare} or {\ttfamily opt\+::less} options are used only in some {\ttfamily Container} class for searching an item. {\ttfamily opt\+::compare} option has the highest priority\+: if {\ttfamily opt\+::compare} is specified, {\ttfamily opt\+::less} is not used.

You can pass other option that would be passed to {\ttfamily adapt} metafunction, see below.

{\bfseries{Internal details}} \begin{DoxyVerb}The \p %StripedMap class cannot utilize the \p Container container specified directly, but only its adapted variant which
supports an unified interface. Internally, the adaptation is made via \p striped_set::adapt metafunction that wraps bucket container
and provides the unified bucket interface suitable for \p %StripedMap. Such adaptation is completely transparent for you -
you don't need to call \p adapt metafunction directly, \p %StripedMap class's internal machinery itself invokes appropriate
\p adapt metafunction to adjust your \p Container container class to \p %StripedMap bucket's internal interface.
All you need is to include a right header before <tt>striped_hash_map.h</tt>.

By default, <tt>striped_set::adapt<AnyContainer, Options...> </tt> metafunction does not make any wrapping to \p AnyContainer,
so, the result <tt>striped_set::adapt<AnyContainer, Options...>::type </tt> is the same as \p AnyContainer.
However, there are a lot of specializations of \p adapt for well-known containers, see table below.
Any of this specialization wraps corresponding container making it suitable for the map's bucket.
Remember, you should include the proper header file for \p adapt <b>before</b> <tt>striped_map.h</tt>.
<table>
    <tr>
        <th>Container</th>
        <th>.h-file for \p adapt</th>
        <th>Example</th>
        <th>Notes</th>
    </tr>
    <tr>
        <td> \p std::list</td>
        <td><tt><cds/container/striped_map/std_list.h></tt></td>
        <td>\code
            #include <cds/container/striped_map/std_list.h>
            #include <cds/container/striped_hash_map.h>
            typedef cds::container::StripedMap<
                std::list< std::pair< const Key, V > >,
                cds::opt::less< std::less<Key> >
            > striped_map;
        \endcode
        </td>
        <td>
            The type of values stored in the \p std::list must be <tt> std::pair< const Key, V > </tt>, where \p Key - key type,  and \p V - value type
            The list is ordered by key \p Key.
            Template argument pack \p Options <b>must</b> contain \p cds::opt::less or \p cds::opt::compare for type \p Key stored in the list.
        </td>
    </tr>
    <tr>
        <td> \p std::map</td>
        <td><tt><cds/container/striped_map/std_map.h></tt></td>
        <td>\code
            #include <cds/container/striped_map/std_map.h>
            #include <cds/container/striped_hash_map.h>
            typedef cds::container::StripedMap<
                std::map< Key, T, std::less<Key> >
            > striped_map;
        \endcode
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td> \p std::unordered_map</td>
        <td><tt><cds/container/striped_map/std_hash_map.h></tt></td>
        <td>\code
            #include <cds/container/striped_map/std_hash_map.h>
            #include <cds/container/striped_hash_map.h>
            typedef cds::container::StripedMap<
                std::unordered_map<
                    Key, T,
                    std::hash<Key>,
                    std::equal_to<Key>
                >
            > striped_map;
        \endcode
        </td>
        <td>
            You should provide two different hash function \p h1 and \p h2 - one for std::unordered_map and other for \p %StripedMap.
            For the best result, \p h1 and \p h2 must be orthogonal i.e. <tt> h1(X) != h2(X) </tt> for any value \p X of type \p Key.
        </td>
    </tr>
    <tr>
        <td> \p boost::container::slist</td>
        <td><tt><cds/container/striped_map/boost_slist.h></tt></td>
        <td>\code
            #include <cds/container/hash_smap/boost_slist.h>
            #include <cds/container/striped_hash_map.h>
            typedef cds::container::StripedMap<
                boost::container::slist< std::pair< const Key, T > >
            > striped_map;
        \endcode
        </td>
        <td>
            The type of values stored in the \p boost::container::slist must be <tt> std::pair< const Key, T > </tt>,
            where \p Key - key type,  and \p T - value type. The list is ordered.
            \p Options <b>must</b> contain \p cds::opt::less or \p cds::opt::compare.
        </td>
    </tr>
    <tr>
        <td> \p boost::container::list</td>
        <td><tt><cds/container/striped_map/boost_list.h></tt></td>
        <td>\code
            #include <cds/container/striped_map/boost_list.h>
            #include <cds/container/striped_hash_map.h>
            typedef cds::container::StripedMap<
                boost::container::list< std::pair< const Key, T > >
            > striped_map;
        \endcode
        </td>
        <td>
            The type of values stored in the \p boost::container::list must be <tt> std::pair< const Key, T > </tt>,
            where \p Key - key type,  and \p T - value type. The list is ordered.
            \p Options <b>must</b> contain \p cds::opt::less or \p cds::opt::compare.
        </td>
    </tr>
    <tr>
        <td> \p boost::container::map</td>
        <td><tt><cds/container/striped_map/boost_map.h></tt></td>
        <td>\code
            #include <cds/container/striped_map/boost_map.h>
            #include <cds/container/striped_hash_map.h>
            typedef cds::container::StripedMap<
                boost::container::map< Key, T, std::less<Key> >
            > striped_map;
        \endcode
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td> \p boost::container::flat_map</td>
        <td><tt><cds/container/striped_map/boost_flat_map.h></tt></td>
        <td>\code
            #include <cds/container/striped_map/boost_flat_map.h>
            #include <cds/container/striped_hash_map.h>
            typedef cds::container::StripedMap<
                boost::container::flat_map< Key, T,
                    std::less< std::less<Key> >
                >
            > striped_map;
        \endcode
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td> \p boost::unordered_map</td>
        <td><tt><cds/container/striped_map/boost_unordered_map.h></tt></td>
        <td>\code
            #include <cds/container/striped_map/boost_unordered_map.h>
            #include <cds/container/refinable_hash_map.h>
            typedef cds::container::StripedMap<
                boost::unordered_map< Key, T, boost::hash<Key>, std::equal_to<Key> >
            > refinable_map;
        \endcode
        </td>
        <td>
        </td>
    </tr>
</table>


You can use another container type as map's bucket.
Suppose, you have a container class \p MyBestContainer and you want to integrate it with \p %StripedMap as bucket type.
There are two possibility:
- either your \p MyBestContainer class has native support of bucket's interface;
    in this case, you can use default <tt>striped_set::adapt</tt> metafunction;
- or your \p MyBestContainer class does not support bucket's interface; it means you should develop a specialization
    <tt>cds::container::striped_set::adapt<MyBestContainer> </tt> metafunction providing necessary interface.

The <tt>striped_set::adapt< Container, Options... ></tt> metafunction has two template argument:
- \p Container is the class that should be used as the bucket, for example, <tt>std::list< std::pair< Key, T > ></tt>.
- \p Options pack is the options from \p %StripedMap declaration. The \p adapt metafunction can use
    any option from \p Options for its internal use. For example, a \p compare option can be passed to \p adapt
    metafunction via \p Options argument of \p %StripedMap declaration.

See \p striped_set::adapt metafunction for the description of interface that the bucket container must provide
to be \p %StripedMap compatible.
\end{DoxyVerb}


{\bfseries{Copy policy}} There are three predefined copy policy\+:
\begin{DoxyItemize}
\item {\ttfamily cds\+::container\+::striped\+\_\+set\+::copy\+\_\+item} -\/ copy item from old bucket to new one when resizing using copy ctor. It is default policy for any compiler that do not support move semantics
\item {\ttfamily cds\+::container\+::striped\+\_\+set\+::move\+\_\+item} -\/ move item from old bucket to new one when resizing using move semantics. It is default policy for any compiler that support move semantics. If compiler does not support move semantics, the move policy is the same as {\ttfamily copy\+\_\+item} 
\item {\ttfamily cds\+::container\+::striped\+\_\+set\+::swap\+\_\+item} -\/ copy item from old bucket to new one when resizing using {\ttfamily \doxylink{namespacestd_a3acbe51b6415e9284430194bf04944e1}{std\+::swap}}. Not all containers support this copy policy, see details in table below.
\end{DoxyItemize}

You can define your own copy policy specifically for your case. Note, right copy policy can significantly improve the performance of resizing.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Container }&\cellcolor{\tableheadbgcolor}\textbf{ Policies  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Container }&\cellcolor{\tableheadbgcolor}\textbf{ Policies  }\\\cline{1-2}
\endhead

\begin{DoxyItemize}
\item {\ttfamily std\+::list} 
\item {\ttfamily boost\+::list} 
\end{DoxyItemize}&
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }copy\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::list<\ std::pair<const\ Key,\ T>\ >\&\ list,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::list<std::pair<const\ Key,\ T>\ >::iterator\ itInsert,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::list<std::pair<const\ Key,\ T>\ >::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert(\ itInsert,\ *itWhat\ );}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ The\ type\ T\ stored\ in\ the\ list\ must\ be\ swappable}}
\DoxyCodeLine{\textcolor{keyword}{struct\ }swap\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::list<\ std::pair<const\ Key,\ T>\ >\&\ list,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::list<std::pair<const\ Key,\ T>\ >::iterator\ itInsert,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::list<std::pair<const\ Key,\ T>\ >::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::pair<Key,\ T>\ newVal(\ itWhat-\/>first,\ \mbox{\hyperlink{test__overwrite__node_8cpp_a0acb682b8260ab1c60b918599864e2e5}{T}}());}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacestd_a3acbe51b6415e9284430194bf04944e1}{std::swap}}(\ \mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert(\ itInsert,\ newVal\ )-\/>second,\ itWhat-\/>second\ );}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }move\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::list<\ std::pair<const\ Key,\ T>\ >\&\ list,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::list<std::pair<const\ Key,\ T>\ >::iterator\ itInsert,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::list<std::pair<const\ Key,\ T>\ >::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert(\ itInsert,\ std::move(\ *itWhat\ ));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}
   \\\cline{1-2}

\begin{DoxyItemize}
\item {\ttfamily std\+::map} 
\item {\ttfamily std\+::unordered\+\_\+map} 
\item {\ttfamily boost\+::container\+::map} 
\item {\ttfamily boost\+::container\+::flat\+\_\+map} 
\item {\ttfamily boost\+::unordered\+\_\+map} 
\end{DoxyItemize}&
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }copy\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ std::map<\ Key,\ T>\&\ map,\ std::map<Key,\ T>::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_a6c13a591c2cf8fcdcfbfd6f6678a211c}{map}}.\mbox{\hyperlink{classeastl_1_1map_acb6a39a1678fb88e7d17142309df6bfe}{insert}}(\ *itWhat\ );}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }swap\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ std::map<\ Key,\ T>\&\ map,\ std::map<Key,\ T>::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacestd_a3acbe51b6415e9284430194bf04944e1}{std::swap}}(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_a6c13a591c2cf8fcdcfbfd6f6678a211c}{map}}.\mbox{\hyperlink{classeastl_1_1map_acb6a39a1678fb88e7d17142309df6bfe}{insert}}(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::map::value\_type(\ itWhat-\/>first,\ \mbox{\hyperlink{test__overwrite__node_8cpp_a0acb682b8260ab1c60b918599864e2e5}{T}}())).\mbox{\hyperlink{namespacedetail_a02319a3deb124802b88b61f85987df5e}{first}}-\/>second}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ,\ itWhat-\/>second}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}
 {\ttfamily T} type must be swappable.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }move\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ std::map<\ Key,\ T>\&\ map,\ std::map<Key,\ T>::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_a6c13a591c2cf8fcdcfbfd6f6678a211c}{map}}.\mbox{\hyperlink{classeastl_1_1map_acb6a39a1678fb88e7d17142309df6bfe}{insert}}(\ std::move(\ *itWhat\ ));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}
  \\\cline{1-2}
{\ttfamily boost\+::container\+::slist}  &
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }copy\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ bc::slist<\ std::pair<const\ Key,\ T>\ >\&\ list,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ bc::slist<std::pair<const\ Key,\ T>\ >::iterator\ itInsert,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ bc::slist<std::pair<const\ Key,\ T>\ >::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert\_after(\ itInsert,\ *itWhat\ );}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ The\ type\ T\ stored\ in\ the\ list\ must\ be\ swappable}}
\DoxyCodeLine{\textcolor{keyword}{struct\ }swap\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ bc::slist<\ std::pair<const\ Key,\ T>\ >\&\ list,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ bc::slist<std::pair<const\ Key,\ T>\ >::iterator\ itInsert,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ bc::slist<std::pair<const\ Key,\ T>\ >::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::pair<Key,\ T>\ newVal(\ itWhat-\/>first,\ \mbox{\hyperlink{test__overwrite__node_8cpp_a0acb682b8260ab1c60b918599864e2e5}{T}}());}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacestd_a3acbe51b6415e9284430194bf04944e1}{std::swap}}(\ \mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert(\ itInsert,\ newVal\ )-\/>second,\ itWhat-\/>second\ );}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }move\_item\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ bc::slist<\ std::pair<const\ Key,\ T>\ >\&\ list,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ bc::slist<std::pair<const\ Key,\ T>\ >::iterator\ itInsert,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ bc::slist<std::pair<const\ Key,\ T>\ >::iterator\ itWhat\ )}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceluisa_afbdbb20de8bb3730f578eaba0e3803b6}{list}}.insert\_after(\ itInsert,\ std::move(\ *itWhat\ ));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}\ }

\end{DoxyCode}
   \\\cline{1-2}
\end{longtabu}


{\bfseries{Advanced functions}}

The library provides some advanced functions like {\ttfamily \doxylink{classcds_1_1container_1_1_striped_map_a0f28cdf88f10e2fcc0910e00c9854f4e}{erase\+\_\+with()}}, {\ttfamily \doxylink{classcds_1_1container_1_1_striped_map_aa1353dfa60543a01fc0092733129a4fd}{find\+\_\+with()}}, that cannot be supported by all underlying containers. The table below shows whether underlying container supports those functions (the sign "{}+"{} means "{}container supports the function"{})\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Container }&\cellcolor{\tableheadbgcolor}\textbf{ {\ttfamily find\+\_\+with}  }&\cellcolor{\tableheadbgcolor}\textbf{ {\ttfamily erse\+\_\+with}   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Container }&\cellcolor{\tableheadbgcolor}\textbf{ {\ttfamily find\+\_\+with}  }&\cellcolor{\tableheadbgcolor}\textbf{ {\ttfamily erse\+\_\+with}   }\\\cline{1-3}
\endhead
{\ttfamily std\+::list}  &+ &+  \\\cline{1-3}
{\ttfamily std\+::map}  &-\/ &-\/  \\\cline{1-3}
{\ttfamily std\+::unordered\+\_\+map}  &-\/ &-\/  \\\cline{1-3}
{\ttfamily boost\+::container\+::slist}  &+ &+  \\\cline{1-3}
{\ttfamily boost\+::container\+::list}  &+ &+  \\\cline{1-3}
{\ttfamily boost\+::container\+::map}  &-\/ &-\/  \\\cline{1-3}
{\ttfamily boost\+::container\+::flat\+\_\+map}  &-\/ &-\/  \\\cline{1-3}
{\ttfamily boost\+::unordered\+\_\+map}  &-\/ &-\/  \\\cline{1-3}
\end{longtabu}


\doxysubsection{成员类型定义说明}
\Hypertarget{classcds_1_1container_1_1_striped_map_a6492d65eb7a28cb6a6714b0c04b826df}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!allocator\_type@{allocator\_type}}
\index{allocator\_type@{allocator\_type}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{allocator\_type}{allocator\_type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a6492d65eb7a28cb6a6714b0c04b826df} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::allocator\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::allocator\+\_\+type}



allocator type specified in options. 

\Hypertarget{classcds_1_1container_1_1_striped_map_af41155b6b3ff185f4ee4a64bdf256c7d}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!bucket\_type@{bucket\_type}}
\index{bucket\_type@{bucket\_type}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{bucket\_type}{bucket\_type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_af41155b6b3ff185f4ee4a64bdf256c7d} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::bucket\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::bucket\+\_\+type}



container type adapted for hash set 

\Hypertarget{classcds_1_1container_1_1_striped_map_a6b1b0a9b45e942498737a5652b325e26}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!hash@{hash}}
\index{hash@{hash}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{hash}{hash}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a6b1b0a9b45e942498737a5652b325e26} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::hash \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\mbox{\hyperlink{structhash}{\+::hash}}}



\doxylink{struct_hash}{Hash} functor 

\Hypertarget{classcds_1_1container_1_1_striped_map_a4097c7d9306f06b3fb0ef3f351387040}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!item\_counter@{item\_counter}}
\index{item\_counter@{item\_counter}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{item\_counter}{item\_counter}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a4097c7d9306f06b3fb0ef3f351387040} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::item\+\_\+counter \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::item\+\_\+counter}



Item counter 

\Hypertarget{classcds_1_1container_1_1_striped_map_a95d2f85653d88cea2e02fc6c39a5d2b3}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!key\_type@{key\_type}}
\index{key\_type@{key\_type}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{key\_type}{key\_type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a95d2f85653d88cea2e02fc6c39a5d2b3} 
template$<$class Container, typename... Options$>$ \\
typedef value\+\_\+type\+::first\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\mbox{\hyperlink{structis__key__matching__join}{\+::key\+\_\+type}}}



key type 

\Hypertarget{classcds_1_1container_1_1_striped_map_abcd34343ee928de44a8d121cfdbb11b9}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!mapped\_type@{mapped\_type}}
\index{mapped\_type@{mapped\_type}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{mapped\_type}{mapped\_type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_abcd34343ee928de44a8d121cfdbb11b9} 
template$<$class Container, typename... Options$>$ \\
typedef value\+\_\+type\+::second\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::mapped\+\_\+type}



mapped type 

\Hypertarget{classcds_1_1container_1_1_striped_map_a0c68a4f3ca5a79fcffac0cb2624e0441}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!mutex\_policy@{mutex\_policy}}
\index{mutex\_policy@{mutex\_policy}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{mutex\_policy}{mutex\_policy}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a0c68a4f3ca5a79fcffac0cb2624e0441} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::mutex\+\_\+policy \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::mutex\+\_\+policy}



Mutex policy 

\Hypertarget{classcds_1_1container_1_1_striped_map_a3155c54ac7cc35f2ab627ce6eb7333e3}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!resizing\_policy@{resizing\_policy}}
\index{resizing\_policy@{resizing\_policy}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{resizing\_policy}{resizing\_policy}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a3155c54ac7cc35f2ab627ce6eb7333e3} 
template$<$class Container, typename... Options$>$ \\
typedef base\+\_\+class\+::resizing\+\_\+policy \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::resizing\+\_\+policy}



Resizing policy 

\Hypertarget{classcds_1_1container_1_1_striped_map_a2e8f54fde7d2f4330dbbd32e32da715a}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!underlying\_container\_type@{underlying\_container\_type}}
\index{underlying\_container\_type@{underlying\_container\_type}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{underlying\_container\_type}{underlying\_container\_type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a2e8f54fde7d2f4330dbbd32e32da715a} 
template$<$class Container, typename... Options$>$ \\
typedef Container \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::underlying\+\_\+container\+\_\+type}



original intrusive container type for the bucket 

\Hypertarget{classcds_1_1container_1_1_striped_map_abc37b83c74cd041b958aba25ff3ea079}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!value\_type@{value\_type}}
\index{value\_type@{value\_type}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{value\_type}{value\_type}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_abc37b83c74cd041b958aba25ff3ea079} 
template$<$class Container, typename... Options$>$ \\
typedef bucket\+\_\+type\+::value\+\_\+type \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::value\+\_\+type}



pair type ({\ttfamily  std\+::pair$<$key\+\_\+type const, mapped\+\_\+type$>$ }) 



\doxysubsection{构造及析构函数说明}
\Hypertarget{classcds_1_1container_1_1_striped_map_a2fb520f4aeda28167438e1f7ccd531df}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!StripedMap@{StripedMap}}
\index{StripedMap@{StripedMap}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{StripedMap()}{StripedMap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a2fb520f4aeda28167438e1f7ccd531df} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::\+Striped\+Map (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Default ctor. The initial capacity is 16. 

\Hypertarget{classcds_1_1container_1_1_striped_map_a892bd935c22aad68b394f3faa67ce8ec}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!StripedMap@{StripedMap}}
\index{StripedMap@{StripedMap}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{StripedMap()}{StripedMap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a892bd935c22aad68b394f3faa67ce8ec} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::\+Striped\+Map (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n\+Capacity}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Ctor with initial capacity specified 


\begin{DoxyParams}{参数}
{\em n\+Capacity} & Initial size of bucket table and lock array. Must be power of two, the minimum is 16. \\
\hline
\end{DoxyParams}
\Hypertarget{classcds_1_1container_1_1_striped_map_ab1c828a31c862660ff8b6ae35e89e8d0}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!StripedMap@{StripedMap}}
\index{StripedMap@{StripedMap}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{StripedMap()}{StripedMap()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_ab1c828a31c862660ff8b6ae35e89e8d0} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::\+Striped\+Map (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n\+Capacity}{, }\item[{\mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a3155c54ac7cc35f2ab627ce6eb7333e3}{resizing\+\_\+policy}} const \&}]{resizing\+Policy}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Ctor with resizing policy (copy semantics) 

This constructor initializes m\+\_\+\+Resizing\+Policy member with copy of {\ttfamily resizing\+Policy} parameter 
\begin{DoxyParams}{参数}
{\em n\+Capacity} & Initial size of bucket table and lock array. Must be power of two, the minimum is 16.  \\
\hline
{\em resizing\+Policy} & Resizing policy \\
\hline
\end{DoxyParams}
\Hypertarget{classcds_1_1container_1_1_striped_map_ad331b6324ae414f56df0324d3435a54f}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!StripedMap@{StripedMap}}
\index{StripedMap@{StripedMap}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{StripedMap()}{StripedMap()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_ad331b6324ae414f56df0324d3435a54f} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::\+Striped\+Map (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n\+Capacity}{, }\item[{\mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a3155c54ac7cc35f2ab627ce6eb7333e3}{resizing\+\_\+policy}} \&\&}]{resizing\+Policy}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Ctor with resizing policy (move semantics) 

This constructor initializes m\+\_\+\+Resizing\+Policy member moving {\ttfamily resizing\+Policy} parameter Move semantics is used. Available only for the compilers that supports C++11 rvalue reference. 
\begin{DoxyParams}{参数}
{\em n\+Capacity} & Initial size of bucket table and lock array. Must be power of two, the minimum is 16.  \\
\hline
{\em resizing\+Policy} & Resizing policy \\
\hline
\end{DoxyParams}
\Hypertarget{classcds_1_1container_1_1_striped_map_a09d5a55697a29b39d471dd71b580cbc3}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!````~StripedMap@{\texorpdfstring{$\sim$}{\string~}StripedMap}}
\index{````~StripedMap@{\texorpdfstring{$\sim$}{\string~}StripedMap}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{\texorpdfstring{$\sim$}{\string~}StripedMap()}{\string~StripedMap()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a09d5a55697a29b39d471dd71b580cbc3} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::\texorpdfstring{$\sim$}{\string~}\mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{Striped\+Map}} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Destructor destroys internal data 



\doxysubsection{成员函数说明}
\Hypertarget{classcds_1_1container_1_1_striped_map_a856f6f7aa7bbeffd0e447c1fee9e3d4a}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!bucket\_count@{bucket\_count}}
\index{bucket\_count@{bucket\_count}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{bucket\_count()}{bucket\_count()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a856f6f7aa7bbeffd0e447c1fee9e3d4a} 
template$<$class Container, typename... Options$>$ \\
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::bucket\+\_\+count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns the size of hash table 

The hash table size is non-\/constant and can be increased via resizing. \Hypertarget{classcds_1_1container_1_1_striped_map_a0f13b4556ea60dfa9a77c9e44040812b}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!clear@{clear}}
\index{clear@{clear}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{clear()}{clear()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a0f13b4556ea60dfa9a77c9e44040812b} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{ittnotify__static_8h_a61af67d9d838a9497ca5b188dabc1aa0}{void}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::clear (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Clears the map 

\Hypertarget{classcds_1_1container_1_1_striped_map_a00b5e87952d9a31cb50707f71dfaef61}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!contains@{contains}}
\index{contains@{contains}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a00b5e87952d9a31cb50707f71dfaef61} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::contains (\begin{DoxyParamCaption}\item[{K const \&}]{key}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Checks whether the map contains {\ttfamily key} 

The function searches the item with key equal to {\ttfamily key} and returns {\ttfamily true} if it is found, and {\ttfamily false} otherwise. \Hypertarget{classcds_1_1container_1_1_striped_map_a9d217945377cb14045e40c4ea862aafd}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!contains@{contains}}
\index{contains@{contains}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a9d217945377cb14045e40c4ea862aafd} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K, typename Less, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+find\+\_\+with $>$\+::type$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::contains (\begin{DoxyParamCaption}\item[{K const \&}]{key}{, }\item[{Less}]{pred}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Checks whether the set contains {\ttfamily key} using {\ttfamily pred} predicate for searching 

The function is similar to {\ttfamily contains( key )} but {\ttfamily pred} is used for key comparing. {\ttfamily Less} functor has the interface like {\ttfamily std\+::less}. {\ttfamily Less} must imply the same element order as the comparator used for building the set.

\begin{DoxyNote}{注解}
This function is enabled if the compiler supports C++11 default template arguments for function template {\bfseries{and}} the underlying container supports {\ttfamily contains}() feature. 
\end{DoxyNote}
\Hypertarget{classcds_1_1container_1_1_striped_map_ab1377e67bb7bf2b40ace6d8bb9f3f3da}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!emplace@{emplace}}
\index{emplace@{emplace}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{emplace()}{emplace()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_ab1377e67bb7bf2b40ace6d8bb9f3f3da} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K, typename... Args$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::emplace (\begin{DoxyParamCaption}\item[{K \&\&}]{key}{, }\item[{Args \&\&...}]{args}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



For key {\ttfamily key} inserts data of type {\ttfamily \doxylink{classcds_1_1container_1_1_striped_map_abcd34343ee928de44a8d121cfdbb11b9}{mapped\+\_\+type}} created in-\/place from {\ttfamily args} 

Returns {\ttfamily true} if inserting successful, {\ttfamily false} otherwise. \Hypertarget{classcds_1_1container_1_1_striped_map_ac1e02f63d146c37c574d3432f84d1ba9}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!empty@{empty}}
\index{empty@{empty}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_ac1e02f63d146c37c574d3432f84d1ba9} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::empty (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Checks if the map is empty 

Emptiness is checked by item counting\+: if item count is zero then the map is empty. \Hypertarget{classcds_1_1container_1_1_striped_map_abf4f29d2c1f58e1f92759f3fad808bb3}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!erase@{erase}}
\index{erase@{erase}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_abf4f29d2c1f58e1f92759f3fad808bb3} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::erase (\begin{DoxyParamCaption}\item[{K const \&}]{key}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Delete {\ttfamily key} from the map 

\label{classcds_1_1container_1_1_striped_map_cds_nonintrusive_StripedMap_erase}%
\Hypertarget{classcds_1_1container_1_1_striped_map_cds_nonintrusive_StripedMap_erase}%
 Return {\ttfamily true} if {\ttfamily key} is found and deleted, {\ttfamily false} otherwise \Hypertarget{classcds_1_1container_1_1_striped_map_a213858e29c6865981935d07665804048}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!erase@{erase}}
\index{erase@{erase}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{erase()}{erase()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a213858e29c6865981935d07665804048} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K, typename Func$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::erase (\begin{DoxyParamCaption}\item[{K const \&}]{key}{, }\item[{Func}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Delete {\ttfamily key} from the map 

\label{classcds_1_1container_1_1_striped_map_cds_nonintrusive_StripedMap_erase_func}%
\Hypertarget{classcds_1_1container_1_1_striped_map_cds_nonintrusive_StripedMap_erase_func}%
 The function searches an item with key {\ttfamily key}, calls {\ttfamily f} functor and deletes the item. If {\ttfamily key} is not found, the functor is not called.

The functor {\ttfamily Func} interface\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }extractor\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(value\_type\&\ item)\ \{\ ...\ \}}
\DoxyCodeLine{\};}

\end{DoxyCode}


Return {\ttfamily true} if key is found and deleted, {\ttfamily false} otherwise \Hypertarget{classcds_1_1container_1_1_striped_map_a0f28cdf88f10e2fcc0910e00c9854f4e}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!erase\_with@{erase\_with}}
\index{erase\_with@{erase\_with}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{erase\_with()}{erase\_with()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a0f28cdf88f10e2fcc0910e00c9854f4e} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K, typename Less, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+erase\+\_\+with $>$\+::type$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::erase\+\_\+with (\begin{DoxyParamCaption}\item[{K const \&}]{key}{, }\item[{Less}]{pred}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deletes the item from the map using {\ttfamily pred} predicate for searching 

The function is an analog of \doxylink{classcds_1_1container_1_1_striped_map_cds_nonintrusive_StripedMap_erase}{erase(K const\&)} but {\ttfamily pred} is used for key comparing. {\ttfamily Less} functor has the interface like {\ttfamily std\+::less}. {\ttfamily pred} must imply the same element order as the comparator used for building the map.

\begin{DoxyNote}{注解}
This function is enabled if the compiler supports C++11 default template arguments for function template {\bfseries{and}} the underlying container supports {\ttfamily erase\+\_\+with} feature. 
\end{DoxyNote}
\Hypertarget{classcds_1_1container_1_1_striped_map_af7ebc1913a673717786c8f7598b9237b}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!erase\_with@{erase\_with}}
\index{erase\_with@{erase\_with}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{erase\_with()}{erase\_with()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_af7ebc1913a673717786c8f7598b9237b} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K, typename Less, typename Func, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+erase\+\_\+with $>$\+::type$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::erase\+\_\+with (\begin{DoxyParamCaption}\item[{K const \&}]{key}{, }\item[{Less}]{pred}{, }\item[{Func}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Deletes the item from the map using {\ttfamily pred} predicate for searching 

The function is an analog of \doxylink{classcds_1_1container_1_1_striped_map_cds_nonintrusive_StripedMap_erase_func}{erase(K const\&, Func)} but {\ttfamily pred} is used for key comparing. {\ttfamily Less} functor has the interface like {\ttfamily std\+::less}. {\ttfamily pred} must imply the same element order as the comparator used for building the map.

\begin{DoxyNote}{注解}
This function is enabled if the compiler supports C++11 default template arguments for function template {\bfseries{and}} the underlying container supports {\ttfamily erase\+\_\+with} feature. 
\end{DoxyNote}
\Hypertarget{classcds_1_1container_1_1_striped_map_a7cc91ff823125ec02014aab0911083f5}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!find@{find}}
\index{find@{find}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{find()}{find()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a7cc91ff823125ec02014aab0911083f5} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K, typename Func$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::find (\begin{DoxyParamCaption}\item[{K const \&}]{key}{, }\item[{Func}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\doxylink{struct_find}{Find} the key {\ttfamily key} 

\label{classcds_1_1container_1_1_striped_map_cds_nonintrusive_StripedMap_find_func}%
\Hypertarget{classcds_1_1container_1_1_striped_map_cds_nonintrusive_StripedMap_find_func}%
 The function searches the item with key equal to {\ttfamily key} and calls the functor {\ttfamily f} for item found. The interface of {\ttfamily Func} functor is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }functor\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ value\_type\&\ item\ );}
\DoxyCodeLine{\};}

\end{DoxyCode}
 where {\ttfamily item} is the item found.

The functor may change {\ttfamily item.\+second}.

The function returns {\ttfamily true} if {\ttfamily key} is found, {\ttfamily false} otherwise. \Hypertarget{classcds_1_1container_1_1_striped_map_aa1353dfa60543a01fc0092733129a4fd}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!find\_with@{find\_with}}
\index{find\_with@{find\_with}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{find\_with()}{find\_with()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_aa1353dfa60543a01fc0092733129a4fd} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K, typename Less, typename Func, typename Bucket = bucket\+\_\+type, typename = typename std\+::enable\+\_\+if$<$ Bucket\+::has\+\_\+find\+\_\+with $>$\+::type$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::find\+\_\+with (\begin{DoxyParamCaption}\item[{K const \&}]{key}{, }\item[{Less}]{pred}{, }\item[{Func}]{f}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\doxylink{struct_find}{Find} the key {\ttfamily val} using {\ttfamily pred} predicate 

The function is an analog of \doxylink{classcds_1_1container_1_1_striped_map_cds_nonintrusive_StripedMap_find_func}{find(K const\&, Func)} but {\ttfamily pred} is used for key comparing {\ttfamily Less} has the interface like {\ttfamily std\+::less}. {\ttfamily pred} must imply the same element order as the comparator used for building the set.

\begin{DoxyNote}{注解}
This function is enabled if the compiler supports C++11 default template arguments for function template {\bfseries{and}} the underlying container supports {\ttfamily find\+\_\+with} feature. 
\end{DoxyNote}
\Hypertarget{classcds_1_1container_1_1_striped_map_a1cc70a631a193852a1a03ea83aa9fa91}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!get\_resizing\_policy@{get\_resizing\_policy}}
\index{get\_resizing\_policy@{get\_resizing\_policy}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{get\_resizing\_policy()}{get\_resizing\_policy()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a1cc70a631a193852a1a03ea83aa9fa91} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a3155c54ac7cc35f2ab627ce6eb7333e3}{resizing\+\_\+policy}} \& \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::get\+\_\+resizing\+\_\+policy (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Returns resizing policy object 

\Hypertarget{classcds_1_1container_1_1_striped_map_a57cc578587602d60d2fd65e9af0b701d}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!get\_resizing\_policy@{get\_resizing\_policy}}
\index{get\_resizing\_policy@{get\_resizing\_policy}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{get\_resizing\_policy()}{get\_resizing\_policy()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a57cc578587602d60d2fd65e9af0b701d} 
template$<$class Container, typename... Options$>$ \\
\mbox{\hyperlink{classcds_1_1container_1_1_striped_map_a3155c54ac7cc35f2ab627ce6eb7333e3}{resizing\+\_\+policy}} const  \& \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::get\+\_\+resizing\+\_\+policy (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns resizing policy (const version) 

\Hypertarget{classcds_1_1container_1_1_striped_map_a8306ce18508455e5a4761f8a051f6c16}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!insert@{insert}}
\index{insert@{insert}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a8306ce18508455e5a4761f8a051f6c16} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::insert (\begin{DoxyParamCaption}\item[{K const \&}]{key}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts new node with key and default value 

The function creates a node with {\ttfamily key} and default value, and then inserts the node created into the map.

Preconditions\+:
\begin{DoxyItemize}
\item The {\ttfamily \doxylink{classcds_1_1container_1_1_striped_map_a95d2f85653d88cea2e02fc6c39a5d2b3}{key\+\_\+type}} should be constructible from a value of type {\ttfamily K}. In trivial case, {\ttfamily K} is equal to {\ttfamily \doxylink{classcds_1_1container_1_1_striped_map_a95d2f85653d88cea2e02fc6c39a5d2b3}{key\+\_\+type}}.
\item The {\ttfamily \doxylink{classcds_1_1container_1_1_striped_map_abcd34343ee928de44a8d121cfdbb11b9}{mapped\+\_\+type}} should be default-\/constructible.
\end{DoxyItemize}

Returns {\ttfamily true} if inserting successful, {\ttfamily false} otherwise. \Hypertarget{classcds_1_1container_1_1_striped_map_a5543dba6bc798cb924b41de9f98cfedf}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!insert@{insert}}
\index{insert@{insert}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a5543dba6bc798cb924b41de9f98cfedf} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K, typename \mbox{\hyperlink{_eigen_solver___eigen_solver___matrix_type_8cpp_a77c224aa52b434918ce65c33175aa8ad}{V}}$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::insert (\begin{DoxyParamCaption}\item[{K const \&}]{key}{, }\item[{\mbox{\hyperlink{_eigen_solver___eigen_solver___matrix_type_8cpp_a77c224aa52b434918ce65c33175aa8ad}{V}} const \&}]{val}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts new node 

The function creates a node with copy of {\ttfamily val} value and then inserts the node created into the map.

Preconditions\+:
\begin{DoxyItemize}
\item The {\ttfamily \doxylink{classcds_1_1container_1_1_striped_map_a95d2f85653d88cea2e02fc6c39a5d2b3}{key\+\_\+type}} should be constructible from {\ttfamily key} of type {\ttfamily K}.
\item The {\ttfamily \doxylink{classcds_1_1container_1_1_striped_map_abcd34343ee928de44a8d121cfdbb11b9}{mapped\+\_\+type}} should be constructible from {\ttfamily val} of type {\ttfamily V}.
\end{DoxyItemize}

Returns {\ttfamily true} if {\ttfamily val} is inserted into the set, {\ttfamily false} otherwise. \Hypertarget{classcds_1_1container_1_1_striped_map_abd563bbd37f3b08f2763c3cff9abaf49}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!insert\_with@{insert\_with}}
\index{insert\_with@{insert\_with}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{insert\_with()}{insert\_with()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_abd563bbd37f3b08f2763c3cff9abaf49} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K, typename Func$>$ \\
\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::insert\+\_\+with (\begin{DoxyParamCaption}\item[{const K \&}]{key}{, }\item[{Func}]{func}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Inserts new node and initialize it by a functor 

This function inserts new node with key {\ttfamily key} and if inserting is successful then it calls {\ttfamily func} functor with signature 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }functor\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ value\_type\&\ item\ );}
\DoxyCodeLine{\};}

\end{DoxyCode}


The argument {\ttfamily item} of user-\/defined functor {\ttfamily func} is the reference to the map\textquotesingle{}s item inserted\+:
\begin{DoxyItemize}
\item {\ttfamily item.\+first} is a const reference to item\textquotesingle{}s key that cannot be changed.
\item {\ttfamily item.\+second} is a reference to item\textquotesingle{}s value that may be changed.
\end{DoxyItemize}

The \doxylink{classcds_1_1container_1_1_striped_map_a95d2f85653d88cea2e02fc6c39a5d2b3}{key\+\_\+type} should be constructible from value of type {\ttfamily K}.

The function allows to split creating of new item into two part\+:
\begin{DoxyItemize}
\item create item from {\ttfamily key};
\item insert new item into the map;
\item if inserting is successful, initialize the value of item by calling {\ttfamily func} functor
\end{DoxyItemize}

This can be useful if complete initialization of object of {\ttfamily \doxylink{classcds_1_1container_1_1_striped_map_abcd34343ee928de44a8d121cfdbb11b9}{mapped\+\_\+type}} is heavyweight and it is preferable that the initialization should be completed only if inserting is successful. \Hypertarget{classcds_1_1container_1_1_striped_map_a82a5fb6f0e6a0723b22e70520147407c}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!lock\_count@{lock\_count}}
\index{lock\_count@{lock\_count}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{lock\_count()}{lock\_count()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a82a5fb6f0e6a0723b22e70520147407c} 
template$<$class Container, typename... Options$>$ \\
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::lock\+\_\+count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns lock array size 

The lock array size is constant. \Hypertarget{classcds_1_1container_1_1_striped_map_a289aecf9771b5c4602375f89871583a3}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!size@{size}}
\index{size@{size}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_a289aecf9771b5c4602375f89871583a3} 
template$<$class Container, typename... Options$>$ \\
size\+\_\+t \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_ac42c05b5701aef6bab82675cf3b55fee}{\+::size}} (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Returns item count in the map 

\Hypertarget{classcds_1_1container_1_1_striped_map_ad61085c91459e53c8a6d817f64b16fb9}\index{cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}!update@{update}}
\index{update@{update}!cds::container::StripedMap$<$ Container, Options $>$@{cds::container::StripedMap$<$ Container, Options $>$}}
\doxysubsubsection{\texorpdfstring{update()}{update()}}
{\footnotesize\ttfamily \label{classcds_1_1container_1_1_striped_map_ad61085c91459e53c8a6d817f64b16fb9} 
template$<$class Container, typename... Options$>$ \\
template$<$typename K, typename Func$>$ \\
std\+::pair$<$ \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}, \mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}} $>$ \mbox{\hyperlink{classcds_1_1container_1_1_striped_map}{cds\+::container\+::\+Striped\+Map}}$<$ Container, Options $>$\+::update (\begin{DoxyParamCaption}\item[{K const \&}]{key}{, }\item[{Func}]{func}{, }\item[{\mbox{\hyperlink{sugar_8h_abb452686968e48b67397da5f97445f5b}{bool}}}]{b\+Allow\+Insert}{ = {\ttfamily \mbox{\hyperlink{yyjson_8h_a41f9c5fb8b08eb5dc3edce4dcb37fee7}{true}}}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Updates the node 

The operation performs inserting or changing data with lock-\/free manner.

If {\ttfamily key} is not found in the map, then {\ttfamily key} is inserted iff {\ttfamily b\+Allow\+Insert} is {\ttfamily true}. Otherwise, the functor {\ttfamily func} is called with item found.

The functor signature is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }my\_functor\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ operator()(\ \textcolor{keywordtype}{bool}\ bNew,\ value\_type\&\ item\ );}
\DoxyCodeLine{\};}

\end{DoxyCode}
 with arguments\+:
\begin{DoxyItemize}
\item {\ttfamily b\+New} -\/ {\ttfamily true} if the item has been inserted, {\ttfamily false} otherwise
\item {\ttfamily item} -\/ item of the map
\end{DoxyItemize}

Returns {\ttfamily  std\+::pair$<$bool, bool$>$ } where {\ttfamily first} is true if operation is successful, {\ttfamily second} is true if new item has been added or {\ttfamily false} if the item with {\ttfamily key} already is in the map. 

该类的文档由以下文件生成\+:\begin{DoxyCompactItemize}
\item 
external/libcds/cds/container/\mbox{\hyperlink{striped__map_8h}{striped\+\_\+map.\+h}}\end{DoxyCompactItemize}
