\doxysection{external/taskflow/3rd-\/party/ff/ubuffer.hpp 文件参考}
\hypertarget{ubuffer_8hpp}{}\label{ubuffer_8hpp}\index{external/taskflow/3rd-\/party/ff/ubuffer.hpp@{external/taskflow/3rd-\/party/ff/ubuffer.hpp}}


This file contains the definition of the unbounded {\ttfamily SWSR} circular buffer used in Fast\+Flow  


{\ttfamily \#include $<$assert.\+h$>$}\newline
{\ttfamily \#include $<$cassert$>$}\newline
{\ttfamily \#include $<$new$>$}\newline
{\ttfamily \#include $<$ff/dynqueue.\+hpp$>$}\newline
{\ttfamily \#include $<$ff/buffer.\+hpp$>$}\newline
{\ttfamily \#include $<$ff/spin-\/lock.\+hpp$>$}\newline
ubuffer.\+hpp 的引用(Include)关系图\+:
% FIG 0
此图展示该文件被哪些文件直接或间接地引用了\+:
% FIG 1
\doxysubsubsection*{类}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classff_1_1_buffer_pool}{ff\+::\+Buffer\+Pool}}
\item 
class \mbox{\hyperlink{classff_1_1u_s_w_s_r___ptr___buffer}{ff\+::u\+SWSR\+\_\+\+Ptr\+\_\+\+Buffer}}
\begin{DoxyCompactList}\small\item\em Unbounded Single-\/\+Writer/\+Single-\/\+Reader buffer (Fast\+Flow unbound channel) \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{命名空间}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespaceff}{ff}}
\end{DoxyCompactItemize}
\doxysubsubsection*{宏定义}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{ubuffer_8hpp_a1ca530a525f942f4813c8583b9e0058f}{INTERNAL\+\_\+\+BUFFER\+\_\+T}}~SWSR\+\_\+\+Ptr\+\_\+\+Buffer  /\texorpdfstring{$\ast$}{*} bounded SPSC \mbox{\hyperlink{classbuffer}{buffer}} \texorpdfstring{$\ast$}{*}/
\end{DoxyCompactItemize}


\doxysubsection{详细描述}
This file contains the definition of the unbounded {\ttfamily SWSR} circular buffer used in Fast\+Flow 

Single-\/\+Writer/\+Single-\/\+Reader (SWSR) lock-\/free (wait-\/free) unbounded FIFO queue. No lock is needed around pop and push methods!!

The key idea underneath the implementation is quite simple\+: the unbounded queue is based on a pool of wait-\/free SWSR circular buffers (see \doxylink{buffer_8hpp}{buffer.\+hpp}). The pool of buffers automatically grows and shrinks on demand. The implementation of the pool of buffers carefully try to minimize the impact of dynamic memory allocation/deallocation by using caching strategies.

More information about the u\+SWSR\+\_\+\+Ptr\+\_\+\+Buffer implementation and correctness proof can be found in\+:

M. Aldinucci, M. Danelutto, P. Kilpatrick, M. Meneghin, and M. Torquati, "{}\+An Efficient Unbounded Lock-\/\+Free Queue for Multi-\/core Systems,"{} in Proc. of 18th Intl. Euro-\/\+Par 2012 Parallel Processing, Rhodes Island, Greece, 2012, pp. 662-\/673. doi\+:10.\+1007/978-\/3-\/642-\/32820-\/6\+\_\+65

IMPORTANT\+:

This implementation has been optimized for 1 producer and 1 consumer. If you need to use more producers and/or more consumers you have several possibilities (top-\/down order)\+:
\begin{DoxyEnumerate}
\item to use an high level construct like the farm skeleton and compositions of multiple farms (in other words, use Fast\+Flow ;-\/) ).
\item to use one of the implementations in the \doxylink{_m_p_m_cqueues_8hpp}{MPMCqueues.\+hpp} file
\item to use the SWSR\+\_\+\+Ptr\+\_\+\+Buffer but with the mp\+\_\+push and the mc\+\_\+pop methods both protected by (spin-\/)locks in order to protect the internal data structures. 
\end{DoxyEnumerate}

\doxysubsection{宏定义说明}
\Hypertarget{ubuffer_8hpp_a1ca530a525f942f4813c8583b9e0058f}\index{ubuffer.hpp@{ubuffer.hpp}!INTERNAL\_BUFFER\_T@{INTERNAL\_BUFFER\_T}}
\index{INTERNAL\_BUFFER\_T@{INTERNAL\_BUFFER\_T}!ubuffer.hpp@{ubuffer.hpp}}
\doxysubsubsection{\texorpdfstring{INTERNAL\_BUFFER\_T}{INTERNAL\_BUFFER\_T}}
{\footnotesize\ttfamily \label{ubuffer_8hpp_a1ca530a525f942f4813c8583b9e0058f} 
\#define INTERNAL\+\_\+\+BUFFER\+\_\+T~SWSR\+\_\+\+Ptr\+\_\+\+Buffer  /\texorpdfstring{$\ast$}{*} bounded SPSC \mbox{\hyperlink{classbuffer}{buffer}} \texorpdfstring{$\ast$}{*}/}

