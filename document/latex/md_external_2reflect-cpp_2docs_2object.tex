\chapter{\texorpdfstring{$<$}{<}tt\texorpdfstring{$>$}{>}rfl\+::Object\texorpdfstring{$<$}{<}/tt\texorpdfstring{$>$}{>}}
\hypertarget{md_external_2reflect-cpp_2docs_2object}{}\label{md_external_2reflect-cpp_2docs_2object}\index{$<$tt$>$rfl::Object$<$/tt$>$@{$<$tt$>$rfl::Object$<$/tt$>$}}
\label{md_external_2reflect-cpp_2docs_2object_autotoc_md615}%
\Hypertarget{md_external_2reflect-cpp_2docs_2object_autotoc_md615}%


{\ttfamily \doxylink{classrfl_1_1_object}{rfl\+::\+Object}\texorpdfstring{$<$}{<}...\texorpdfstring{$>$}{>}} behaves similarly to {\ttfamily std\+::map\texorpdfstring{$<$}{<}std\+::string, ...\texorpdfstring{$>$}{>}} and {\ttfamily std\+::unordered\+\_\+map\texorpdfstring{$<$}{<}std\+::string, ...\texorpdfstring{$>$}{>}}.

It will be represented in JSON or other formats as an object\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ bart\ =\ \mbox{\hyperlink{classrfl_1_1_object}{rfl::Object<std::string>}}();}
\DoxyCodeLine{bart[\textcolor{stringliteral}{"{}first\_name"{}}]\ =\ \textcolor{stringliteral}{"{}Bart"{}};}
\DoxyCodeLine{bart[\textcolor{stringliteral}{"{}last\_name"{}}]\ =\ \textcolor{stringliteral}{"{}Simpson"{}};}
\DoxyCodeLine{bart[\textcolor{stringliteral}{"{}town"{}}]\ =\ \textcolor{stringliteral}{"{}Springfield"{}};}

\end{DoxyCode}


This is results in the following JSON string\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{\textcolor{stringliteral}{"{}first\_name"{}}:\textcolor{stringliteral}{"{}Bart"{}},\textcolor{stringliteral}{"{}last\_name"{}}:\textcolor{stringliteral}{"{}Simpson"{}},\textcolor{stringliteral}{"{}town"{}}:\textcolor{stringliteral}{"{}Springfield"{}}\}}

\end{DoxyCode}


It supports almost all of the normal features you would expect from such a container. For instance, you can iterate through it just like any other map\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ [k,\ \mbox{\hyperlink{_cwise__arg_8cpp_a49bb5a0db288a22a099643d44c5abbd6}{v}}]:\ bart)\ \{}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ k\ <<\ \textcolor{stringliteral}{"{}:\ "{}}\ <<\ \mbox{\hyperlink{_cwise__arg_8cpp_a49bb5a0db288a22a099643d44c5abbd6}{v}}\ <<\ std::endl;}
\DoxyCodeLine{\}}

\end{DoxyCode}


However, unlike these containers, the order of fields is preserved. It is also possible to have duplicate keys\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ bart\ =\ \mbox{\hyperlink{classrfl_1_1_object}{rfl::Object<std::string>}}();}
\DoxyCodeLine{bart[\textcolor{stringliteral}{"{}first\_name"{}}]\ =\ \textcolor{stringliteral}{"{}Bart"{}};}
\DoxyCodeLine{bart[\textcolor{stringliteral}{"{}last\_name"{}}]\ =\ \textcolor{stringliteral}{"{}Simpson"{}};}
\DoxyCodeLine{bart[\textcolor{stringliteral}{"{}town"{}}]\ =\ \textcolor{stringliteral}{"{}Springfield"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Note\ that\ you\ need\ the\ .insert(...)\ method,}}
\DoxyCodeLine{\textcolor{comment}{//\ because\ operator[]\ would\ overwrite\ the}}
\DoxyCodeLine{\textcolor{comment}{//\ existing\ field.}}
\DoxyCodeLine{bart.insert(\textcolor{stringliteral}{"{}first\_name"{}},\ \textcolor{stringliteral}{"{}Lisa"{}});}

\end{DoxyCode}


This results in the following JSON string\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\{\textcolor{stringliteral}{"{}first\_name"{}}:\textcolor{stringliteral}{"{}Bart"{}},\textcolor{stringliteral}{"{}last\_name"{}}:\textcolor{stringliteral}{"{}Simpson"{}},\textcolor{stringliteral}{"{}town"{}}:\textcolor{stringliteral}{"{}Springfield"{}},\textcolor{stringliteral}{"{}first\_name"{}}:\textcolor{stringliteral}{"{}Lisa"{}}\}}

\end{DoxyCode}


There are three different ways of inserting fields\+:


\begin{DoxyItemize}
\item {\ttfamily operator\mbox{[}...\mbox{]}} creates a new field, if a field of this name doesn\textquotesingle{}t already exist, and then assigns it.
\item {\ttfamily .\doxylink{_sparse_matrix__coeffs_8cpp_ab35a6a022462a2c6584f51173eb05af6}{insert(...)}} inserts a new field at the end, potentially creating duplicate field names. Much like {\ttfamily std\+::map}, it supports several types of inputs\+:
\begin{DoxyItemize}
\item {\ttfamily .\doxylink{_sparse_matrix__coeffs_8cpp_ab35a6a022462a2c6584f51173eb05af6}{insert(std\+::pair(key, value))}}
\item {\ttfamily .\doxylink{_sparse_matrix__coeffs_8cpp_ab35a6a022462a2c6584f51173eb05af6}{insert(key, value)}}
\item {\ttfamily .\doxylink{_sparse_matrix__coeffs_8cpp_ab35a6a022462a2c6584f51173eb05af6}{insert(begin, end)}}, where {\ttfamily begin} and {\ttfamily end} are iterators of a container of key-\/value-\/pairs
\end{DoxyItemize}
\item {\ttfamily .emplace(...)} is an alias for {\ttfamily .insert} that exists primarily for reasons of compatability with standard containers.
\end{DoxyItemize}

There are three different ways of accessing fields\+:


\begin{DoxyItemize}
\item {\ttfamily operator\mbox{[}...\mbox{]}} creates a new field, if a field of this name doesn\textquotesingle{}t already exist.
\item {\ttfamily .at(...)} throws an exception, if field of this name doesn\textquotesingle{}t exist.
\item {\ttfamily .\doxylink{structget}{get(...)}} returns an {\ttfamily \doxylink{classrfl_1_1_result}{rfl\+::\+Result}} wrapping the field, or an {\ttfamily \doxylink{classrfl_1_1_error}{rfl\+::\+Error}} if the field doesn\textquotesingle{}t exist.
\end{DoxyItemize}

Note that it is most efficient, if you access fields in the order that they were placed. 