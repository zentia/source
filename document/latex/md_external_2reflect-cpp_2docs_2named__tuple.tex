\chapter{\texorpdfstring{$<$}{<}tt\texorpdfstring{$>$}{>}rfl\+::Named\+Tuple\texorpdfstring{$<$}{<}/tt\texorpdfstring{$>$}{>}}
\hypertarget{md_external_2reflect-cpp_2docs_2named__tuple}{}\label{md_external_2reflect-cpp_2docs_2named__tuple}\index{$<$tt$>$rfl::NamedTuple$<$/tt$>$@{$<$tt$>$rfl::NamedTuple$<$/tt$>$}}
\label{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md606}%
\Hypertarget{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md606}%


{\ttfamily \doxylink{classrfl_1_1_named_tuple}{rfl\+::\+Named\+Tuple}} is very similar to {\ttfamily std\+::tuple} or {\ttfamily \doxylink{classrfl_1_1_tuple}{rfl\+::\+Tuple}}, but unlike these two structures, the fields have names.

In other words, consider the following struct\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ \ \ std::string\ first\_name;}
\DoxyCodeLine{\ \ \ \ std::string\ last\_name;}
\DoxyCodeLine{\ \ \ \ rfl::Timestamp<\textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%d"{}}>\ birthday;}
\DoxyCodeLine{\};}

\end{DoxyCode}


You might as well define the following {\ttfamily \doxylink{classrfl_1_1_named_tuple}{rfl\+::\+Named\+Tuple}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ }Person\ =\ \mbox{\hyperlink{classrfl_1_1_named_tuple}{rfl::NamedTuple}}<}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}first\_name"{}},\ std::string>,}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}last\_name"{}},\ std::string>,}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}birthday"{}},\ \mbox{\hyperlink{classrfl_1_1_timestamp}{rfl::Timestamp}}<\textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%d"{}}>>>;}

\end{DoxyCode}


From the point-\/of-\/view of serialization/deserialization, the two definitions are equivalent. The resulting JSON strings (or any other format) will be the same.\hypertarget{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md607}{}\doxysection{\texorpdfstring{Structural typing}{Structural typing}}\label{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md607}
From the point-\/of-\/view of programming, there is an important difference\+: Structs are {\itshape nominally typed} and named tuples are {\itshape structurally typed} (confusingly, structs are not structurally typed).

In plain language, that means that the compiler will regard this as absolutely equivalent to {\ttfamily Person}, the named tuple\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ }Person2\ =\ \mbox{\hyperlink{classrfl_1_1_named_tuple}{rfl::NamedTuple}}<}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}first\_name"{}},\ std::string>,}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}last\_name"{}},\ std::string>,}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}birthday"{}},\ \mbox{\hyperlink{classrfl_1_1_timestamp}{rfl::Timestamp}}<\textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%d"{}}>>>;}

\end{DoxyCode}


However, this will be seen as a type that is different from {\ttfamily Person}, the struct\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person2\ \{}
\DoxyCodeLine{\ \ \ \ std::string\ first\_name;}
\DoxyCodeLine{\ \ \ \ std::string\ last\_name;}
\DoxyCodeLine{\ \ \ \ rfl::Timestamp<\textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%d"{}}>\ birthday;}
\DoxyCodeLine{\};}

\end{DoxyCode}


Structural typing also means that you can declare new types on-\/the-\/fly. For instance, in order to create a {\ttfamily Person} named tuple, you don\textquotesingle{}t actually have to declare it at all. The following will do\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ person\ =\ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}first\_name"{}},\ std::string>(\textcolor{stringliteral}{"{}Homer"{}})\ *}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field<"{}last\_name"{},\ std::string>}}(\textcolor{stringliteral}{"{}Simpson"{}})\ *}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}birthday"{}},\ \mbox{\hyperlink{classrfl_1_1_timestamp}{rfl::Timestamp}}<\textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%d"{}}>>(\textcolor{stringliteral}{"{}1987-\/04-\/19"{}});}

\end{DoxyCode}


The type of {\ttfamily person} will now be equivalent to the definition of {\ttfamily Person}, the named tuple, regardless of whether you have actually declared it anywhere.

On the other hand, structural typing also means that recursive definitions are impossible. For instance, consider something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Person\ \{}
\DoxyCodeLine{\ \ \ \ std::string\ first\_name;}
\DoxyCodeLine{\ \ \ \ std::string\ last\_name;}
\DoxyCodeLine{\ \ \ \ std::vector<Person>\ children;}
\DoxyCodeLine{\};}

\end{DoxyCode}


In this example, {\ttfamily Person} is recursively defined (because of the field {\ttfamily children}). This is impossible to accomplish using structural typing and {\ttfamily \doxylink{classrfl_1_1_named_tuple}{rfl\+::\+Named\+Tuple}}, just like it is impossible to have a recursively defined lambda function.\hypertarget{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md608}{}\doxysection{\texorpdfstring{Accessing fields}{Accessing fields}}\label{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md608}
Fields inside the named tuple can be accessed using {\ttfamily \doxylink{namespacerfl_ac379420409251e5a3c0bea4a701daf0a}{rfl\+::get}} or the {\ttfamily .get} method\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ person\ =\ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}first\_name"{}},\ std::string>(\textcolor{stringliteral}{"{}Homer"{}})\ *}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field<"{}last\_name"{},\ std::string>}}(\textcolor{stringliteral}{"{}Simpson"{}})\ *}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}birthday"{}},\ \mbox{\hyperlink{classrfl_1_1_timestamp}{rfl::Timestamp}}<\textcolor{stringliteral}{"{}\%Y-\/\%m-\/\%d"{}}>>(\textcolor{stringliteral}{"{}1987-\/04-\/19"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ OK\ in\ most\ circumstances\ (there\ are\ restrictions}}
\DoxyCodeLine{\textcolor{comment}{//\ due\ to\ the\ way\ C++\ templates\ work).}}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ first\_name\ =\ person.get<\textcolor{stringliteral}{"{}firstName"{}}>();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Always\ OK}}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ first\_name\ =\ person.template\ \mbox{\hyperlink{stdlist__overload_8cpp_a120a90058439faee14791b33f94c0693}{get}}<\textcolor{stringliteral}{"{}firstName"{}}>();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Always\ OK}}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ first\_name\ =\ \mbox{\hyperlink{namespacerfl_ac379420409251e5a3c0bea4a701daf0a}{rfl::get}}<\textcolor{stringliteral}{"{}firstName"{}}>(person);}

\end{DoxyCode}


Fields can also be iterated over at compile-\/time using the {\ttfamily apply()} method\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ person\ =\ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}first\_name"{}},\ std::string>(\textcolor{stringliteral}{"{}Bart"{}})\ *}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field<"{}last\_name"{},\ std::string>}}(\textcolor{stringliteral}{"{}Simpson"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{person.apply([](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})\ \{}
\DoxyCodeLine{\ \ \textcolor{keyword}{auto}\ field\_name\ =\ \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}}.name();}
\DoxyCodeLine{\ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_abe8e049f756b5ba547bda825af81b645}{value}}\ =\ *\mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}}.value();}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{person.apply([]<\textcolor{keyword}{typename}\ Field>(Field\&\ \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}})\ \{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ The\ field\ name\ can\ also\ be\ obtained\ as\ a\ compile-\/time\ constant.}}
\DoxyCodeLine{\ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{auto}\ field\_name\ =\ Field::name();}
\DoxyCodeLine{\ \ \textcolor{keyword}{using\ }field\_pointer\_type\ =\ \textcolor{keyword}{typename}\ Field::Type;}
\DoxyCodeLine{\ \ field\_pointer\_type*\ \mbox{\hyperlink{imgui__impl__opengl3__loader_8h_abe8e049f756b5ba547bda825af81b645}{value}}\ =\ \mbox{\hyperlink{cxx11__tensor__map_8cpp_a7f507fea02198f6cb81c86640c7b1a4e}{f}}.value();}
\DoxyCodeLine{\});}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md609}{}\doxysubsection{\texorpdfstring{Monadic operations\+: {\ttfamily .transform} and {\ttfamily .and\+\_\+then}}{Monadic operations\+: {\ttfamily .transform} and {\ttfamily .and\+\_\+then}}}\label{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md609}
Named tuples also contain compile-\/time monadic operations.

{\ttfamily .transform(f)} expects a function {\ttfamily f} of type {\ttfamily Field -\/\texorpdfstring{$>$}{>} Field}. {\ttfamily transform} then applies that function to each field of the named tuple. It can be used to change either the values or the names of the fields, but not their overall number.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ lisa\ =}
\DoxyCodeLine{\ \ \ \ Person\{.first\_name\ =\ \textcolor{stringliteral}{"{}Lisa"{}},\ .last\_name\ =\ \textcolor{stringliteral}{"{}Simpson"{}},\ .age\ =\ 8\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ to\_bart\ =\ [](\textcolor{keyword}{auto}\ field)\ \{}
\DoxyCodeLine{\textcolor{keywordflow}{if}\ \textcolor{keyword}{constexpr}\ (\textcolor{keyword}{decltype}(field)\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{::name}}()\ ==\ \textcolor{stringliteral}{"{}first\_name"{}})\ \{}
\DoxyCodeLine{\ \ \ \ field\ =\ \textcolor{stringliteral}{"{}Bart"{}};}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ field;}
\DoxyCodeLine{\}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ \textcolor{keyword}{constexpr}\ (\textcolor{keyword}{decltype}(field)\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{::name}}()\ ==\ \textcolor{stringliteral}{"{}age"{}})\ \{}
\DoxyCodeLine{\ \ \ \ field\ =\ 10;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ field;}
\DoxyCodeLine{\}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ field;}
\DoxyCodeLine{\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ bart\ will\ now\ be\ a\ named\ tuple\ with\ first\_name="{}Bart"{},}}
\DoxyCodeLine{\textcolor{comment}{//\ last\_name="{}Simpson"{},\ age=10}}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ bart\ =\ \mbox{\hyperlink{namespacerfl_a7d112596ec25825815ee5b2cae093110}{rfl::to\_named\_tuple}}(lisa).transform(to\_bart);}

\end{DoxyCode}


{\ttfamily .and\+\_\+then(f)} expects a function {\ttfamily f} of type {\ttfamily Field -\/\texorpdfstring{$>$}{>} Named\+Tuple}. {\ttfamily and\+\_\+then} then applies that function to each field of the named tuple and finally concatenates the resulting named tuple to form a new named tuple. Note that the named tuple returned by {\ttfamily f} may be empty. {\ttfamily .and\+\_\+then(f)} can be used to change either the values or the names of the fields, and can also affect their overall number.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ lisa\ =}
\DoxyCodeLine{\ \ \ \ Person\{.first\_name\ =\ \textcolor{stringliteral}{"{}Lisa"{}},\ .last\_name\ =\ \textcolor{stringliteral}{"{}Simpson"{}},\ .age\ =\ 8\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ to\_bart\ =\ [](\textcolor{keyword}{auto}\ field)\ \{}
\DoxyCodeLine{\textcolor{keywordflow}{if}\ \textcolor{keyword}{constexpr}\ (\textcolor{keyword}{decltype}(field)\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{::name}}()\ ==\ \textcolor{stringliteral}{"{}first\_name"{}})\ \{}
\DoxyCodeLine{\ \ \ \ field\ =\ \textcolor{stringliteral}{"{}Bart"{}};}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespacerfl_a19523aa875e6c36af474a97f28ed4002}{rfl::make\_named\_tuple}}(field);}
\DoxyCodeLine{\}\ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ \textcolor{keyword}{constexpr}\ (\textcolor{keyword}{decltype}(field)\mbox{\hyperlink{imgui__impl__opengl3__loader_8h_aab18cfce5ee7c6881ae04f18be70d94a}{::name}}()\ ==\ \textcolor{stringliteral}{"{}age"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespacerfl_a19523aa875e6c36af474a97f28ed4002}{rfl::make\_named\_tuple}}();}
\DoxyCodeLine{\}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespacerfl_a19523aa875e6c36af474a97f28ed4002}{rfl::make\_named\_tuple}}(field);}
\DoxyCodeLine{\}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ bart\ will\ now\ be\ a\ named\ tuple\ with\ first\_name="{}Bart"{},}}
\DoxyCodeLine{\textcolor{comment}{//\ last\_name="{}Simpson"{}.\ Since\ we\ have\ returned\ and\ empty}}
\DoxyCodeLine{\textcolor{comment}{//\ named\ tuple\ for\ the\ field\ "{}age"{},\ there\ will\ be\ no\ such}}
\DoxyCodeLine{\textcolor{comment}{//\ field\ in\ bart.}}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ bart\ =\ \mbox{\hyperlink{namespacerfl_a7d112596ec25825815ee5b2cae093110}{rfl::to\_named\_tuple}}(lisa).and\_then(to\_bart);}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md610}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::replace}}{{\ttfamily rfl\+::replace}}}\label{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md610}
{\ttfamily \doxylink{namespacerfl_ac4bd3c990469707252d797a9d81a3680}{rfl\+::replace}} works for {\ttfamily \doxylink{classrfl_1_1_named_tuple}{rfl\+::\+Named\+Tuple}} as well\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ lisa\ =\ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}firstName"{}},\ std::string>(\textcolor{stringliteral}{"{}Lisa"{}})\ *}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field<"{}lastName"{},\ std::string>}}(\textcolor{stringliteral}{"{}Simpson"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Returns\ a\ deep\ copy\ of\ the\ original\ object,}}
\DoxyCodeLine{\textcolor{comment}{//\ replacing\ first\_name.}}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ maggie\ =}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespacerfl_ac4bd3c990469707252d797a9d81a3680}{rfl::replace}}(lisa,\ \mbox{\hyperlink{namespacerfl_afb5f68a22d5b6a42a5b4477c35559ce9}{rfl::make\_field<"{}firstName"{}>}}(std::string(\textcolor{stringliteral}{"{}Maggie"{}})));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Also\ OK}}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ bart\ =\ lisa.replace(\mbox{\hyperlink{namespacerfl_afb5f68a22d5b6a42a5b4477c35559ce9}{rfl::make\_field<"{}firstName"{}>}}(std::string(\textcolor{stringliteral}{"{}Bart"{}})));}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md611}{}\doxysubsection{\texorpdfstring{{\ttfamily rfl\+::as}}{{\ttfamily rfl\+::as}}}\label{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md611}
So does {\ttfamily \doxylink{namespacerfl_a6ed469a6082d8180235db125c13fc410}{rfl\+::as}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ }\mbox{\hyperlink{test__buffer__node_8cpp_ac4cf4b2ab929bd23951a8676eeac086b}{C}}\ =\ \mbox{\hyperlink{classrfl_1_1_named_tuple}{rfl::NamedTuple}}<}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}f1"{}},\ std::string>,}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}f2"{}},\ std::string>,}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}f4"{}},\ std::string>>;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ \mbox{\hyperlink{_cwise__product_8cpp_ad2cbe4616e813eb9af81732dca777b24}{a}}\ =\ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}f1"{}},\ std::string>(\textcolor{stringliteral}{"{}Hello"{}})\ *\ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field<"{}f2"{},\ std::string>}}(\textcolor{stringliteral}{"{}World"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ \mbox{\hyperlink{offscreen_8c_a846c9667e34d56c560bb7f0ac6e173f6}{b}}\ =\ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}f3"{}},\ std::string>(\textcolor{stringliteral}{"{}Hello"{}})\ *\ \ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field<"{}f4"{},\ std::string>}}(\textcolor{stringliteral}{"{}World"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ \mbox{\hyperlink{bench_vec_add_8cpp_a41689956983587b085f9da3e48f31d99}{c}}\ =\ \mbox{\hyperlink{namespacerfl_a6ed469a6082d8180235db125c13fc410}{rfl::as<C>}}(\mbox{\hyperlink{_cwise__product_8cpp_ad2cbe4616e813eb9af81732dca777b24}{a}},\ \mbox{\hyperlink{offscreen_8c_a846c9667e34d56c560bb7f0ac6e173f6}{b}});}

\end{DoxyCode}


However, you do not really have to use {\ttfamily \doxylink{namespacerfl_a6ed469a6082d8180235db125c13fc410}{rfl\+::as}} here. This will work as well\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Same\ as\ rfl::as<C>(a,\ b)}}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ \mbox{\hyperlink{bench_vec_add_8cpp_a41689956983587b085f9da3e48f31d99}{c}}\ =\ \mbox{\hyperlink{test__buffer__node_8cpp_ac4cf4b2ab929bd23951a8676eeac086b}{C}}(\mbox{\hyperlink{_cwise__product_8cpp_ad2cbe4616e813eb9af81732dca777b24}{a}}\ *\ \mbox{\hyperlink{offscreen_8c_a846c9667e34d56c560bb7f0ac6e173f6}{b}});}

\end{DoxyCode}


(in fact, this is how {\ttfamily \doxylink{namespacerfl_a6ed469a6082d8180235db125c13fc410}{rfl\+::as}} is implemented in the first place).\hypertarget{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md612}{}\doxysection{\texorpdfstring{Defining named tuples using other named tuples}{Defining named tuples using other named tuples}}\label{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md612}
{\ttfamily \doxylink{structrfl_1_1_flatten}{rfl\+::\+Flatten}} is not supported inside named tuples. Instead, you can use {\ttfamily \doxylink{namespacerfl_ae957285d05ac374da54195649b4dbc00}{rfl\+::define\+\_\+named\+\_\+tuple\+\_\+t}\texorpdfstring{$<$}{<}...\texorpdfstring{$>$}{>}} to achieve the same goal\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ }Person\ =\ \mbox{\hyperlink{classrfl_1_1_named_tuple}{rfl::NamedTuple}}<}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}firstName"{}},\ std::string>,}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}lastName"{}},\ std::string>,}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}age"{}},\ \textcolor{keywordtype}{int}>>;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using\ }Employee\ =\ \mbox{\hyperlink{namespacerfl_ae957285d05ac374da54195649b4dbc00}{rfl::define\_named\_tuple\_t}}<}
\DoxyCodeLine{\ \ \ \ Person,}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field}}<\textcolor{stringliteral}{"{}salary"{}},\ \textcolor{keywordtype}{float}>>;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ employee\ =\ Employee(}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field<"{}firstName"{},\ std::string>}}(\textcolor{stringliteral}{"{}Homer"{}}),}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{structrfl_1_1_field}{rfl::Field<"{}lastName"{},\ std::string>}}(\textcolor{stringliteral}{"{}Simpson"{}}),}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespacerfl_afb5f68a22d5b6a42a5b4477c35559ce9}{rfl::make\_field<"{}age"{}>}}(45),}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespacerfl_afb5f68a22d5b6a42a5b4477c35559ce9}{rfl::make\_field<"{}salary"{}>}}(60000.0));}

\end{DoxyCode}
\hypertarget{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md613}{}\doxysection{\texorpdfstring{Transforming structs to named tuples and vice versa}{Transforming structs to named tuples and vice versa}}\label{md_external_2reflect-cpp_2docs_2named__tuple_autotoc_md613}
You can transform structs to named tuples and vice versa (this will only work with the {\ttfamily \doxylink{structrfl_1_1_field}{rfl\+::\+Field}}-\/syntax\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ bart\ =\ Person\{.first\_name\ =\ \textcolor{stringliteral}{"{}Bart"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .last\_name\ =\ \textcolor{stringliteral}{"{}Simpson"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .birthday\ =\ \textcolor{stringliteral}{"{}1987-\/04-\/19"{}}\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ bart\_nt\ is\ a\ named\ tuple}}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ bart\_nt\ =\ \mbox{\hyperlink{namespacerfl_a7d112596ec25825815ee5b2cae093110}{rfl::to\_named\_tuple}}(bart);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ You\ can\ also\ retrieve\ the\ equivalent\ named\ tuple}}
\DoxyCodeLine{\textcolor{comment}{//\ type\ to\ a\ struct:}}
\DoxyCodeLine{\textcolor{keyword}{using\ }PersonNamedTuple\ =\ \mbox{\hyperlink{namespacerfl_a8ed271477b7d12d3ed6fbc987e8ad999}{rfl::named\_tuple\_t<Person>}};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ rfl::to\_named\_tuple\ also\ supports\ move\ semantics}}
\DoxyCodeLine{PersonNamedTuple\ bart\_nt\ =\ \mbox{\hyperlink{namespacerfl_a7d112596ec25825815ee5b2cae093110}{rfl::to\_named\_tuple}}(std::move(bart\_nt));}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ You\ can\ also\ go\ the\ other\ way}}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ bart\_struct\ =\ \mbox{\hyperlink{namespacerfl_a5acb20e6bf6611a2a9f26931513b29f7}{rfl::from\_named\_tuple<Person>}}(bart\_nt);}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ bart\_struct\ =\ \mbox{\hyperlink{namespacerfl_a5acb20e6bf6611a2a9f26931513b29f7}{rfl::from\_named\_tuple<Person>}}(std::move(bart\_nt));}

\end{DoxyCode}
 